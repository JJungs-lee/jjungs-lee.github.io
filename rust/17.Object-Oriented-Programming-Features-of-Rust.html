<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.17.2 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html -->

<!----><title>Yes! I Take IT :)</title>
<meta name="description" content="Object Oriented Programming Features of RustObject-oriented programming (OOP) is a way of modeling programs. Objects came from Simula in the 1960s. Those objects influenced Alan Kay’s programming architecture in which objects pass messages to each other. He coined the term object-oriented programming in 1967 to describe this architecture. Many competing definitions describe what OOP is; some definitions would classify Rust as object oriented, but other definitions would not. In this chapter, we’ll explore certain characteristics that are commonly considered object oriented and how those characteristics translate to idiomatic Rust. We’ll then show you how to implement an object-oriented design pattern in Rust and discuss the trade-offs of doing so versus implementing a solution using some of Rust’s strengths instead.">


  <meta name="author" content="JJungs-lee">


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Yes! I Take IT">
<meta property="og:title" content="RUST : 17. Object Oriented Programming Features of Rust">
<meta property="og:url" content="https://jjungs-lee.github.io//rust/17.Object-Oriented-Programming-Features-of-Rust">


  <meta property="og:description" content="Object Oriented Programming Features of RustObject-oriented programming (OOP) is a way of modeling programs. Objects came from Simula in the 1960s. Those objects influenced Alan Kay’s programming architecture in which objects pass messages to each other. He coined the term object-oriented programming in 1967 to describe this architecture. Many competing definitions describe what OOP is; some definitions would classify Rust as object oriented, but other definitions would not. In this chapter, we’ll explore certain characteristics that are commonly considered object oriented and how those characteristics translate to idiomatic Rust. We’ll then show you how to implement an object-oriented design pattern in Rust and discuss the trade-offs of doing so versus implementing a solution using some of Rust’s strengths instead.">







  <meta property="article:published_time" content="2020-09-07T00:00:00+00:00">





  

  


<link rel="canonical" href="https://jjungs-lee.github.io//rust/17.Object-Oriented-Programming-Features-of-Rust">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "JJungs-lee",
      "url": "https://jjungs-lee.github.io//"
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="NONE" type="application/atom+xml" rel="alternate" title="Yes! I Take IT Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          <b>I.T.I</b> <small>by JHLee</small>
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/posts/" >Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/kernel/" >Kernel</a>
            </li><li class="masthead__menu-item">
              <a href="/swim/" >Swim</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="/assets/images/author_jhl.png" alt="JJungs-lee" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">JJungs-lee</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>Do Coding! Do Study!</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Somewhere</span>
        </li>
      

      
        
          
        
          
        
          
        
          
        
          
            <li><a href="https://github.com/jjungs-lee" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
          
        
          
        
          
            <li><a href="https://www.linkedin.com/in/jjungs-lee" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="RUST : 17. Object Oriented Programming Features of Rust">
    <meta itemprop="description" content="Object Oriented Programming Features of RustObject-oriented programming (OOP) is a way of modeling programs. Objects came from Simula in the 1960s. Those objects influenced Alan Kay’s programming architecture in which objects pass messages to each other. He coined the term object-oriented programming in 1967 to describe this architecture. Many competing definitions describe what OOP is; some definitions would classify Rust as object oriented, but other definitions would not. In this chapter, we’ll explore certain characteristics that are commonly considered object oriented and how those characteristics translate to idiomatic Rust. We’ll then show you how to implement an object-oriented design pattern in Rust and discuss the trade-offs of doing so versus implementing a solution using some of Rust’s strengths instead.">
    <meta itemprop="datePublished" content="2020-09-07T00:00:00+00:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">RUST : 17. Object Oriented Programming Features of Rust
</h1>
          
            <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  42 minute read

</p>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
        <h2 id="object-oriented-programming-features-of-rust">Object Oriented Programming Features of Rust</h2>
<p>Object-oriented programming (OOP) is a way of modeling programs. 
Objects came from Simula in the 1960s. 
Those objects influenced Alan Kay’s programming architecture in which objects pass messages to each other. 
He coined the term <em>object-oriented programming</em> in 1967 to describe this architecture. 
Many competing definitions describe what OOP is; some definitions would classify Rust as object oriented, but other definitions would not. 
In this chapter, we’ll explore certain characteristics that are commonly considered object oriented and how those characteristics translate to idiomatic Rust. 
We’ll then show you how to implement an object-oriented design pattern in Rust and discuss the trade-offs of doing so versus implementing a solution using some of Rust’s strengths instead.</p>

<h3 id="characteristics-of-object-oriented-languages">Characteristics of Object-Oriented Languages</h3>
<p>There is no consensus in the programming community about what features a language must have to be considered object oriented. 
Rust is influenced by many programming paradigms, including OOP; for example, we explored the features that came from functional programming in Chapter 13. 
Arguably, OOP languages share certain common characteristics, namely objects, encapsulation, and inheritance. 
Let’s look at what each of those characteristics means and whether Rust supports it.</p>

<h3 id="objects-contain-data-and-behavior">Objects Contain Data and Behavior</h3>
<p>The book <em>Design Patterns: Elements of Reusable Object-Oriented Software</em> by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wesley Professional, 1994) colloquially referred to as <em>The Gang of Four</em> book, is a catalog of object-oriented design patterns. It defines OOP this way:</p>

<p class="notice--info">Object-oriented programs are made up of objects. An object packages both data and the procedures that operate on that data. 
The procedures are typically called methods or operations.</p>

<p>Using this definition, Rust is object oriented: structs and enums have data, and <code class="language-plaintext highlighter-rouge">impl</code> blocks provide methods on structs and enums. 
Even though structs and enums with methods aren’t <em>called</em> objects, they provide the same functionality, according to the Gang of Four’s definition of objects.</p>

<h3 id="encapsulation-that-hides-implementation-details">Encapsulation that Hides Implementation Details</h3>
<p>Another aspect commonly associated with OOP is the idea of encapsulation, which means that the implementation details of an object aren’t accessible to code using that object. 
Therefore, the only way to interact with an object is through its public API; code using the object shouldn’t be able to reach into the object’s internals and change data or behavior directly. 
This enables the programmer to change and refactor an object’s internals without needing to change the code that uses the object.</p>

<p>We discussed how to control encapsulation in Chapter 7: we can use the <code class="language-plaintext highlighter-rouge">pub</code> keyword to decide which modules, types, functions, and methods in our code should be public, and by default everything else is private. 
For example, we can define a struct <code class="language-plaintext highlighter-rouge">AveragedCollection</code> that has a field containing a vector of <code class="language-plaintext highlighter-rouge">i32</code> values. 
The struct can also have a field that contains the average of the values in the vector, meaning the average doesn’t have to be computed on demand whenever anyone needs it. 
In other words, <code class="language-plaintext highlighter-rouge">AveragedCollection</code> will cache the calculated average for us. Listing 17-1 has the definition of the <code class="language-plaintext highlighter-rouge">AveragedCollection</code> struct:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">AveragedCollection</span> <span class="p">{</span>
    <span class="n">list</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">average</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-17-1-an-averagedcollection-struct-that-maintains-a-list-of-integers-and-the-average-of-the-items-in-the-collection">Listing 17-1: An AveragedCollection struct that maintains a list of integers and the average of the items in the collection</h4>

<p>The struct is marked <code class="language-plaintext highlighter-rouge">pub</code> so that other code can use it, but the fields within the struct remain private. 
This is important in this case because we want to ensure that whenever a value is added or removed from the list, the average is also updated. 
We do this by implementing <code class="language-plaintext highlighter-rouge">add</code>, <code class="language-plaintext highlighter-rouge">remove</code>, and <code class="language-plaintext highlighter-rouge">average</code> methods on the struct, as shown in Listing 17-2:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>
<span class="k">impl</span> <span class="n">AveragedCollection</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.list</span><span class="nf">.push</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.update_average</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">remove</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="k">self</span><span class="py">.list</span><span class="nf">.pop</span><span class="p">();</span>
        <span class="k">match</span> <span class="n">result</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.update_average</span><span class="p">();</span>
                <span class="nf">Some</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">average</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">f64</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.average</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">update_average</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">total</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="k">self</span><span class="py">.list</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.sum</span><span class="p">();</span>
        <span class="k">self</span><span class="py">.average</span> <span class="o">=</span> <span class="n">total</span> <span class="k">as</span> <span class="nb">f64</span> <span class="o">/</span> <span class="k">self</span><span class="py">.list</span><span class="nf">.len</span><span class="p">()</span> <span class="k">as</span> <span class="nb">f64</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-17-2-implementations-of-the-public-methods-add-remove-and-average-on-averagedcollection">Listing 17-2: Implementations of the public methods add, remove, and average on AveragedCollection</h4>

<p>The public methods <code class="language-plaintext highlighter-rouge">add</code>, <code class="language-plaintext highlighter-rouge">remove</code>, and <code class="language-plaintext highlighter-rouge">average</code> are the only ways to access or modify data in an instance of <code class="language-plaintext highlighter-rouge">AveragedCollection</code>. 
When an item is added to <code class="language-plaintext highlighter-rouge">list</code> using the <code class="language-plaintext highlighter-rouge">add</code> method or removed using the <code class="language-plaintext highlighter-rouge">remove</code> method, the implementations of each call the private <code class="language-plaintext highlighter-rouge">update_average</code> method that handles updating the <code class="language-plaintext highlighter-rouge">average</code> field as well.</p>

<p>We leave the <code class="language-plaintext highlighter-rouge">list</code> and <code class="language-plaintext highlighter-rouge">average</code> fields private so there is no way for external code to add or remove items to the <code class="language-plaintext highlighter-rouge">list</code> field directly; otherwise, the <code class="language-plaintext highlighter-rouge">average</code> field might become out of sync when the <code class="language-plaintext highlighter-rouge">list</code> changes. 
The <code class="language-plaintext highlighter-rouge">average</code> method returns the value in the <code class="language-plaintext highlighter-rouge">average</code> field, allowing external code to read the <code class="language-plaintext highlighter-rouge">average</code> but not modify it.</p>

<p>Because we’ve encapsulated the implementation details of the struct <code class="language-plaintext highlighter-rouge">AveragedCollection</code>, we can easily change aspects, such as the data structure, in the future. 
For instance, we could use a <code class="language-plaintext highlighter-rouge">HashSet&lt;i32&gt;</code> instead of a <code class="language-plaintext highlighter-rouge">Vec&lt;i32&gt;</code> for the <code class="language-plaintext highlighter-rouge">list</code> field. 
As long as the signatures of the <code class="language-plaintext highlighter-rouge">add</code>, <code class="language-plaintext highlighter-rouge">remove</code>, and <code class="language-plaintext highlighter-rouge">average</code> public methods stay the same, code using <code class="language-plaintext highlighter-rouge">AveragedCollection</code> wouldn’t need to change. 
If we made <code class="language-plaintext highlighter-rouge">list</code> public instead, this wouldn’t necessarily be the case: <code class="language-plaintext highlighter-rouge">HashSet&lt;i32&gt;</code> and <code class="language-plaintext highlighter-rouge">Vec&lt;i32&gt;</code> have different methods for adding and removing items, so the external code would likely have to change if it were modifying <code class="language-plaintext highlighter-rouge">list</code> directly.</p>

<p>If encapsulation is a required aspect for a language to be considered object oriented, then Rust meets that requirement. 
The option to use <code class="language-plaintext highlighter-rouge">pub</code> or not for different parts of code enables encapsulation of implementation details.</p>

<h3 id="inheritance-as-a-type-system-and-as-code-sharing">Inheritance as a Type System and as Code Sharing</h3>
<p><em>Inheritance</em> is a mechanism whereby an object can inherit from another object’s definition, thus gaining the parent object’s data and behavior without you having to define them again.</p>

<p>If a language must have inheritance to be an object-oriented language, then Rust is not one. 
There <strong>is no way</strong> to define a struct that inherits the parent struct’s fields and method implementations. 
However, if you’re used to having inheritance in your programming toolbox, you can use other solutions in Rust, depending on your reason for reaching for inheritance in the first place.</p>

<p>You choose inheritance for two main reasons. 
One is for reuse of code: you can implement particular behavior for one type, and inheritance enables you to reuse that implementation for a different type. 
You can share Rust code using default trait method implementations instead, which you saw in Listing 10-14 when we added a default implementation of the <code class="language-plaintext highlighter-rouge">summarize</code> method on the <code class="language-plaintext highlighter-rouge">Summary</code> trait. 
Any type implementing the <code class="language-plaintext highlighter-rouge">Summary</code> trait would have the <code class="language-plaintext highlighter-rouge">summarize</code> method available on it without any further code. 
This is similar to a parent class having an implementation of a method and an inheriting child class also having the implementation of the method. 
We can also override the default implementation of the <code class="language-plaintext highlighter-rouge">summarize</code> method when we implement the <code class="language-plaintext highlighter-rouge">Summary</code> trait, which is similar to a child class overriding the implementation of a method inherited from a parent class.</p>

<p>The other reason to use inheritance relates to the type system: to enable a child type to be used in the same places as the parent type. 
This is also called <em>polymorphism</em>, which means that you can substitute multiple objects for each other at runtime if they share certain characteristics.</p>

<p class="notice--info"><strong>Polymorphism</strong>  <br />
To many people, polymorphism is synonymous with inheritance. But it’s actually a more general concept that refers to code that can work with data of multiple types. For inheritance, those types are generally subclasses.<br />
Rust instead uses generics to abstract over different possible types and trait bounds to impose constraints on what those types must provide. This is sometimes called <em>bounded parametric polymorphism</em>.
The procedures are typically called methods or operations.</p>

<p>Inheritance has recently fallen out of favor as a programming design solution in many programming languages because it’s often at risk of sharing more code than necessary. 
Subclasses shouldn’t always share all characteristics of their parent class but will do so with inheritance. 
This can make a program’s design less flexible. 
It also introduces the possibility of calling methods on subclasses that don’t make sense or that cause errors because the methods don’t apply to the subclass. 
In addition, some languages will only allow a subclass to inherit from one class, further restricting the flexibility of a program’s design.</p>

<p>For these reasons, Rust takes a different approach, using trait objects instead of inheritance. 
Let’s look at how trait objects enable polymorphism in Rust.</p>

<h3 id="using-trait-objects-that-allow-for-values-of-different-types">Using Trait Objects That Allow for Values of Different Types</h3>
<p>In Chapter 8, we mentioned that one limitation of vectors is that they can store elements of only one type. 
We created a workaround in Listing 8-10 where we defined a <code class="language-plaintext highlighter-rouge">SpreadsheetCell</code> enum that had variants to hold integers, floats, and text. 
This meant we could store different types of data in each cell and still have a vector that represented a row of cells. 
This is a perfectly good solution when our interchangeable items are a fixed set of types that we know when our code is compiled.</p>

<p>However, sometimes we want our library user to be able to extend the set of types that are valid in a particular situation. 
To show how we might achieve this, we’ll create an example graphical user interface (GUI) tool that iterates through a list of items, calling a <code class="language-plaintext highlighter-rouge">draw</code> method on each one to draw it to the screen—a common technique for GUI tools. 
We’ll create a library crate called <code class="language-plaintext highlighter-rouge">gui</code> that contains the structure of a GUI library. 
This crate might include some types for people to use, such as <code class="language-plaintext highlighter-rouge">Button</code> or <code class="language-plaintext highlighter-rouge">TextField</code>. 
In addition, <code class="language-plaintext highlighter-rouge">gui</code> users will want to create their own types that can be drawn: for instance, one programmer might add an <code class="language-plaintext highlighter-rouge">Image</code> and another might add a <code class="language-plaintext highlighter-rouge">SelectBox</code>.</p>

<p>We won’t implement a fully fledged GUI library for this example but will show how the pieces would fit together. 
At the time of writing the library, we can’t know and define all the types other programmers might want to create. 
But we do know that <code class="language-plaintext highlighter-rouge">gui</code> needs to keep track of many values of different types, and it needs to call a <code class="language-plaintext highlighter-rouge">draw</code> method on each of these differently typed values. 
It doesn’t need to know exactly what will happen when we call the <code class="language-plaintext highlighter-rouge">draw</code> method, just that the value will have that method available for us to call.</p>

<p>To do this in a language with inheritance, we might define a class named <code class="language-plaintext highlighter-rouge">Component</code> that has a method named <code class="language-plaintext highlighter-rouge">draw</code> on it. 
The other classes, such as <code class="language-plaintext highlighter-rouge">Button</code>, <code class="language-plaintext highlighter-rouge">Image</code>, and <code class="language-plaintext highlighter-rouge">SelectBox</code>, would inherit from <code class="language-plaintext highlighter-rouge">Component</code> and thus inherit the <code class="language-plaintext highlighter-rouge">draw</code> method. 
They could each override the <code class="language-plaintext highlighter-rouge">draw</code> method to define their custom behavior, but the framework could treat all of the types as if they were <code class="language-plaintext highlighter-rouge">Component</code> instances and call <code class="language-plaintext highlighter-rouge">draw</code> on them. 
But because Rust doesn’t have inheritance, we need another way to structure the <code class="language-plaintext highlighter-rouge">gui</code> library to allow users to extend it with new types.</p>

<h3 id="defining-a-trait-for-common-behavior">Defining a Trait for Common Behavior</h3>
<p>To implement the behavior we want <code class="language-plaintext highlighter-rouge">gui</code> to have, we’ll define a trait named <code class="language-plaintext highlighter-rouge">Draw</code> that will have one method named <code class="language-plaintext highlighter-rouge">draw</code>. 
Then we can define a vector that takes a <em>trait object</em>. 
A trait object points to both an instance of a type implementing our specified trait as well as a table used to look up trait methods on that type at runtime. 
We create a trait object by specifying some sort of pointer, such as a <code class="language-plaintext highlighter-rouge">&amp;</code> reference or a <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> smart pointer, then the <code class="language-plaintext highlighter-rouge">dyn</code> keyword, and then specifying the relevant trait. 
(We’ll talk about the reason trait objects must use a pointer in Chapter 19 in the section “Dynamically Sized Types and the Sized Trait.”) We can use trait objects in place of a generic or concrete type. 
Wherever we use a trait object, Rust’s type system will ensure at compile time that any value used in that context will implement the trait object’s trait. 
Consequently, we don’t need to know all the possible types at compile time.</p>

<p>We’ve mentioned that in Rust, we refrain from calling structs and enums “objects” to distinguish them from other languages’ objects. 
In a struct or enum, the data in the struct fields and the behavior in <code class="language-plaintext highlighter-rouge">impl</code> blocks are separated, whereas in other languages, the data and behavior combined into one concept is often labeled an object. 
However, trait objects <em>are</em> more like objects in other languages in the sense that they combine data and behavior. 
But trait objects <strong>differ</strong> from traditional objects in that we can’t add data to a trait object. 
Trait objects aren’t as generally useful as objects in other languages: their specific purpose is to allow abstraction across common behavior.</p>

<p>Listing 17-3 shows how to define a trait named <code class="language-plaintext highlighter-rouge">Draw</code> with one method named <code class="language-plaintext highlighter-rouge">draw</code>:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>

<span class="k">pub</span> <span class="k">trait</span> <span class="n">Draw</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">draw</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-17-3-definition-of-the-draw-trait">Listing 17-3: Definition of the Draw trait</h4>

<p>This syntax should look familiar from our discussions on how to define traits in Chapter 10. 
Next comes some new syntax: Listing 17-4 defines a struct named <code class="language-plaintext highlighter-rouge">Screen</code> that holds a vector named <code class="language-plaintext highlighter-rouge">components</code>. 
This vector is of type <code class="language-plaintext highlighter-rouge">Box&lt;dyn Draw&gt;</code>, which is a trait object; it’s a stand-in for any type inside a <code class="language-plaintext highlighter-rouge">Box</code> that implements the <code class="language-plaintext highlighter-rouge">Draw</code> trait.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Screen</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">components</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">Draw</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-17-4-definition-of-the-screen-struct-with-a-components-field-holding-a-vector-of-trait-objects-that-implement-the-draw-trait">Listing 17-4: Definition of the Screen struct with a components field holding a vector of trait objects that implement the Draw trait</h4>

<p>On the <code class="language-plaintext highlighter-rouge">Screen</code> struct, we’ll define a method named <code class="language-plaintext highlighter-rouge">run</code> that will call the draw method on each of its <code class="language-plaintext highlighter-rouge">components</code>, as shown in Listing 17-5:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>

<span class="k">impl</span> <span class="n">Screen</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">component</span> <span class="k">in</span> <span class="k">self</span><span class="py">.components</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">component</span><span class="nf">.draw</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-17-5-a-run-method-on-screen-that-calls-the-draw-method-on-each-component">Listing 17-5: A run method on Screen that calls the draw method on each component</h4>

<p>This works differently from defining a struct that uses a generic type parameter with trait bounds. 
A generic type parameter can only be substituted with <strong>one</strong> concrete type at a time, whereas trait objects allow for <strong>multiple</strong> concrete types to fill in for the trait object at runtime. 
For example, we could have defined the <code class="language-plaintext highlighter-rouge">Screen</code> struct using a generic type and a trait bound as in Listing 17-6:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Screen</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Draw</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">components</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Screen</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="n">Draw</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">component</span> <span class="k">in</span> <span class="k">self</span><span class="py">.components</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">component</span><span class="nf">.draw</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-17-6-an-alternate-implementation-of-the-screen-struct-and-its-run-method-using-generics-and-trait-bounds">Listing 17-6: An alternate implementation of the Screen struct and its run method using generics and trait bounds</h4>

<p>This restricts us to a <code class="language-plaintext highlighter-rouge">Screen</code> instance that has a list of components all of type <code class="language-plaintext highlighter-rouge">Button</code> or all of type <code class="language-plaintext highlighter-rouge">TextField</code>. 
If you’ll only ever have homogeneous collections, using generics and trait bounds is preferable because the definitions will be monomorphized at compile time to use the concrete types.</p>

<p>On the other hand, with the method using trait objects, one <code class="language-plaintext highlighter-rouge">Screen</code> instance can hold a <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code> that contains a <code class="language-plaintext highlighter-rouge">Box&lt;Button&gt;</code> as well as a <code class="language-plaintext highlighter-rouge">Box&lt;TextField&gt;</code>. 
Let’s look at how this works, and then we’ll talk about the runtime performance implications.</p>

<h3 id="implementing-the-trait">Implementing the Trait</h3>
<p>Now we’ll add some types that implement the <code class="language-plaintext highlighter-rouge">Draw</code> trait. 
We’ll provide the <code class="language-plaintext highlighter-rouge">Button</code> type. 
Again, actually implementing a GUI library is beyond the scope of this book, so the <code class="language-plaintext highlighter-rouge">draw</code> method won’t have any useful implementation in its body. 
To imagine what the implementation might look like, a <code class="language-plaintext highlighter-rouge">Button</code> struct might have fields for <code class="language-plaintext highlighter-rouge">width</code>, <code class="language-plaintext highlighter-rouge">height</code>, and <code class="language-plaintext highlighter-rouge">label</code>, as shown in Listing 17-7:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Button</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">width</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">height</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">label</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Draw</span> <span class="k">for</span> <span class="n">Button</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">draw</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// code to actually draw a button</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-17-7-a-button-struct-that-implements-the-draw-trait">Listing 17-7: A Button struct that implements the Draw trait</h4>

<p>The <code class="language-plaintext highlighter-rouge">width</code>, <code class="language-plaintext highlighter-rouge">height</code>, and <code class="language-plaintext highlighter-rouge">label</code> fields on <code class="language-plaintext highlighter-rouge">Button</code> will differ from the fields on other components, such as a <code class="language-plaintext highlighter-rouge">TextField</code> type, that might have those fields plus a <code class="language-plaintext highlighter-rouge">placeholder</code> field instead. 
Each of the types we want to draw on the screen will implement the <code class="language-plaintext highlighter-rouge">Draw</code> trait but will use different code in the <code class="language-plaintext highlighter-rouge">draw</code> method to define how to draw that particular type, as <code class="language-plaintext highlighter-rouge">Button</code> has here (without the actual GUI code, which is beyond the scope of this chapter). 
The <code class="language-plaintext highlighter-rouge">Button</code> type, for instance, might have an additional <code class="language-plaintext highlighter-rouge">impl</code> block containing methods related to what happens when a user clicks the button. 
These kinds of methods won’t apply to types like <code class="language-plaintext highlighter-rouge">TextField</code>.</p>

<p>If someone using our library decides to implement a <code class="language-plaintext highlighter-rouge">SelectBox</code> struct that has <code class="language-plaintext highlighter-rouge">width</code>, <code class="language-plaintext highlighter-rouge">height</code>, and <code class="language-plaintext highlighter-rouge">options</code> fields, they implement the <code class="language-plaintext highlighter-rouge">Draw</code> trait on the <code class="language-plaintext highlighter-rouge">SelectBox</code> type as well, as shown in Listing 17-8:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">use</span> <span class="nn">gui</span><span class="p">::</span><span class="n">Draw</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">SelectBox</span> <span class="p">{</span>
    <span class="n">width</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">height</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">options</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Draw</span> <span class="k">for</span> <span class="n">SelectBox</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">draw</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// code to actually draw a select box</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-17-8-another-crate-using-gui-and-implementing-the-draw-trait-on-a-selectbox-struct">Listing 17-8: Another crate using gui and implementing the Draw trait on a SelectBox struct</h4>

<p>Our library’s user can now write their <code class="language-plaintext highlighter-rouge">main</code> function to create a <code class="language-plaintext highlighter-rouge">Screen</code> instance. 
To the <code class="language-plaintext highlighter-rouge">Screen</code> instance, they can add a <code class="language-plaintext highlighter-rouge">SelectBox</code> and a <code class="language-plaintext highlighter-rouge">Button</code> by putting each in a <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> to become a trait object. 
They can then call the <code class="language-plaintext highlighter-rouge">run</code> method on the <code class="language-plaintext highlighter-rouge">Screen</code> instance, which will call <code class="language-plaintext highlighter-rouge">draw</code> on each of the components. Listing 17-9 shows this implementation:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">use</span> <span class="nn">gui</span><span class="p">::{</span><span class="n">Button</span><span class="p">,</span> <span class="n">Screen</span><span class="p">};</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">screen</span> <span class="o">=</span> <span class="n">Screen</span> <span class="p">{</span>
        <span class="n">components</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span>
            <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">SelectBox</span> <span class="p">{</span>
                <span class="n">width</span><span class="p">:</span> <span class="mi">75</span><span class="p">,</span>
                <span class="n">height</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
                <span class="n">options</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span>
                    <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Yes"</span><span class="p">),</span>
                    <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Maybe"</span><span class="p">),</span>
                    <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"No"</span><span class="p">),</span>
                <span class="p">],</span>
            <span class="p">}),</span>
            <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Button</span> <span class="p">{</span>
                <span class="n">width</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span>
                <span class="n">height</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
                <span class="n">label</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"OK"</span><span class="p">),</span>
            <span class="p">}),</span>
        <span class="p">],</span>
    <span class="p">};</span>

    <span class="n">screen</span><span class="nf">.run</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-17-9-using-trait-objects-to-store-values-of-different-types-that-implement-the-same-trait">Listing 17-9: Using trait objects to store values of different types that implement the same trait</h4>

<p>When we wrote the library, we didn’t know that someone might add the <code class="language-plaintext highlighter-rouge">SelectBox</code> type, but our <code class="language-plaintext highlighter-rouge">Screen</code> implementation was able to operate on the new type and draw it because <code class="language-plaintext highlighter-rouge">SelectBox</code> implements the <code class="language-plaintext highlighter-rouge">Draw</code> trait, which means it implements the <code class="language-plaintext highlighter-rouge">draw</code> method.</p>

<p>This concept—of being concerned only with the messages a value responds to rather than the value’s concrete type—is similar to the concept of <em>duck typing</em> in dynamically typed languages: if it walks like a duck and quacks like a duck, then it must be a duck! In the implementation of <code class="language-plaintext highlighter-rouge">run</code> on <code class="language-plaintext highlighter-rouge">Screen</code> in Listing 17-5, <code class="language-plaintext highlighter-rouge">run</code> doesn’t need to know what the concrete type of each component is. 
It doesn’t check whether a component is an instance of a <code class="language-plaintext highlighter-rouge">Button</code> or a <code class="language-plaintext highlighter-rouge">SelectBox</code>, it just calls the <code class="language-plaintext highlighter-rouge">draw</code> method on the component. 
By specifying <code class="language-plaintext highlighter-rouge">Box&lt;dyn Draw&gt;</code> as the type of the values in the <code class="language-plaintext highlighter-rouge">components</code> vector, we’ve defined <code class="language-plaintext highlighter-rouge">Screen</code> to need values that we can call the <code class="language-plaintext highlighter-rouge">draw</code> method on.</p>

<p>The advantage of using trait objects and Rust’s type system to write code similar to code using duck typing is that we never have to check whether a value implements a particular method at runtime or worry about getting errors if a value doesn’t implement a method but we call it anyway. 
Rust won’t compile our code if the values don’t implement the traits that the trait objects need.</p>

<p>For example, Listing 17-10 shows what happens if we try to create a <code class="language-plaintext highlighter-rouge">Screen</code> with a <code class="language-plaintext highlighter-rouge">String</code> as a component:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">use</span> <span class="nn">gui</span><span class="p">::</span><span class="n">Screen</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">screen</span> <span class="o">=</span> <span class="n">Screen</span> <span class="p">{</span>
        <span class="n">components</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Hi"</span><span class="p">))],</span>
    <span class="p">};</span>

    <span class="n">screen</span><span class="nf">.run</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-17-10-attempting-to-use-a-type-that-doesnt-implement-the-trait-objects-trait">Listing 17-10: Attempting to use a type that doesn’t implement the trait object’s trait</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="n">gui</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/gui)</span>
<span class="n">error</span><span class="p">[</span><span class="n">E0277</span><span class="p">]:</span> <span class="n">the</span> <span class="k">trait</span> <span class="n">bound</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">string</span><span class="p">::</span><span class="nb">String</span><span class="p">:</span> <span class="nn">gui</span><span class="p">::</span><span class="n">Draw</span><span class="err">`</span> <span class="n">is</span> <span class="n">not</span> <span class="n">satisfied</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span><span class="mi">26</span>
  <span class="p">|</span>
<span class="mi">5</span> <span class="p">|</span>         <span class="n">components</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Hi"</span><span class="p">))],</span>
  <span class="p">|</span>                          <span class="o">^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span> <span class="n">the</span> <span class="k">trait</span> <span class="err">`</span><span class="nn">gui</span><span class="p">::</span><span class="n">Draw</span><span class="err">`</span> <span class="n">is</span> <span class="n">not</span> <span class="n">implemented</span> <span class="k">for</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">string</span><span class="p">::</span><span class="nb">String</span><span class="err">`</span>
  <span class="p">|</span>
  <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">required</span> <span class="k">for</span> <span class="n">the</span> <span class="n">cast</span> <span class="n">to</span> <span class="n">the</span> <span class="n">object</span> <span class="k">type</span> <span class="err">`</span><span class="k">dyn</span> <span class="nn">gui</span><span class="p">::</span><span class="n">Draw</span><span class="err">`</span>

<span class="n">error</span><span class="p">:</span> <span class="n">aborting</span> <span class="n">due</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">error</span>

<span class="n">For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">about</span> <span class="n">this</span> <span class="n">error</span><span class="p">,</span> <span class="k">try</span> <span class="err">`</span><span class="n">rustc</span> <span class="o">--</span><span class="n">explain</span> <span class="n">E0277</span><span class="err">`</span><span class="py">.
error</span><span class="p">:</span> <span class="n">could</span> <span class="n">not</span> <span class="n">compile</span> <span class="err">`</span><span class="n">gui</span><span class="err">`</span><span class="py">.

To</span> <span class="n">learn</span> <span class="n">more</span><span class="p">,</span> <span class="n">run</span> <span class="n">the</span> <span class="n">command</span> <span class="n">again</span> <span class="n">with</span> <span class="o">--</span><span class="n">verbose</span><span class="err">.</span>
</code></pre></div></div>
<p>This error lets us know that either we’re passing something to <code class="language-plaintext highlighter-rouge">Screen</code> we didn’t mean to pass and we should pass a different type or we should implement <code class="language-plaintext highlighter-rouge">Draw</code> on <code class="language-plaintext highlighter-rouge">String</code> so that <code class="language-plaintext highlighter-rouge">Screen</code> is able to call <code class="language-plaintext highlighter-rouge">draw</code> on it.</p>

<h3 id="trait-objects-perform-dynamic-dispatch">Trait Objects Perform Dynamic Dispatch</h3>
<p>Recall in the “Performance of Code Using Generics” section in Chapter 10 our discussion on the monomorphization process performed by the compiler when we use trait bounds on generics: the compiler generates nongeneric implementations of functions and methods for each concrete type that we use in place of a generic type parameter. 
The code that results from monomorphization is doing <em>static dispatch</em>, which is when the compiler knows what method you’re calling at compile time. 
This is opposed to <em>dynamic dispatch</em>, which is when the compiler can’t tell at compile time which method you’re calling. 
In dynamic dispatch cases, the compiler emits code that at runtime will figure out which method to call.</p>

<p>When we use trait objects, Rust must use <strong>dynamic dispatch</strong>. 
The compiler doesn’t know all the types that might be used with the code that is using trait objects, so it doesn’t know which method implemented on which type to call. 
Instead, at runtime, Rust uses the pointers inside the trait object to know which method to call. 
There is a runtime cost when this lookup happens that doesn’t occur with static dispatch. 
Dynamic dispatch also prevents the compiler from choosing to inline a method’s code, which in turn prevents some optimizations. 
However, we did get extra flexibility in the code that we wrote in Listing 17-5 and were able to support in Listing 17-9, so it’s a trade-off to consider.</p>

<h3 id="object-safety-is-required-for-trait-objects">Object Safety Is Required for Trait Objects</h3>
<p>You can only make <em>object-safe</em> traits into trait objects. 
Some complex rules govern all the properties that make a trait object safe, but in practice, only <strong>two</strong> rules are relevant. 
A trait is object safe if all the methods defined in the trait have the following properties:</p>

<ul>
  <li>The return type isn’t Self.</li>
  <li>There are no generic type parameters.</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">Self</code> keyword is an alias for the type we’re implementing the traits or methods on. 
Trait objects must be object safe because once you’ve used a trait object, Rust no longer knows the concrete type that’s implementing that trait. 
If a trait method returns the concrete <code class="language-plaintext highlighter-rouge">Self</code> type, but a trait object forgets the exact type that <code class="language-plaintext highlighter-rouge">Self</code> is, there is no way the method can use the original concrete type. 
The same is true of generic type parameters that are filled in with concrete type parameters when the trait is used: the concrete types become part of the type that implements the trait. 
When the type is forgotten through the use of a trait object, there is no way to know what types to fill in the generic type parameters with.</p>

<p>An example of a trait whose methods are not object safe is the standard library’s <code class="language-plaintext highlighter-rouge">Clone</code> trait. 
The signature for the <code class="language-plaintext highlighter-rouge">clone</code> method in the <code class="language-plaintext highlighter-rouge">Clone</code> trait looks like this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="nb">Clone</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">String</code> type implements the <code class="language-plaintext highlighter-rouge">Clone</code> trait, and when we call the <code class="language-plaintext highlighter-rouge">clone</code> method on an instance of <code class="language-plaintext highlighter-rouge">String</code> we get back an instance of <code class="language-plaintext highlighter-rouge">String</code>. 
Similarly, if we call <code class="language-plaintext highlighter-rouge">clone</code> on an instance of <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code>, we get back an instance of <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code>. 
The signature of <code class="language-plaintext highlighter-rouge">clone</code> needs to know what type will stand in for <code class="language-plaintext highlighter-rouge">Self</code>, because that’s the return type.</p>

<p>The compiler will indicate when you’re trying to do something that violates the rules of object safety in regard to trait objects. 
For example, let’s say we tried to implement the <code class="language-plaintext highlighter-rouge">Screen</code> struct in Listing 17-4 to hold types that implement the <code class="language-plaintext highlighter-rouge">Clone</code> trait instead of the Draw trait, like this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">Screen</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">components</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nb">Clone</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>
<p>We would get this error:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">build</span>
   <span class="n">Compiling</span> <span class="n">gui</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/gui)</span>
<span class="n">error</span><span class="p">[</span><span class="n">E0038</span><span class="p">]:</span> <span class="n">the</span> <span class="k">trait</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">clone</span><span class="p">::</span><span class="nb">Clone</span><span class="err">`</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">made</span> <span class="n">into</span> <span class="n">an</span> <span class="n">object</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">lib</span><span class="py">.rs</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span>
  <span class="p">|</span>
<span class="mi">2</span> <span class="p">|</span>     <span class="k">pub</span> <span class="n">components</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nb">Clone</span><span class="o">&gt;&gt;</span><span class="p">,</span>
  <span class="p">|</span>     <span class="o">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span> <span class="n">the</span> <span class="k">trait</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">clone</span><span class="p">::</span><span class="nb">Clone</span><span class="err">`</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">made</span> <span class="n">into</span> <span class="n">an</span> <span class="n">object</span>
  <span class="p">|</span>
  <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">the</span> <span class="k">trait</span> <span class="n">cannot</span> <span class="n">require</span> <span class="n">that</span> <span class="err">`</span><span class="k">Self</span> <span class="p">:</span> <span class="nb">Sized</span><span class="err">`</span>

<span class="n">error</span><span class="p">:</span> <span class="n">aborting</span> <span class="n">due</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">error</span>

<span class="n">For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">about</span> <span class="n">this</span> <span class="n">error</span><span class="p">,</span> <span class="k">try</span> <span class="err">`</span><span class="n">rustc</span> <span class="o">--</span><span class="n">explain</span> <span class="n">E0038</span><span class="err">`</span><span class="py">.
error</span><span class="p">:</span> <span class="n">could</span> <span class="n">not</span> <span class="n">compile</span> <span class="err">`</span><span class="n">gui</span><span class="err">`</span><span class="py">.

To</span> <span class="n">learn</span> <span class="n">more</span><span class="p">,</span> <span class="n">run</span> <span class="n">the</span> <span class="n">command</span> <span class="n">again</span> <span class="n">with</span> <span class="o">--</span><span class="n">verbose</span><span class="err">.</span>
</code></pre></div></div>

<p>This error means you can’t use this trait as a trait object in this way. If you’re interested in more details on object safety, see <a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">Rust RFC 255</a>.</p>

<h2 id="implementing-an-object-oriented-design-pattern">Implementing an Object-Oriented Design Pattern</h2>
<p>The <code class="language-plaintext highlighter-rouge">state pattern</code> is an object-oriented design pattern. 
The crux of the pattern is that a value has some internal state, which is represented by a set of <em>state objects</em>, and the value’s behavior changes based on the internal state. 
The state objects share functionality: in Rust, of course, we use structs and traits rather than objects and inheritance. 
Each state object is responsible for its own behavior and for governing when it should change into another state. 
The value that holds a state object knows nothing about the different behavior of the states or when to transition between states.</p>

<p>Using the state pattern means when the business requirements of the program change, we won’t need to change the code of the value holding the state or the code that uses the value. 
We’ll only need to update the code inside one of the state objects to change its rules or perhaps add more state objects. 
Let’s look at an example of the state design pattern and how to use it in Rust.</p>

<p>We’ll implement a blog post workflow in an incremental way. 
The blog’s final functionality will look like this:</p>

<ol>
  <li>A blog post starts as an empty draft.</li>
  <li>When the draft is done, a review of the post is requested.</li>
  <li>When the post is approved, it gets published.</li>
  <li>Only published blog posts return content to print, so unapproved posts can’t accidentally be published.</li>
</ol>

<p>Any other changes attempted on a post should have no effect. 
For example, if we try to approve a draft blog post before we’ve requested a review, the post should remain an unpublished draft.</p>

<p>Listing 17-11 shows this workflow in code form: this is an example usage of the API we’ll implement in a library crate named <code class="language-plaintext highlighter-rouge">blog</code>. 
This won’t compile yet because we haven’t implemented the <code class="language-plaintext highlighter-rouge">blog</code> crate yet.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">use</span> <span class="nn">blog</span><span class="p">::</span><span class="n">Post</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">post</span> <span class="o">=</span> <span class="nn">Post</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="n">post</span><span class="nf">.add_text</span><span class="p">(</span><span class="s">"I ate a salad for lunch today"</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="s">""</span><span class="p">,</span> <span class="n">post</span><span class="nf">.content</span><span class="p">());</span>

    <span class="n">post</span><span class="nf">.request_review</span><span class="p">();</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="s">""</span><span class="p">,</span> <span class="n">post</span><span class="nf">.content</span><span class="p">());</span>

    <span class="n">post</span><span class="nf">.approve</span><span class="p">();</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="s">"I ate a salad for lunch today"</span><span class="p">,</span> <span class="n">post</span><span class="nf">.content</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-17-11-code-that-demonstrates-the-desired-behavior-we-want-our-blog-crate-to-have">Listing 17-11: Code that demonstrates the desired behavior we want our blog crate to have</h4>

<p>We want to allow the user to create a new draft blog post with <code class="language-plaintext highlighter-rouge">Post::new</code>. 
Then we want to allow text to be added to the blog post while it’s in the draft state. 
If we try to get the post’s content immediately, before approval, nothing should happen because the post is still a draft. 
We’ve added <code class="language-plaintext highlighter-rouge">assert_eq!</code> in the code for demonstration purposes. 
An excellent unit test for this would be to assert that a draft blog post returns an empty string from the <code class="language-plaintext highlighter-rouge">content</code> method, but we’re not going to write tests for this example.</p>

<p>Next, we want to enable a request for a review of the post, and we want <code class="language-plaintext highlighter-rouge">content</code> to return an empty string while waiting for the review. 
When the post receives approval, it should get published, meaning the text of the post will be returned when <code class="language-plaintext highlighter-rouge">content</code> is called.</p>

<p>Notice that the only type we’re interacting with from the crate is the <code class="language-plaintext highlighter-rouge">Post</code> type. 
This type will use the state pattern and will hold a value that will be one of three state objects representing the various states a post can be in—draft, waiting for review, or published. 
Changing from one state to another will be managed internally within the <code class="language-plaintext highlighter-rouge">Post</code> type. 
The states change in response to the methods called by our library’s users on the Post instance, but they don’t have to manage the state changes directly. 
Also, users can’t make a mistake with the states, like publishing a post before it’s reviewed.</p>

<h3 id="defining-post-and-creating-a-new-instance-in-the-draft-state">Defining Post and Creating a New Instance in the Draft State</h3>
<p>Let’s get started on the implementation of the library! 
We know we need a public <code class="language-plaintext highlighter-rouge">Post</code> struct that holds some content, so we’ll start with the definition of the struct and an associated public <code class="language-plaintext highlighter-rouge">new</code> function to create an instance of <code class="language-plaintext highlighter-rouge">Post</code>, as shown in Listing 17-12. 
We’ll also make a private <code class="language-plaintext highlighter-rouge">State</code> trait. 
Then Post will hold a trait object of <code class="language-plaintext highlighter-rouge">Box&lt;dyn State&gt;</code> inside an <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code> in a private field named state. 
You’ll see why the <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code> is necessary in a bit.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Post</span> <span class="p">{</span>
    <span class="n">state</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">State</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">content</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Post</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Post</span> <span class="p">{</span>
        <span class="n">Post</span> <span class="p">{</span>
            <span class="n">state</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Draft</span> <span class="p">{})),</span>
            <span class="n">content</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">State</span> <span class="p">{}</span>

<span class="k">struct</span> <span class="n">Draft</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="n">State</span> <span class="k">for</span> <span class="n">Draft</span> <span class="p">{}</span>
</code></pre></div></div>
<h4 id="listing-17-12-definition-of-a-post-struct-and-a-new-function-that-creates-a-new-post-instance-a-state-trait-and-a-draft-struct">Listing 17-12: Definition of a Post struct and a new function that creates a new Post instance, a State trait, and a Draft struct</h4>

<p>The <code class="language-plaintext highlighter-rouge">State</code> trait defines the behavior shared by different post states, and the <code class="language-plaintext highlighter-rouge">Draft</code>, <code class="language-plaintext highlighter-rouge">PendingReview</code>, and <code class="language-plaintext highlighter-rouge">Published</code> states will all implement the State trait. 
For now, the trait doesn’t have any methods, and we’ll start by defining just the <code class="language-plaintext highlighter-rouge">Draft</code> state because that is the state we want a post to start in.</p>

<p>When we create a new <code class="language-plaintext highlighter-rouge">Post</code>, we set its state field to a <code class="language-plaintext highlighter-rouge">Some</code> value that holds a <code class="language-plaintext highlighter-rouge">Box</code>. 
This <code class="language-plaintext highlighter-rouge">Box</code> points to a new instance of the <code class="language-plaintext highlighter-rouge">Draft</code> struct. 
This ensures whenever we create a new instance of <code class="language-plaintext highlighter-rouge">Post</code>, it will start out as a draft. 
Because the state field of <code class="language-plaintext highlighter-rouge">Post</code> is private, there is no way to create a <code class="language-plaintext highlighter-rouge">Post</code> in any other state! In the <code class="language-plaintext highlighter-rouge">Post::new</code> function, we set the <code class="language-plaintext highlighter-rouge">content</code> field to a new, empty <code class="language-plaintext highlighter-rouge">String</code>.</p>

<h3 id="storing-the-text-of-the-post-content">Storing the Text of the Post Content</h3>
<p>Listing 17-11 showed that we want to be able to call a method named <code class="language-plaintext highlighter-rouge">add_text</code> and pass it a <code class="language-plaintext highlighter-rouge">&amp;str</code> that is then added to the text content of the blog post. 
We implement this as a method rather than exposing the <code class="language-plaintext highlighter-rouge">content</code> field as <code class="language-plaintext highlighter-rouge">pub</code>. 
This means we can implement a method later that will control how the <code class="language-plaintext highlighter-rouge">content</code> field’s data is read. 
The <code class="language-plaintext highlighter-rouge">add_text</code> method is pretty straightforward, so let’s add the implementation in Listing 17-13 to the <code class="language-plaintext highlighter-rouge">impl Post</code> block:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>

<span class="k">impl</span> <span class="n">Post</span> <span class="p">{</span>
    <span class="c1">// --snip--</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add_text</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.content</span><span class="nf">.push_str</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-17-13-implementing-the-add_text-method-to-add-text-to-a-posts-content">Listing 17-13: Implementing the add_text method to add text to a post’s content</h4>

<p>The <code class="language-plaintext highlighter-rouge">add_text</code> method takes a <strong>mutable reference</strong> to <code class="language-plaintext highlighter-rouge">self</code>, because we’re changing the Post instance that we’re calling <code class="language-plaintext highlighter-rouge">add_text</code> on. 
We then call <code class="language-plaintext highlighter-rouge">push_str</code> on the <code class="language-plaintext highlighter-rouge">String</code> in <code class="language-plaintext highlighter-rouge">content</code> and pass the <code class="language-plaintext highlighter-rouge">text</code> argument to add to the saved <code class="language-plaintext highlighter-rouge">content</code>. 
This behavior doesn’t depend on the state the post is in, so it’s not part of the state pattern. 
The <code class="language-plaintext highlighter-rouge">add_text</code> method doesn’t interact with the <code class="language-plaintext highlighter-rouge">state</code> field at all, but it is part of the behavior we want to support.</p>

<h3 id="ensuring-the-content-of-a-draft-post-is-empty">Ensuring the Content of a Draft Post Is Empty</h3>
<p>Even after we’ve called <code class="language-plaintext highlighter-rouge">add_text</code> and added some content to our post, we still want the <code class="language-plaintext highlighter-rouge">content</code> method to return an empty string slice because the post is still in the draft state, as shown on line 7 of Listing 17-11. 
For now, let’s implement the <code class="language-plaintext highlighter-rouge">content</code> method with the simplest thing that will fulfill this requirement: always returning an empty string slice. 
We’ll change this later once we implement the ability to change a post’s state so it can be published. 
So far, posts can only be in the draft state, so the post content should always be empty. 
Listing 17-14 shows this placeholder implementation:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>

<span class="k">impl</span> <span class="n">Post</span> <span class="p">{</span>
    <span class="c1">// --snip--</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">content</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
        <span class="s">""</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-17-14-adding-a-placeholder-implementation-for-the-content-method-on-post-that-always-returns-an-empty-string-slice">Listing 17-14: Adding a placeholder implementation for the content method on Post that always returns an empty string slice</h4>

<p>With this added <code class="language-plaintext highlighter-rouge">content</code> method, everything in Listing 17-11 up to line 7 works as intended.</p>

<h3 id="requesting-a-review-of-the-post-changes-its-state">Requesting a Review of the Post Changes Its State</h3>
<p>Next, we need to add functionality to request a review of a post, which should change its state from <code class="language-plaintext highlighter-rouge">Draft</code> to <code class="language-plaintext highlighter-rouge">PendingReview</code>. 
Listing 17-15 shows this code:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>

<span class="k">impl</span> <span class="n">Post</span> <span class="p">{</span>
    <span class="c1">// --snip--</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">request_review</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.state</span><span class="nf">.take</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.state</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">s</span><span class="nf">.request_review</span><span class="p">())</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">State</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">request_review</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">State</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Draft</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="n">State</span> <span class="k">for</span> <span class="n">Draft</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">request_review</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">State</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">PendingReview</span> <span class="p">{})</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">PendingReview</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="n">State</span> <span class="k">for</span> <span class="n">PendingReview</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">request_review</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">State</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-17-15-implementing-request_review-methods-on-post-and-the-state-trait">Listing 17-15: Implementing request_review methods on Post and the State trait</h4>

<p>We give <code class="language-plaintext highlighter-rouge">Post</code> a public method named <code class="language-plaintext highlighter-rouge">request_review</code> that will take a mutable reference to <code class="language-plaintext highlighter-rouge">self</code>. 
Then we call an internal <code class="language-plaintext highlighter-rouge">request_review</code> method on the current state of <code class="language-plaintext highlighter-rouge">Post</code>, and this second <code class="language-plaintext highlighter-rouge">request_review</code> method consumes the current state and returns a new state.</p>

<p>We’ve added the <code class="language-plaintext highlighter-rouge">request_review</code> method to the <code class="language-plaintext highlighter-rouge">State</code> trait; 
all types that implement the trait will now need to implement the <code class="language-plaintext highlighter-rouge">request_review</code> method. 
Note that rather than having <code class="language-plaintext highlighter-rouge">self</code>, <code class="language-plaintext highlighter-rouge">&amp;self</code>, or <code class="language-plaintext highlighter-rouge">&amp;mut self</code> as the first parameter of the method, we have <code class="language-plaintext highlighter-rouge">self: Box&lt;Self&gt;</code>. 
This syntax means the method is only valid when called on a <code class="language-plaintext highlighter-rouge">Box</code> holding the type. 
This syntax takes ownership of <code class="language-plaintext highlighter-rouge">Box&lt;Self&gt;</code>, invalidating the old state so the state value of the <code class="language-plaintext highlighter-rouge">Post</code> can transform into a new state.</p>

<p>To consume the old state, the <code class="language-plaintext highlighter-rouge">request_review</code> method needs to take ownership of the state value. 
This is where the <code class="language-plaintext highlighter-rouge">Option</code> in the <code class="language-plaintext highlighter-rouge">state</code> field of <code class="language-plaintext highlighter-rouge">Post</code> comes in: we call the <code class="language-plaintext highlighter-rouge">take</code> method to take the <code class="language-plaintext highlighter-rouge">Some</code> value out of the <code class="language-plaintext highlighter-rouge">state</code> field and leave a <code class="language-plaintext highlighter-rouge">None</code> in its place, because Rust doesn’t let us have unpopulated fields in structs. 
This lets us move the <code class="language-plaintext highlighter-rouge">state</code> value out of <code class="language-plaintext highlighter-rouge">Post</code> rather than borrowing it. Then we’ll set the post’s <code class="language-plaintext highlighter-rouge">state</code> value to the result of this operation.</p>

<p>We need to set <code class="language-plaintext highlighter-rouge">state</code> to <code class="language-plaintext highlighter-rouge">None</code> temporarily rather than setting it directly with code like <code class="language-plaintext highlighter-rouge">self.state = self.state.request_review();</code> to get ownership of the state value. 
This ensures <code class="language-plaintext highlighter-rouge">Post</code> can’t use the old <code class="language-plaintext highlighter-rouge">state</code> value after we’ve transformed it into a new state.</p>

<p>The <code class="language-plaintext highlighter-rouge">request_review</code> method on <code class="language-plaintext highlighter-rouge">Draft</code> needs to return a new, boxed instance of a new <code class="language-plaintext highlighter-rouge">PendingReview</code> struct, which represents the state when a post is waiting for a review. 
The <code class="language-plaintext highlighter-rouge">PendingReview</code> struct also implements the <code class="language-plaintext highlighter-rouge">request_review</code> method but doesn’t do any transformations. 
Rather, it returns itself, because when we request a review on a post already in the <code class="language-plaintext highlighter-rouge">PendingReview</code> state, it should stay in the <code class="language-plaintext highlighter-rouge">PendingReview</code> state.</p>

<p>Now we can start seeing the advantages of the state pattern: the <code class="language-plaintext highlighter-rouge">request_review</code> method on <code class="language-plaintext highlighter-rouge">Post</code> is the same no matter its <code class="language-plaintext highlighter-rouge">state</code> value. 
Each state is responsible for its own rules.</p>

<p>We’ll leave the <code class="language-plaintext highlighter-rouge">content</code> method on <code class="language-plaintext highlighter-rouge">Post</code> as is, returning an empty string slice. 
We can now have a <code class="language-plaintext highlighter-rouge">Post</code> in the <code class="language-plaintext highlighter-rouge">PendingReview</code> state as well as in the <code class="language-plaintext highlighter-rouge">Draft</code> state, but we want the same behavior in the <code class="language-plaintext highlighter-rouge">PendingReview</code> state. 
Listing 17-11 now works up to line 10!</p>

<h3 id="adding-the-approve-method-that-changes-the-behavior-of-content">Adding the approve Method that Changes the Behavior of content</h3>
<p>The <code class="language-plaintext highlighter-rouge">approve</code> method will be similar to the <code class="language-plaintext highlighter-rouge">request_review</code> method: it will set <code class="language-plaintext highlighter-rouge">state</code> to the value that the current state says it should have when that state is approved, as shown in Listing 17-16:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>

<span class="k">impl</span> <span class="n">Post</span> <span class="p">{</span>
    <span class="c1">// --snip--</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">approve</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.state</span><span class="nf">.take</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.state</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">s</span><span class="nf">.approve</span><span class="p">())</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">State</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">request_review</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">State</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">approve</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">State</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Draft</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="n">State</span> <span class="k">for</span> <span class="n">Draft</span> <span class="p">{</span>
    <span class="c1">// --snip--</span>
    <span class="k">fn</span> <span class="nf">approve</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">State</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">PendingReview</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="n">State</span> <span class="k">for</span> <span class="n">PendingReview</span> <span class="p">{</span>
    <span class="c1">// --snip--</span>
    <span class="k">fn</span> <span class="nf">approve</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">State</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Published</span> <span class="p">{})</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Published</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="n">State</span> <span class="k">for</span> <span class="n">Published</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">request_review</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">State</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">approve</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">State</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-17-16-implementing-the-approve-method-on-post-and-the-state-trait">Listing 17-16: Implementing the approve method on Post and the State trait</h4>

<p>We add the <code class="language-plaintext highlighter-rouge">approve</code> method to the <code class="language-plaintext highlighter-rouge">State</code> trait and add a new struct that implements <code class="language-plaintext highlighter-rouge">State</code>, the <code class="language-plaintext highlighter-rouge">Published</code> state.</p>

<p>Similar to <code class="language-plaintext highlighter-rouge">request_review</code>, if we call the approve method on a Draft, it will have no effect because it will return <code class="language-plaintext highlighter-rouge">self</code>. 
When we call <code class="language-plaintext highlighter-rouge">approve</code> on <code class="language-plaintext highlighter-rouge">PendingReview</code>, it returns a new, boxed instance of the <code class="language-plaintext highlighter-rouge">Published</code> struct. 
The <code class="language-plaintext highlighter-rouge">Published</code> struct implements the <code class="language-plaintext highlighter-rouge">State</code> trait, and for both the <code class="language-plaintext highlighter-rouge">request_review</code> method and the <code class="language-plaintext highlighter-rouge">approve</code> method, it returns itself, because the post should stay in the <code class="language-plaintext highlighter-rouge">Published</code> state in those cases.</p>

<p>Now we need to update the <code class="language-plaintext highlighter-rouge">content</code> method on <code class="language-plaintext highlighter-rouge">Post</code>: if the state is <code class="language-plaintext highlighter-rouge">Published</code>, we want to return the value in the post’s <code class="language-plaintext highlighter-rouge">content</code> field; otherwise, we want to return an empty string slice, as shown in Listing 17-17:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>

<span class="k">impl</span> <span class="n">Post</span> <span class="p">{</span>
    <span class="c1">// --snip--</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">content</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.state</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.content</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// --snip--</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-17-17-updating-the-content-method-on-post-to-delegate-to-a-content-method-on-state">Listing 17-17: Updating the content method on Post to delegate to a content method on State</h4>

<p>Because the goal is to keep all these rules inside the structs that implement <code class="language-plaintext highlighter-rouge">State</code>, we call a <code class="language-plaintext highlighter-rouge">content</code> method on the value in <code class="language-plaintext highlighter-rouge">state</code> and pass the post instance (that is, <code class="language-plaintext highlighter-rouge">self</code>) as an argument. 
Then we return the value that is returned from using the content method on the state value.</p>

<p>We call the <code class="language-plaintext highlighter-rouge">as_ref</code> method on the <code class="language-plaintext highlighter-rouge">Option</code> because we want a reference to the value inside the <code class="language-plaintext highlighter-rouge">Option</code> rather than ownership of the value. 
Because <code class="language-plaintext highlighter-rouge">state</code> is an <code class="language-plaintext highlighter-rouge">Option&lt;Box&lt;dyn State&gt;&gt;</code>, when we call <code class="language-plaintext highlighter-rouge">as_ref</code>, an <code class="language-plaintext highlighter-rouge">Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code> is returned. 
If we didn’t call <code class="language-plaintext highlighter-rouge">as_ref</code>, we would get an error because we can’t move <code class="language-plaintext highlighter-rouge">state</code> out of the borrowed <code class="language-plaintext highlighter-rouge">&amp;self</code> of the function parameter.</p>

<p>We then call the <code class="language-plaintext highlighter-rouge">unwrap</code> method, which we know will never panic, because we know the methods on <code class="language-plaintext highlighter-rouge">Post</code> ensure that <code class="language-plaintext highlighter-rouge">state</code> will always contain a <code class="language-plaintext highlighter-rouge">Some</code> value when those methods are done. 
This is one of the cases we talked about in the “Cases In Which You Have More Information Than the Compiler” section of Chapter 9 when we know that a <code class="language-plaintext highlighter-rouge">None</code> value is never possible, even though the compiler isn’t able to understand that.</p>

<p>At this point, when we call <code class="language-plaintext highlighter-rouge">content</code> on the <code class="language-plaintext highlighter-rouge">&amp;Box&lt;dyn State&gt;</code>, deref coercion will take effect on the <code class="language-plaintext highlighter-rouge">&amp;</code> and the <code class="language-plaintext highlighter-rouge">Box</code> so the <code class="language-plaintext highlighter-rouge">content</code> method will ultimately be called on the type that implements the <code class="language-plaintext highlighter-rouge">State</code> trait. 
That means we need to add <code class="language-plaintext highlighter-rouge">content</code> to the <code class="language-plaintext highlighter-rouge">State</code> trait definition, and that is where we’ll put the logic for what content to return depending on which state we have, as shown in Listing 17-18:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>

<span class="k">trait</span> <span class="n">State</span> <span class="p">{</span>
    <span class="c1">// --snip--</span>
    <span class="k">fn</span> <span class="n">content</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">post</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Post</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span> <span class="p">{</span>
        <span class="s">""</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// --snip--</span>
<span class="k">struct</span> <span class="n">Published</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="n">State</span> <span class="k">for</span> <span class="n">Published</span> <span class="p">{</span>
    <span class="c1">// --snip--</span>
    <span class="k">fn</span> <span class="n">content</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">post</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Post</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="n">post</span><span class="py">.content</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-17-18-adding-the-content-method-to-the-state-trait">Listing 17-18: Adding the content method to the State trait</h4>

<p>We add a default implementation for the <code class="language-plaintext highlighter-rouge">content</code> method that returns an empty string slice. 
That means we don’t need to implement <code class="language-plaintext highlighter-rouge">content</code> on the <code class="language-plaintext highlighter-rouge">Draft</code> and <code class="language-plaintext highlighter-rouge">PendingReview</code> structs. 
The <code class="language-plaintext highlighter-rouge">Published</code> struct will override the <code class="language-plaintext highlighter-rouge">content</code> method and return the value in <code class="language-plaintext highlighter-rouge">post.content</code>.</p>

<p>Note that we need lifetime annotations on this method, as we discussed in Chapter 10. 
We’re taking a reference to a <code class="language-plaintext highlighter-rouge">post</code> as an argument and returning a reference to part of that <code class="language-plaintext highlighter-rouge">post</code>, so the lifetime of the returned reference is related to the lifetime of the <code class="language-plaintext highlighter-rouge">post</code> argument.</p>

<p>And we’re done—all of Listing 17-11 now works! We’ve implemented the state pattern with the rules of the blog post workflow. The logic related to the rules lives in the state objects rather than being scattered throughout <code class="language-plaintext highlighter-rouge">Post</code>.</p>

<h3 id="trade-offs-of-the-state-pattern">Trade-offs of the State Pattern</h3>
<p>We’ve shown that Rust is capable of implementing the object-oriented state pattern to encapsulate the different kinds of behavior a post should have in each state. 
The methods on <code class="language-plaintext highlighter-rouge">Post</code> know nothing about the various behaviors. 
The way we organized the code, we have to look in only one place to know the different ways a published post can behave: the implementation of the <code class="language-plaintext highlighter-rouge">State</code> trait on the <code class="language-plaintext highlighter-rouge">Published</code> struct.</p>

<p>If we were to create an alternative implementation that didn’t use the state pattern, we might instead use <code class="language-plaintext highlighter-rouge">match</code> expressions in the methods on <code class="language-plaintext highlighter-rouge">Post</code> or even in the <code class="language-plaintext highlighter-rouge">main</code> code that checks the state of the post and changes behavior in those places. 
That would mean we would have to look in several places to understand all the implications of a post being in the published state! This would only increase the more states we added: each of those <code class="language-plaintext highlighter-rouge">match</code> expressions would need another arm.</p>

<p>With the state pattern, the <code class="language-plaintext highlighter-rouge">Post</code> methods and the places we use <code class="language-plaintext highlighter-rouge">Post</code> don’t need <code class="language-plaintext highlighter-rouge">match</code> expressions, and to add a new state, we would only need to add a new struct and implement the trait methods on that one struct.</p>

<p>The implementation using the state pattern is easy to extend to add more functionality. To see the simplicity of maintaining code that uses the state pattern, try a few of these suggestions:</p>

<ul>
  <li>Add a <code class="language-plaintext highlighter-rouge">reject</code> method that changes the post’s state from <code class="language-plaintext highlighter-rouge">PendingReview</code> back to <code class="language-plaintext highlighter-rouge">Draft</code>.</li>
  <li>Require two calls to <code class="language-plaintext highlighter-rouge">approve</code> before the state can be changed to <code class="language-plaintext highlighter-rouge">Published</code>.</li>
  <li>Allow users to add text content only when a post is in the <code class="language-plaintext highlighter-rouge">Draft</code> state. Hint: have the state object responsible for what might change about the content but not responsible for modifying the <code class="language-plaintext highlighter-rouge">Post</code>.</li>
</ul>

<p>One downside of the state pattern is that, because the states implement the transitions between states, some of the states are coupled to each other. 
If we add another state between <code class="language-plaintext highlighter-rouge">PendingReview</code> and <code class="language-plaintext highlighter-rouge">Published</code>, such as <code class="language-plaintext highlighter-rouge">Scheduled</code>, we would have to change the code in <code class="language-plaintext highlighter-rouge">PendingReview</code> to transition to <code class="language-plaintext highlighter-rouge">Scheduled</code> instead. 
It would be less work if <code class="language-plaintext highlighter-rouge">PendingReview</code> didn’t need to change with the addition of a new state, but that would mean switching to another design pattern.</p>

<p>Another downside is that we’ve duplicated some logic. 
To eliminate some of the duplication, we might try to make default implementations for the <code class="language-plaintext highlighter-rouge">request_review</code> and <code class="language-plaintext highlighter-rouge">approve</code> methods on the <code class="language-plaintext highlighter-rouge">State</code> trait that return <code class="language-plaintext highlighter-rouge">self</code>; however, this would violate object safety, because the trait doesn’t know what the concrete <code class="language-plaintext highlighter-rouge">self</code> will be exactly. 
We want to be able to use <code class="language-plaintext highlighter-rouge">State</code> as a trait object, so we need its methods to be object safe.</p>

<p>Other duplication includes the similar implementations of the <code class="language-plaintext highlighter-rouge">request_review</code> and <code class="language-plaintext highlighter-rouge">approve</code> methods on <code class="language-plaintext highlighter-rouge">Post</code>. 
Both methods delegate to the implementation of the same method on the value in the <code class="language-plaintext highlighter-rouge">state</code> field of <code class="language-plaintext highlighter-rouge">Option</code> and set the new value of the <code class="language-plaintext highlighter-rouge">state</code> field to the result. 
If we had a lot of methods on <code class="language-plaintext highlighter-rouge">Post</code> that followed this pattern, we might consider defining a macro to eliminate the repetition (see the “Macros” section in Chapter 19).</p>

<p>By implementing the state pattern exactly as it’s defined for object-oriented languages, we’re not taking as full advantage of Rust’s strengths as we could. 
Let’s look at some changes we can make to the <code class="language-plaintext highlighter-rouge">blog</code> crate that can make invalid states and transitions into compile time errors.</p>

<h3 id="encoding-states-and-behavior-as-types">Encoding States and Behavior as Types</h3>
<p>We’ll show you how to rethink the state pattern to get a different set of trade-offs. 
Rather than encapsulating the states and transitions completely so outside code has no knowledge of them, we’ll encode the states into different types. 
Consequently, Rust’s type checking system will prevent attempts to use draft posts where only published posts are allowed by issuing a compiler error.</p>

<p>Let’s consider the first part of <code class="language-plaintext highlighter-rouge">main</code> in Listing 17-11:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">post</span> <span class="o">=</span> <span class="nn">Post</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="n">post</span><span class="nf">.add_text</span><span class="p">(</span><span class="s">"I ate a salad for lunch today"</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="s">""</span><span class="p">,</span> <span class="n">post</span><span class="nf">.content</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>
<p>We still enable the creation of new posts in the draft state using <code class="language-plaintext highlighter-rouge">Post::new</code> and the ability to add text to the post’s content. 
But instead of having a <code class="language-plaintext highlighter-rouge">content</code> method on a draft post that returns an empty string, we’ll make it so draft posts don’t have the <code class="language-plaintext highlighter-rouge">content</code> method at all. 
That way, if we try to get a draft post’s content, we’ll get a compiler error telling us the method doesn’t exist. 
As a result, it will be impossible for us to accidentally display draft post content in production, because that code won’t even compile. 
Listing 17-19 shows the definition of a <code class="language-plaintext highlighter-rouge">Post</code> struct and a <code class="language-plaintext highlighter-rouge">DraftPost</code> struct, as well as methods on each:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Post</span> <span class="p">{</span>
    <span class="n">content</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">DraftPost</span> <span class="p">{</span>
    <span class="n">content</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Post</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">DraftPost</span> <span class="p">{</span>
        <span class="n">DraftPost</span> <span class="p">{</span>
            <span class="n">content</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">content</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="py">.content</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">DraftPost</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add_text</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.content</span><span class="nf">.push_str</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-17-19-a-post-with-a-content-method-and-a-draftpost-without-a-content-method">Listing 17-19: A Post with a content method and a DraftPost without a content method</h4>

<p>Both the <code class="language-plaintext highlighter-rouge">Post</code> and <code class="language-plaintext highlighter-rouge">DraftPost</code> structs have a private <code class="language-plaintext highlighter-rouge">content</code> field that stores the blog post text. 
The structs no longer have the <code class="language-plaintext highlighter-rouge">state</code> field because we’re moving the encoding of the state to the types of the structs. 
The <code class="language-plaintext highlighter-rouge">Post</code> struct will represent a published post, and it has a <code class="language-plaintext highlighter-rouge">content</code> method that returns the <code class="language-plaintext highlighter-rouge">content</code>.</p>

<p>We still have a <code class="language-plaintext highlighter-rouge">Post::new</code> function, but instead of returning an instance of <code class="language-plaintext highlighter-rouge">Post</code>, it returns an instance of <code class="language-plaintext highlighter-rouge">DraftPost</code>. 
Because <code class="language-plaintext highlighter-rouge">content</code> is private and there aren’t any functions that return <code class="language-plaintext highlighter-rouge">Post</code>, it’s not possible to create an instance of <code class="language-plaintext highlighter-rouge">Post</code> right now.</p>

<p>The <code class="language-plaintext highlighter-rouge">DraftPost</code> struct has an <code class="language-plaintext highlighter-rouge">add_text</code> method, so we can add text to <code class="language-plaintext highlighter-rouge">content</code> as before, but note that <code class="language-plaintext highlighter-rouge">DraftPost</code> does not have a <code class="language-plaintext highlighter-rouge">content</code> method defined! So now the program ensures all posts start as draft posts, and draft posts don’t have their content available for display. Any attempt to get around these constraints will result in a compiler error.</p>

<h3 id="implementing-transitions-as-transformations-into-different-types">Implementing Transitions as Transformations into Different Types</h3>
<p>So how do we get a published post? We want to enforce the rule that a draft post has to be reviewed and approved before it can be published. 
A post in the pending review state should still not display any content. 
Let’s implement these constraints by adding another struct, <code class="language-plaintext highlighter-rouge">PendingReviewPost</code>, defining the <code class="language-plaintext highlighter-rouge">request_review</code> method on <code class="language-plaintext highlighter-rouge">DraftPost</code> to return a <code class="language-plaintext highlighter-rouge">PendingReviewPost</code>, and defining an <code class="language-plaintext highlighter-rouge">approve</code> method on <code class="language-plaintext highlighter-rouge">PendingReviewPost</code> to return a <code class="language-plaintext highlighter-rouge">Post</code>, as shown in Listing 17-20:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>

<span class="k">impl</span> <span class="n">DraftPost</span> <span class="p">{</span>
    <span class="c1">// --snip--</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">request_review</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">PendingReviewPost</span> <span class="p">{</span>
        <span class="n">PendingReviewPost</span> <span class="p">{</span>
            <span class="n">content</span><span class="p">:</span> <span class="k">self</span><span class="py">.content</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">PendingReviewPost</span> <span class="p">{</span>
    <span class="n">content</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">PendingReviewPost</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">approve</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Post</span> <span class="p">{</span>
        <span class="n">Post</span> <span class="p">{</span>
            <span class="n">content</span><span class="p">:</span> <span class="k">self</span><span class="py">.content</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-17-20-a-pendingreviewpost-that-gets-created-by-calling-request_review-on-draftpost-and-an-approve-method-that-turns-a-pendingreviewpost-into-a-published-post">Listing 17-20: A PendingReviewPost that gets created by calling request_review on DraftPost and an approve method that turns a PendingReviewPost into a published Post</h4>

<p>The <code class="language-plaintext highlighter-rouge">request_review</code> and <code class="language-plaintext highlighter-rouge">approve</code> methods take ownership of <code class="language-plaintext highlighter-rouge">self</code>, thus consuming the <code class="language-plaintext highlighter-rouge">DraftPost</code> and <code class="language-plaintext highlighter-rouge">PendingReviewPost</code> instances and transforming them into a <code class="language-plaintext highlighter-rouge">PendingReviewPost</code> and a published <code class="language-plaintext highlighter-rouge">Post</code>, respectively. 
This way, we won’t have any lingering <code class="language-plaintext highlighter-rouge">DraftPost</code> instances after we’ve called <code class="language-plaintext highlighter-rouge">request_review</code> on them, and so forth. 
The <code class="language-plaintext highlighter-rouge">PendingReviewPost</code> struct doesn’t have a <code class="language-plaintext highlighter-rouge">content</code> method defined on it, so attempting to read its content results in a compiler error, as with <code class="language-plaintext highlighter-rouge">DraftPost</code>. 
Because the only way to get a published <code class="language-plaintext highlighter-rouge">Post</code> instance that does have a <code class="language-plaintext highlighter-rouge">content</code> method defined is to call the <code class="language-plaintext highlighter-rouge">approve</code> method on a <code class="language-plaintext highlighter-rouge">PendingReviewPost</code>, and the only way to get a <code class="language-plaintext highlighter-rouge">PendingReviewPost</code> is to call the <code class="language-plaintext highlighter-rouge">request_review</code> method on a <code class="language-plaintext highlighter-rouge">DraftPost</code>, we’ve now encoded the blog post workflow into the type system.</p>

<p>But we also have to make some small changes to <code class="language-plaintext highlighter-rouge">main</code>. 
The <code class="language-plaintext highlighter-rouge">request_review</code> and <code class="language-plaintext highlighter-rouge">approve</code> methods return new instances rather than modifying the struct they’re called on, so we need to add more <code class="language-plaintext highlighter-rouge">let post =</code> shadowing assignments to save the returned instances. 
We also can’t have the assertions about the draft and pending review post’s contents be empty strings, nor do we need them: we can’t compile code that tries to use the content of posts in those states any longer. 
The updated code in <code class="language-plaintext highlighter-rouge">main</code> is shown in Listing 17-21:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">use</span> <span class="nn">blog</span><span class="p">::</span><span class="n">Post</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">post</span> <span class="o">=</span> <span class="nn">Post</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="n">post</span><span class="nf">.add_text</span><span class="p">(</span><span class="s">"I ate a salad for lunch today"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">post</span> <span class="o">=</span> <span class="n">post</span><span class="nf">.request_review</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">post</span> <span class="o">=</span> <span class="n">post</span><span class="nf">.approve</span><span class="p">();</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="s">"I ate a salad for lunch today"</span><span class="p">,</span> <span class="n">post</span><span class="nf">.content</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-17-21-modifications-to-main-to-use-the-new-implementation-of-the-blog-post-workflow">Listing 17-21: Modifications to main to use the new implementation of the blog post workflow</h4>
<p>The changes we needed to make to <code class="language-plaintext highlighter-rouge">main</code> to reassign <code class="language-plaintext highlighter-rouge">post</code> mean that this implementation doesn’t quite follow the object-oriented state pattern anymore: the transformations between the states are no longer encapsulated entirely within the <code class="language-plaintext highlighter-rouge">Post</code> implementation. 
However, our gain is that invalid states are now impossible because of the type system and the type checking that happens at compile time! 
This ensures that certain bugs, such as display of the content of an unpublished post, will be discovered before they make it to production.</p>

<p>Try the tasks suggested for additional requirements that we mentioned at the start of this section on the <code class="language-plaintext highlighter-rouge">blog</code> crate as it is after Listing 17-20 to see what you think about the design of this version of the code. 
Note that some of the tasks might be completed already in this design.</p>

<p>We’ve seen that even though Rust is capable of implementing object-oriented design patterns, other patterns, such as encoding state into the type system, are also available in Rust. 
These patterns have different trade-offs. 
Although you might be very familiar with object-oriented patterns, rethinking the problem to take advantage of Rust’s features can provide benefits, such as preventing some bugs at compile time. 
Object-oriented patterns won’t always be the best solution in Rust due to certain features, like ownership, that object-oriented languages don’t have.</p>

<h2 id="summary">Summary</h2>
<p>No matter whether or not you think Rust is an object-oriented language after reading this chapter, you now know that you can use trait objects to get some object-oriented features in Rust. 
Dynamic dispatch can give your code some flexibility in exchange for a bit of runtime performance. 
You can use this flexibility to implement object-oriented patterns that can help your code’s maintainability. 
Rust also has other features, like ownership, that object-oriented languages don’t have. 
An object-oriented pattern won’t always be the best way to take advantage of Rust’s strengths, but is an available option.</p>

<p>Next, we’ll look at patterns, which are another of Rust’s features that enable lots of flexibility. 
We’ve looked at them briefly throughout the book but haven’t seen their full capability yet. Let’s go!</p>

        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/#c" class="page__taxonomy-item" rel="tag">C++</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#impl" class="page__taxonomy-item" rel="tag">impl</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#object-oriented" class="page__taxonomy-item" rel="tag">Object Oriented</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#oop" class="page__taxonomy-item" rel="tag">OOP</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#trait" class="page__taxonomy-item" rel="tag">trait</a>
    
    </span>
  </p>




  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/categories/#rust-language" class="page__taxonomy-item" rel="tag">RUST Language</a>
    
    </span>
  </p>


        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2020-09-07T00:00:00+00:00">September 7, 2020</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?text=RUST+%3A+17.+Object+Oriented+Programming+Features+of+Rust%20https%3A%2F%2Fjjungs-lee.github.io%2F%2Frust%2F17.Object-Oriented-Programming-Features-of-Rust" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fjjungs-lee.github.io%2F%2Frust%2F17.Object-Oriented-Programming-Features-of-Rust" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fjjungs-lee.github.io%2F%2Frust%2F17.Object-Oriented-Programming-Features-of-Rust" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/rust/16.Fearless-Concurrency" class="pagination--pager" title="RUST : 16. Fearless Concurrency
">Previous</a>
    
    
      <a href="/rust/18.Patterns-and-Matching" class="pagination--pager" title="RUST : 18. Patterns and Matching
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/rust/4.Variable-Bindings" rel="permalink">Rust by Example : 4. Variable Bindings
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  2 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">Rust provides type safety via static typing. 
Variable bindings can be type annotated when declared. 
However, in most cases, the compiler will be able to in...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/rust/3.Custom-Types" rel="permalink">Rust by Example : 3. Custom Types
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  8 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">Rust custom data types are formed mainly through the two keywords:
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/rust/2.Primitives" rel="permalink">Rust by Example : 2. Primitives
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  6 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">Rust provides access to a wide variety of primitives. A sample includes:
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/rust/1.Hello-World" rel="permalink">Rust by Example : 1. Hello World
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  13 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">This is the source code of the traditional Hello World program.
</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
      
        
      
        
          <li><a href="https://github.com/jjungs-lee" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
      
        
      
        
      
        
          <li><a href="https://www.linkedin.com/in/jjungs-lee" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
    

    <li><a href="NONE"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 JJungs-lee. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script src="https://kit.fontawesome.com/4eee35f757.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>







  </body>
</html>
