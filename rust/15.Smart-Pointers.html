<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.17.2 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html -->

<!----><title>Yes! I Take IT :)</title>
<meta name="description" content="Smart PointersA pointer is a general concept for a variable that contains an address in memory. This address refers to, or “points at,” some other data. The most common kind of pointer in Rust is a reference, which you learned about in Chapter 4. References are indicated by the &amp; symbol and borrow the value they point to. They don’t have any special capabilities other than referring to data. Also, they don’t have any overhead and are the kind of pointer we use most often.">


  <meta name="author" content="JJungs-lee">


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Yes! I Take IT">
<meta property="og:title" content="RUST : 15. Smart Pointers">
<meta property="og:url" content="https://jjungs-lee.github.io//rust/15.Smart-Pointers">


  <meta property="og:description" content="Smart PointersA pointer is a general concept for a variable that contains an address in memory. This address refers to, or “points at,” some other data. The most common kind of pointer in Rust is a reference, which you learned about in Chapter 4. References are indicated by the &amp; symbol and borrow the value they point to. They don’t have any special capabilities other than referring to data. Also, they don’t have any overhead and are the kind of pointer we use most often.">







  <meta property="article:published_time" content="2020-04-20T00:00:00+00:00">





  

  


<link rel="canonical" href="https://jjungs-lee.github.io//rust/15.Smart-Pointers">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "JJungs-lee",
      "url": "https://jjungs-lee.github.io//"
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="NONE" type="application/atom+xml" rel="alternate" title="Yes! I Take IT Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          <b>I.T.I</b> <small>by JHLee</small>
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/posts/" >Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/kernel/" >Kernel</a>
            </li><li class="masthead__menu-item">
              <a href="/swim/" >Swim</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="/assets/images/author_jhl.png" alt="JJungs-lee" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">JJungs-lee</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>Do Coding! Do Study!</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Somewhere</span>
        </li>
      

      
        
          
        
          
        
          
        
          
        
          
            <li><a href="https://github.com/jjungs-lee" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
          
        
          
        
          
            <li><a href="https://www.linkedin.com/in/jjungs-lee" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="RUST : 15. Smart Pointers">
    <meta itemprop="description" content="Smart PointersA pointer is a general concept for a variable that contains an address in memory. This address refers to, or “points at,” some other data. The most common kind of pointer in Rust is a reference, which you learned about in Chapter 4. References are indicated by the &amp; symbol and borrow the value they point to. They don’t have any special capabilities other than referring to data. Also, they don’t have any overhead and are the kind of pointer we use most often.">
    <meta itemprop="datePublished" content="2020-04-20T00:00:00+00:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">RUST : 15. Smart Pointers
</h1>
          
            <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  68 minute read

</p>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
        <h2 id="smart-pointers">Smart Pointers</h2>
<p>A <strong>pointer</strong> is a general concept for a variable that contains an address in memory. 
This address refers to, or “points at,” some other data. 
The most common kind of pointer in Rust is a reference, which you learned about in Chapter 4. 
References are indicated by the <code class="language-plaintext highlighter-rouge">&amp;</code> symbol and borrow the value they point to. 
They don’t have any special capabilities other than referring to data. 
Also, they don’t have any overhead and are the kind of pointer we use most often.</p>

<p><strong>Smart pointers</strong>, on the other hand, are data structures that not only act like a pointer but also have additional metadata and capabilities. 
The concept of smart pointers isn’t unique to Rust: smart pointers originated in C++ and exist in other languages as well. 
In Rust, the different smart pointers defined in the standard library provide functionality beyond that provided by references. 
One example that we’ll explore in this chapter is the <em>reference counting</em> smart pointer type. 
This pointer enables you to have multiple owners of data by keeping track of the number of owners and, when no owners remain, cleaning up the data.</p>

<p>In Rust, which uses the concept of ownership and borrowing, an additional difference between references and smart pointers is that references are pointers that <strong>only borrow data</strong>; in contrast, in many cases, smart pointers <em>own</em> the data they point to.</p>

<p>We’ve already encountered a few smart pointers in this book, such as <code class="language-plaintext highlighter-rouge">String</code> and <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code> in Chapter 8, although we didn’t call them smart pointers at the time. 
Both these types count as smart pointers because they own some memory and allow you to manipulate it. 
They also have metadata (such as their capacity) and extra capabilities or guarantees (such as with <code class="language-plaintext highlighter-rouge">String</code> ensuring its data will always be valid UTF-8).</p>

<p>Smart pointers are usually implemented using structs. 
The characteristic that distinguishes a smart pointer from an ordinary struct is that smart pointers implement the <code class="language-plaintext highlighter-rouge">Deref</code> and <code class="language-plaintext highlighter-rouge">Drop</code> traits. 
The <code class="language-plaintext highlighter-rouge">Deref</code> trait allows an instance of the smart pointer struct to behave like a reference so you can write code that works with either references or smart pointers. 
The <code class="language-plaintext highlighter-rouge">Drop</code> trait allows you to customize the code that is run when an instance of the smart pointer goes out of scope. In this chapter, we’ll discuss both traits and demonstrate why they’re important to smart pointers.</p>

<p>Given that the smart pointer pattern is a general design pattern used frequently in Rust, this chapter won’t cover every existing smart pointer. 
Many libraries have their own smart pointers, and you can even write your own. 
We’ll cover the most common smart pointers in the standard library:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> for allocating values on the heap</li>
  <li><code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code>, a reference counting type that enables multiple ownership</li>
  <li><code class="language-plaintext highlighter-rouge">Ref&lt;T&gt;</code> and <code class="language-plaintext highlighter-rouge">RefMut&lt;T&gt;</code>, accessed through <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code>, a type that enforces the borrowing rules at runtime instead of compile time</li>
</ul>

<p>In addition, we’ll cover the <em>interior mutability</em> pattern where an immutable type exposes an API for mutating an interior value. 
We’ll also discuss <em>reference cycles</em>: how they can leak memory and how to prevent them.</p>

<p>Let’s dive in!</p>

<h2 id="using-box-to-point-to-data-on-the-heap">Using Box<T> to Point to Data on the Heap</T></h2>
<p>The most straightforward smart pointer is a <em>box</em>, whose type is written <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code>. 
Boxes allow you to store data on the heap rather than the stack. What remains on the stack is the pointer to the heap data. 
Refer to Chapter 4 to review the difference between the stack and the heap.</p>

<p>Boxes don’t have performance overhead, other than storing their data on the heap instead of on the stack. 
But they don’t have many extra capabilities either. You’ll use them most often in these situations:</p>

<ul>
  <li>When you have a type whose size can’t be known at compile time and you want to use a value of that type in a context that requires an exact size</li>
  <li>When you have a large amount of data and you want to transfer ownership but ensure the data won’t be copied when you do so</li>
  <li>When you want to own a value and you care only that it’s a type that implements a particular trait rather than being of a specific type</li>
</ul>

<p>We’ll demonstrate the first situation in the “Enabling Recursive Types with Boxes” section. 
In the second case, transferring ownership of a large amount of data can take a long time because the data is copied around on the stack. 
To improve performance in this situation, we can store the large amount of data on the heap in a box. 
Then, only the small amount of pointer data is copied around on the stack, while the data it references stays in one place on the heap. 
The third case is known as a <em>trait object</em>, and Chapter 17 devotes an entire section, “Using Trait Objects That Allow for Values of Different Types,” just to that topic. 
So what you learn here you’ll apply again in Chapter 17!</p>

<h3 id="using-a-box-to-store-data-on-the-heap">Using a Box<T> to Store Data on the Heap</T></h3>
<p>Before we discuss this use case for <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code>, we’ll cover the syntax and how to interact with values stored within a <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code>.</p>

<p>Listing 15-1 shows how to use a box to store an <code class="language-plaintext highlighter-rouge">i32</code> value on the heap:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"b = {}"</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-1-storing-an-i32-value-on-the-heap-using-a-box">Listing 15-1: Storing an i32 value on the heap using a box</h4>

<p>We define the variable <code class="language-plaintext highlighter-rouge">b</code> to have the value of a <code class="language-plaintext highlighter-rouge">Box</code> that points to the value <code class="language-plaintext highlighter-rouge">5</code>, which is allocated on the heap. 
This program will print <code class="language-plaintext highlighter-rouge">b = 5</code>; in this case, we can access the data in the box similar to how we would if this data were on the stack. 
Just like any owned value, when a box goes out of scope, as b does at the end of main, it will be deallocated. 
The deallocation happens for the box (stored on the stack) and the data it points to (stored on the heap).</p>

<p>Putting a single value on the heap isn’t very useful, so you won’t use boxes by themselves in this way very often. 
Having values like a single <code class="language-plaintext highlighter-rouge">i32</code> on the stack, where they’re stored by default, is more appropriate in the majority of situations. 
Let’s look at a case where boxes allow us to define types that we wouldn’t be allowed to if we didn’t have boxes.</p>

<h3 id="enabling-recursive-types-with-boxes">Enabling Recursive Types with Boxes</h3>
<p>At compile time, Rust needs to know how much space a type takes up. 
One type whose size can’t be known at compile time is a <em>recursive type</em>, where a value can have as part of itself another value of the same type. 
Because this nesting of values could theoretically continue infinitely, Rust doesn’t know how much space a value of a recursive type needs. 
However, boxes have a known size, so by inserting a box in a recursive type definition, you can have recursive types.</p>

<p>Let’s explore the <em>cons list</em>, which is a data type common in functional programming languages, as an example of a recursive type. 
The cons list type we’ll define is straightforward except for the recursion; therefore, the concepts in the example we’ll work with will be useful any time you get into more complex situations involving recursive types.</p>

<h3 id="more-information-about-the-cons-list">More Information About the Cons List</h3>
<p>A <em>cons list</em> is a data structure that comes from the Lisp programming language and its dialects. 
In Lisp, the <code class="language-plaintext highlighter-rouge">cons</code> function (short for “construct function”) constructs a new pair from its two arguments, which usually are a single value and another pair. 
These pairs containing pairs form a list.</p>

<p>The cons function concept has made its way into more general functional programming jargon: “to cons <em>x</em> onto <em>y</em>” informally means to construct a new container instance by putting the element x at the start of this new container, followed by the container <em>y</em>.</p>

<p>Each item in a cons list contains two elements: the value of the current item and the next item. 
The last item in the list contains only a value called <code class="language-plaintext highlighter-rouge">Nil</code> without a next item. 
A cons list is produced by recursively calling the <code class="language-plaintext highlighter-rouge">cons</code> function. 
The canonical name to denote the base case of the recursion is <code class="language-plaintext highlighter-rouge">Nil</code>. 
Note that this is not the same as the “null” or “nil” concept in Chapter 6, which is an invalid or absent value.</p>

<p>Although functional programming languages use cons lists frequently, the cons list <strong>isn’t a commonly used</strong> data structure in Rust. 
Most of the time when you have a list of items in Rust, <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code> is a better choice to use. 
Other, more complex recursive data types <em>are</em> useful in various situations, but by starting with the cons list, we can explore how boxes let us define a recursive data type without much distraction.</p>

<p>Listing 15-2 contains an enum definition for a cons list. 
Note that this code won’t compile yet because the <code class="language-plaintext highlighter-rouge">List</code> type doesn’t have a known size, which we’ll demonstrate.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>
<span class="k">enum</span> <span class="n">List</span> <span class="p">{</span>
    <span class="nf">Cons</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="n">List</span><span class="p">),</span>
    <span class="nb">Nil</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-2-the-first-attempt-at-defining-an-enum-to-represent-a-cons-list-data-structure-of-i32-values">Listing 15-2: The first attempt at defining an enum to represent a cons list data structure of i32 values</h4>

<p class="notice--info"><strong>Note</strong>: We’re implementing a cons list that holds only <code class="language-plaintext highlighter-rouge">i32</code> values for the purposes of this example. We could have implemented it using generics, as we discussed in Chapter 10, to define a cons list type that could store values of any type.</p>

<p>Using the <code class="language-plaintext highlighter-rouge">List</code> type to store the list <code class="language-plaintext highlighter-rouge">1, 2, 3</code> would look like the code in Listing 15-3:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>
<span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="nn">List</span><span class="p">::{</span><span class="nb">Cons</span><span class="p">,</span> <span class="nb">Nil</span><span class="p">};</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">list</span> <span class="o">=</span> <span class="nf">Cons</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nf">Cons</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nf">Cons</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">Nil</span><span class="p">)));</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-3-using-the-list-enum-to-store-the-list-1-2-3">Listing 15-3: Using the List enum to store the list 1, 2, 3</h4>

<p>The first <code class="language-plaintext highlighter-rouge">Cons</code> value holds <code class="language-plaintext highlighter-rouge">1</code> and another <code class="language-plaintext highlighter-rouge">List</code> value. 
This <code class="language-plaintext highlighter-rouge">List</code> value is another <code class="language-plaintext highlighter-rouge">Cons</code> value that holds <code class="language-plaintext highlighter-rouge">2</code> and another <code class="language-plaintext highlighter-rouge">List</code> value. 
This <code class="language-plaintext highlighter-rouge">List</code> value is one more <code class="language-plaintext highlighter-rouge">Cons</code> value that holds <code class="language-plaintext highlighter-rouge">3</code> and a List value, which is finally <code class="language-plaintext highlighter-rouge">Nil</code>, the non-recursive variant that signals the end of the list.</p>

<p>If we try to compile the code in Listing 15-3, we get the error shown in Listing 15-4:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="n">cons</span><span class="o">-</span><span class="n">list</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/cons-list)</span>
<span class="n">error</span><span class="p">[</span><span class="n">E0072</span><span class="p">]:</span> <span class="n">recursive</span> <span class="k">type</span> <span class="err">`</span><span class="n">List</span><span class="err">`</span> <span class="n">has</span> <span class="n">infinite</span> <span class="n">size</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span>
  <span class="p">|</span>
<span class="mi">1</span> <span class="p">|</span> <span class="k">enum</span> <span class="n">List</span> <span class="p">{</span>
  <span class="p">|</span> <span class="o">^^^^^^^^^</span> <span class="n">recursive</span> <span class="k">type</span> <span class="n">has</span> <span class="n">infinite</span> <span class="n">size</span>
<span class="mi">2</span> <span class="p">|</span>     <span class="nf">Cons</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="n">List</span><span class="p">),</span>
  <span class="p">|</span>               <span class="o">----</span> <span class="n">recursive</span> <span class="n">without</span> <span class="n">indirection</span>
  <span class="p">|</span>
  <span class="o">=</span> <span class="n">help</span><span class="p">:</span> <span class="n">insert</span> <span class="nf">indirection</span> <span class="p">(</span><span class="n">e</span><span class="py">.g</span><span class="err">.</span><span class="p">,</span> <span class="n">a</span> <span class="err">`</span><span class="nb">Box</span><span class="err">`</span><span class="p">,</span> <span class="err">`</span><span class="nb">Rc</span><span class="err">`</span><span class="p">,</span> <span class="n">or</span> <span class="err">`</span><span class="o">&amp;</span><span class="err">`</span><span class="p">)</span> 
  <span class="n">at</span> <span class="n">some</span> <span class="n">point</span> <span class="n">to</span> <span class="n">make</span> <span class="err">`</span><span class="n">List</span><span class="err">`</span> <span class="n">representable</span>

<span class="n">error</span><span class="p">[</span><span class="n">E0391</span><span class="p">]:</span> <span class="n">cycle</span> <span class="n">detected</span> <span class="n">when</span> <span class="n">processing</span> <span class="err">`</span><span class="n">List</span><span class="err">`</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span>
  <span class="p">|</span>
<span class="mi">1</span> <span class="p">|</span> <span class="k">enum</span> <span class="n">List</span> <span class="p">{</span>
  <span class="p">|</span> <span class="o">^^^^^^^^^</span>
  <span class="p">|</span>
  <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="o">...</span><span class="n">which</span> <span class="n">again</span> <span class="n">requires</span> <span class="n">processing</span> <span class="err">`</span><span class="n">List</span><span class="err">`</span><span class="p">,</span> <span class="n">completing</span> <span class="n">the</span> <span class="n">cycle</span>
  <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">cycle</span> <span class="n">used</span> <span class="n">when</span> <span class="n">computing</span> <span class="n">dropck</span> <span class="n">types</span> <span class="k">for</span> 
  <span class="err">`</span><span class="n">Canonical</span> <span class="p">{</span> <span class="n">max_universe</span><span class="p">:</span> <span class="n">U0</span><span class="p">,</span> <span class="n">variables</span><span class="p">:</span> <span class="p">[],</span> <span class="n">value</span><span class="p">:</span> <span class="n">ParamEnvAnd</span> <span class="p">{</span> 
    <span class="n">param_env</span><span class="p">:</span> <span class="n">ParamEnv</span> <span class="p">{</span> <span class="n">caller_bounds</span><span class="p">:</span> <span class="p">[],</span> <span class="n">reveal</span><span class="p">:</span> <span class="n">UserFacing</span><span class="p">,</span> <span class="n">def_id</span><span class="p">:</span> <span class="nb">None</span> <span class="p">},</span> <span class="n">value</span><span class="p">:</span> <span class="n">List</span> <span class="p">}</span> 
  <span class="p">}</span><span class="err">`</span>

<span class="n">error</span><span class="p">:</span> <span class="n">aborting</span> <span class="n">due</span> <span class="n">to</span> <span class="mi">2</span> <span class="n">previous</span> <span class="n">errors</span>

<span class="nb">Some</span> <span class="n">errors</span> <span class="n">have</span> <span class="n">detailed</span> <span class="n">explanations</span><span class="p">:</span> <span class="n">E0072</span><span class="p">,</span> <span class="n">E0391</span><span class="py">.
For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">about</span> <span class="n">an</span> <span class="n">error</span><span class="p">,</span> <span class="k">try</span> <span class="err">`</span><span class="n">rustc</span> <span class="o">--</span><span class="n">explain</span> <span class="n">E0072</span><span class="err">`</span><span class="py">.
error</span><span class="p">:</span> <span class="n">could</span> <span class="n">not</span> <span class="n">compile</span> <span class="err">`</span><span class="n">cons</span><span class="o">-</span><span class="n">list</span><span class="err">`</span><span class="py">.

To</span> <span class="n">learn</span> <span class="n">more</span><span class="p">,</span> <span class="n">run</span> <span class="n">the</span> <span class="n">command</span> <span class="n">again</span> <span class="n">with</span> <span class="o">--</span><span class="n">verbose</span><span class="err">.</span>
</code></pre></div></div>
<h4 id="listing-15-4-the-error-we-get-when-attempting-to-define-a-recursive-enum">Listing 15-4: The error we get when attempting to define a recursive enum</h4>

<p>The error shows this type “has infinite size.” The reason is that we’ve defined <code class="language-plaintext highlighter-rouge">List</code> with a variant that is recursive: it holds another value of itself directly. 
As a result, Rust can’t figure out how much space it needs to store a <code class="language-plaintext highlighter-rouge">List</code> value. 
Let’s break down why we get this error a bit. First, let’s look at how Rust decides how much space it needs to store a value of a non-recursive type.</p>

<h3 id="computing-the-size-of-a-non-recursive-type">Computing the Size of a Non-Recursive Type</h3>
<p>Recall the <code class="language-plaintext highlighter-rouge">Message</code> enum we defined in Listing 6-2 when we discussed enum definitions in Chapter 6:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Message</span> <span class="p">{</span>
    <span class="n">Quit</span><span class="p">,</span>
    <span class="n">Move</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">i32</span> <span class="p">},</span>
    <span class="nf">Write</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
    <span class="nf">ChangeColor</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">),</span>
<span class="p">}</span>
</code></pre></div></div>
<p>To determine how much space to allocate for a <code class="language-plaintext highlighter-rouge">Message</code> value, Rust goes through each of the variants to see which variant needs the most space. 
Rust sees that <code class="language-plaintext highlighter-rouge">Message::Quit</code> doesn’t need any space, <code class="language-plaintext highlighter-rouge">Message::Move</code> needs enough space to store two <code class="language-plaintext highlighter-rouge">i32</code> values, and so forth. 
Because only one variant will be used, the most space a <code class="language-plaintext highlighter-rouge">Message</code> value will need is the space it would take to store the largest of its variants.</p>

<p>Contrast this with what happens when Rust tries to determine how much space a recursive type like the <code class="language-plaintext highlighter-rouge">List</code> enum in Listing 15-2 needs. 
The compiler starts by looking at the <code class="language-plaintext highlighter-rouge">Cons</code> variant, which holds a value of type <code class="language-plaintext highlighter-rouge">i32</code> and a value of type <code class="language-plaintext highlighter-rouge">List</code>. 
Therefore, <code class="language-plaintext highlighter-rouge">Cons</code> needs an amount of space equal to the size of an <code class="language-plaintext highlighter-rouge">i32</code> plus the size of a <code class="language-plaintext highlighter-rouge">List</code>. 
To figure out how much memory the <code class="language-plaintext highlighter-rouge">List</code> type needs, the compiler looks at the variants, starting with the <code class="language-plaintext highlighter-rouge">Cons</code> variant. 
The <code class="language-plaintext highlighter-rouge">Cons</code> variant holds a value of type <code class="language-plaintext highlighter-rouge">i32</code> and a value of type <code class="language-plaintext highlighter-rouge">List</code>, and this process continues infinitely, as shown in Figure 15-1.</p>

<p><img src="/assets/images/rust/trpl15-01.svg" alt="Figure 15-1" width="40%" height="35%" /></p>
<h4 id="figure-15-1-an-infinite-list-consisting-of-infinite-cons-variants">Figure 15-1: An infinite List consisting of infinite Cons variants</h4>

<h3 id="using-box-to-get-a-recursive-type-with-a-known-size">Using Box<T> to Get a Recursive Type with a Known Size</T></h3>
<p>Rust can’t figure out how much space to allocate for recursively defined types, so the compiler gives the error in Listing 15-4. But the error does include this helpful suggestion:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">=</span> <span class="n">help</span><span class="p">:</span> <span class="n">insert</span> <span class="nf">indirection</span> <span class="p">(</span><span class="n">e</span><span class="py">.g</span><span class="err">.</span><span class="p">,</span> <span class="n">a</span> <span class="err">`</span><span class="nb">Box</span><span class="err">`</span><span class="p">,</span> <span class="err">`</span><span class="nb">Rc</span><span class="err">`</span><span class="p">,</span> <span class="n">or</span> <span class="err">`</span><span class="o">&amp;</span><span class="err">`</span><span class="p">)</span> 
  <span class="n">at</span> <span class="n">some</span> <span class="n">point</span> <span class="n">to</span> <span class="n">make</span> <span class="err">`</span><span class="n">List</span><span class="err">`</span> <span class="n">representable</span>
</code></pre></div></div>
<p>In this suggestion, “indirection” means that instead of storing a value directly, we’ll change the data structure to store the value indirectly by storing a pointer to the value instead.</p>

<p>Because a <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> is a pointer, Rust always knows how much space a <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> needs: a pointer’s size doesn’t change based on the amount of data it’s pointing to. 
This means we can put a <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> inside the <code class="language-plaintext highlighter-rouge">Cons</code> variant instead of another List value directly. 
The <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> will point to the next <code class="language-plaintext highlighter-rouge">List</code> value that will be on the heap rather than inside the <code class="language-plaintext highlighter-rouge">Cons</code> variant. 
Conceptually, we still have a list, created with lists “holding” other lists, but this implementation is now more like placing the items next to one another rather than inside one another.</p>

<p>We can change the definition of the <code class="language-plaintext highlighter-rouge">List</code> enum in Listing 15-2 and the usage of the <code class="language-plaintext highlighter-rouge">List</code> in Listing 15-3 to the code in Listing 15-5, which will compile:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>
<span class="k">enum</span> <span class="n">List</span> <span class="p">{</span>
    <span class="nf">Cons</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="nb">Nil</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="nn">List</span><span class="p">::{</span><span class="nb">Cons</span><span class="p">,</span> <span class="nb">Nil</span><span class="p">};</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">list</span> <span class="o">=</span> <span class="nf">Cons</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Cons</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Cons</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nb">Nil</span><span class="p">))))));</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-5-definition-of-list-that-uses-box-in-order-to-have-a-known-size">Listing 15-5: Definition of List that uses Box<T> in order to have a known size</T></h4>

<p>The <code class="language-plaintext highlighter-rouge">Cons</code> variant will need the size of an <code class="language-plaintext highlighter-rouge">i32</code> plus the space to store the box’s pointer data. 
The <code class="language-plaintext highlighter-rouge">Nil</code> variant stores no values, so it needs less space than the <code class="language-plaintext highlighter-rouge">Cons</code> variant. 
We now know that any <code class="language-plaintext highlighter-rouge">List</code> value will take up the size of an <code class="language-plaintext highlighter-rouge">i32</code> plus the size of a box’s pointer data. 
By using a box, we’ve broken the infinite, recursive chain, so the compiler can figure out the size it needs to store a <code class="language-plaintext highlighter-rouge">List</code> value. 
Figure 15-2 shows what the <code class="language-plaintext highlighter-rouge">Cons</code> variant looks like now.</p>

<p><img src="/assets/images/rust/trpl15-02.svg" alt="Figure 15-2" width="35%" height="35%" /></p>
<h4 id="figure-15-2-a-list-that-is-not-infinitely-sized-because-cons-holds-a-box">Figure 15-2: A List that is not infinitely sized because Cons holds a Box</h4>

<p>Boxes provide only the indirection and heap allocation; 
they don’t have any other special capabilities, like those we’ll see with the other smart pointer types. 
They also don’t have any performance overhead that these special capabilities incur, so they can be useful in cases like the cons list where the indirection is the only feature we need. 
We’ll look at more use cases for boxes in Chapter 17, too.</p>

<p>The <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> type is a smart pointer because it implements the <code class="language-plaintext highlighter-rouge">Deref</code> trait, which allows <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> values to be treated like references. 
When a <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> value goes out of scope, the heap data that the box is pointing to is cleaned up as well because of the <code class="language-plaintext highlighter-rouge">Drop</code> trait implementation. 
Let’s explore these two traits in more detail. 
These two traits will be even more important to the functionality provided by the other smart pointer types we’ll discuss in the rest of this chapter.</p>

<h2 id="treating-smart-pointers-like-regular-references-with-the-deref-trait">Treating Smart Pointers Like Regular References with the Deref Trait</h2>
<p>Implementing the <code class="language-plaintext highlighter-rouge">Deref</code> trait allows you to customize the behavior of the <em>dereference operator</em>, <code class="language-plaintext highlighter-rouge">*</code> (as opposed to the multiplication or glob operator). 
By implementing <code class="language-plaintext highlighter-rouge">Deref</code> in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.</p>

<p>Let’s first look at how the dereference operator works with regular references. 
Then we’ll try to define a custom type that behaves like <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code>, and see why the dereference operator doesn’t work like a reference on our newly defined type. 
We’ll explore how implementing the <code class="language-plaintext highlighter-rouge">Deref</code> trait makes it possible for smart pointers to work in ways similar to references. 
Then we’ll look at Rust’s <em>deref coercion</em> feature and how it lets us work with either references or smart pointers.</p>

<p class="notice--info">Note: there’s one big difference between the <code class="language-plaintext highlighter-rouge">MyBox&lt;T&gt;</code> type we’re about to build and the real <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code>: our version will not store its data on the heap. We are focusing this example on Deref, so where the data is actually stored is less important than the pointer-like behavior.</p>

<h3 id="following-the-pointer-to-the-value-with-the-dereference-operator">Following the Pointer to the Value with the Dereference Operator</h3>
<p>A regular reference is a type of pointer, and one way to think of a pointer is as an arrow to a value stored somewhere else. 
In Listing 15-6, we create a reference to an <code class="language-plaintext highlighter-rouge">i32</code> value and then use the dereference operator to follow the reference to the data:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="o">*</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-6-using-the-dereference-operator-to-follow-a-reference-to-an-i32-value">Listing 15-6: Using the dereference operator to follow a reference to an i32 value</h4>

<p>The variable <code class="language-plaintext highlighter-rouge">x</code> holds an <code class="language-plaintext highlighter-rouge">i32</code> value, <code class="language-plaintext highlighter-rouge">5</code>. 
We set <code class="language-plaintext highlighter-rouge">y</code> equal to a reference to <code class="language-plaintext highlighter-rouge">x</code>. 
We can assert that <code class="language-plaintext highlighter-rouge">x</code> is equal to <code class="language-plaintext highlighter-rouge">5</code>. 
However, if we want to make an assertion about the value in <code class="language-plaintext highlighter-rouge">y</code>, we have to use <code class="language-plaintext highlighter-rouge">*y</code> to follow the reference to the value it’s pointing to (hence <em>dereference</em>). 
Once we dereference <code class="language-plaintext highlighter-rouge">y</code>, we have access to the integer value <code class="language-plaintext highlighter-rouge">y</code> is pointing to that we can compare with <code class="language-plaintext highlighter-rouge">5</code>.</p>

<p>If we tried to write <code class="language-plaintext highlighter-rouge">assert_eq!(5, y);</code> instead, we would get this compilation error:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="n">deref</span><span class="o">-</span><span class="n">example</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/deref-example)</span>
<span class="n">error</span><span class="p">[</span><span class="n">E0277</span><span class="p">]:</span> <span class="n">can</span><span class="nv">'t</span> <span class="n">compare</span> <span class="err">`</span><span class="p">{</span><span class="n">integer</span><span class="p">}</span><span class="err">`</span> <span class="n">with</span> <span class="err">`</span><span class="o">&amp;</span><span class="p">{</span><span class="n">integer</span><span class="p">}</span><span class="err">`</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">6</span><span class="p">:</span><span class="mi">5</span>
  <span class="p">|</span>
<span class="mi">6</span> <span class="p">|</span>     <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
  <span class="p">|</span>     <span class="o">^^^^^^^^^^^^^^^^^</span> <span class="n">no</span> <span class="n">implementation</span> <span class="k">for</span> <span class="err">`</span><span class="p">{</span><span class="n">integer</span><span class="p">}</span> <span class="o">==</span> <span class="o">&amp;</span><span class="p">{</span><span class="n">integer</span><span class="p">}</span><span class="err">`</span>
  <span class="p">|</span>
  <span class="o">=</span> <span class="n">help</span><span class="p">:</span> <span class="n">the</span> <span class="k">trait</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nb">PartialEq</span><span class="o">&lt;&amp;</span><span class="p">{</span><span class="n">integer</span><span class="p">}</span><span class="o">&gt;</span><span class="err">`</span> <span class="n">is</span> <span class="n">not</span> <span class="n">implemented</span> <span class="k">for</span> <span class="err">`</span><span class="p">{</span><span class="n">integer</span><span class="p">}</span><span class="err">`</span>
  <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">this</span> <span class="n">error</span> <span class="n">originates</span> <span class="k">in</span> <span class="n">a</span> <span class="k">macro</span> <span class="n">outside</span> <span class="n">of</span> <span class="n">the</span> <span class="n">current</span> <span class="k">crate</span> 
  <span class="p">(</span><span class="k">in</span> <span class="n">Nightly</span> <span class="n">builds</span><span class="p">,</span> <span class="n">run</span> <span class="n">with</span> <span class="o">-</span><span class="n">Z</span> <span class="n">external</span><span class="o">-</span><span class="k">macro</span><span class="o">-</span><span class="n">backtrace</span> <span class="k">for</span> <span class="n">more</span> <span class="n">info</span><span class="p">)</span>

<span class="n">error</span><span class="p">:</span> <span class="n">aborting</span> <span class="n">due</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">error</span>

<span class="n">For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">about</span> <span class="n">this</span> <span class="n">error</span><span class="p">,</span> <span class="k">try</span> <span class="err">`</span><span class="n">rustc</span> <span class="o">--</span><span class="n">explain</span> <span class="n">E0277</span><span class="err">`</span><span class="py">.
error</span><span class="p">:</span> <span class="n">could</span> <span class="n">not</span> <span class="n">compile</span> <span class="err">`</span><span class="n">deref</span><span class="o">-</span><span class="n">example</span><span class="err">`</span><span class="py">.

To</span> <span class="n">learn</span> <span class="n">more</span><span class="p">,</span> <span class="n">run</span> <span class="n">the</span> <span class="n">command</span> <span class="n">again</span> <span class="n">with</span> <span class="o">--</span><span class="n">verbose</span><span class="err">.</span>
</code></pre></div></div>
<p>Comparing a number and a reference to a number isn’t allowed because they’re different types. 
We must use the dereference operator to follow the reference to the value it’s pointing to.</p>

<h3 id="using-box-like-a-reference">Using Box<T> Like a Reference</T></h3>
<p>We can rewrite the code in Listing 15-6 to use a <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> instead of a reference; the dereference operator will work as shown in Listing 15-7:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="o">*</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-7-using-the-dereference-operator-on-a-box">Listing 15-7: Using the dereference operator on a Box<i32></i32></h4>

<p>The only difference between Listing 15-7 and Listing 15-6 is that here we set <code class="language-plaintext highlighter-rouge">y</code> to be an instance of a box pointing to the value in <code class="language-plaintext highlighter-rouge">x</code> rather than a reference pointing to the value of <code class="language-plaintext highlighter-rouge">x</code>. 
In the last assertion, we can use the dereference operator to follow the box’s pointer in the same way that we did when <code class="language-plaintext highlighter-rouge">y</code> was a reference. 
Next, we’ll explore what is special about <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> that enables us to use the dereference operator by defining our own box type.</p>

<h3 id="defining-our-own-smart-pointer">Defining Our Own Smart Pointer</h3>
<p>Let’s build a smart pointer similar to the <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> type provided by the standard library to experience how smart pointers behave differently from references by default. 
Then we’ll look at how to add the ability to use the dereference operator.</p>

<p>The <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> type is ultimately defined as a tuple struct with one element, so Listing 15-8 defines a <code class="language-plaintext highlighter-rouge">MyBox&lt;T&gt;</code> type in the same way. We’ll also define a <code class="language-plaintext highlighter-rouge">new</code> function to match the <code class="language-plaintext highlighter-rouge">new</code> function defined on <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>
<span class="k">struct</span> <span class="n">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">MyBox</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-8-defining-a-myboxt-type">Listing 15-8: Defining a <code class="language-plaintext highlighter-rouge">MyBox&lt;T&gt;</code> type</h4>

<p>We define a struct named <code class="language-plaintext highlighter-rouge">MyBox</code> and declare a generic parameter <code class="language-plaintext highlighter-rouge">T</code>, because we want our type to hold values of any type. The <code class="language-plaintext highlighter-rouge">MyBox</code> type is a tuple struct with one element of type <code class="language-plaintext highlighter-rouge">T</code>. The <code class="language-plaintext highlighter-rouge">MyBox::new</code> function takes one parameter of type <code class="language-plaintext highlighter-rouge">T</code> and returns a MyBox instance that holds the value passed in.</p>

<p>Let’s try adding the <code class="language-plaintext highlighter-rouge">main</code> function in Listing 15-7 to Listing 15-8 and changing it to use the <code class="language-plaintext highlighter-rouge">MyBox&lt;T&gt;</code> type we’ve defined instead of <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code>. The code in Listing 15-9 won’t compile because Rust doesn’t know how to dereference <code class="language-plaintext highlighter-rouge">MyBox</code>.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="nn">MyBox</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="o">*</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-9-attempting-to-use-mybox-in-the-same-way-we-used-references-and-box">Listing 15-9: Attempting to use MyBox<T> in the same way we used references and Box<T></T></T></h4>

<p>Here’s the resulting compilation error:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="n">deref</span><span class="o">-</span><span class="n">example</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/deref-example)</span>
<span class="n">error</span><span class="p">[</span><span class="n">E0614</span><span class="p">]:</span> <span class="k">type</span> <span class="err">`</span><span class="n">MyBox</span><span class="o">&lt;</span><span class="p">{</span><span class="n">integer</span><span class="p">}</span><span class="o">&gt;</span><span class="err">`</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">dereferenced</span>
  <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">14</span><span class="p">:</span><span class="mi">19</span>
   <span class="p">|</span>
<span class="mi">14</span> <span class="p">|</span>     <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="o">*</span><span class="n">y</span><span class="p">);</span>
   <span class="p">|</span>                   <span class="o">^^</span>

<span class="n">error</span><span class="p">:</span> <span class="n">aborting</span> <span class="n">due</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">error</span>

<span class="n">For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">about</span> <span class="n">this</span> <span class="n">error</span><span class="p">,</span> <span class="k">try</span> <span class="err">`</span><span class="n">rustc</span> <span class="o">--</span><span class="n">explain</span> <span class="n">E0614</span><span class="err">`</span><span class="py">.
error</span><span class="p">:</span> <span class="n">could</span> <span class="n">not</span> <span class="n">compile</span> <span class="err">`</span><span class="n">deref</span><span class="o">-</span><span class="n">example</span><span class="err">`</span><span class="py">.

To</span> <span class="n">learn</span> <span class="n">more</span><span class="p">,</span> <span class="n">run</span> <span class="n">the</span> <span class="n">command</span> <span class="n">again</span> <span class="n">with</span> <span class="o">--</span><span class="n">verbose</span><span class="err">.</span>
</code></pre></div></div>

<p>Our <code class="language-plaintext highlighter-rouge">MyBox&lt;T&gt;</code> type can’t be dereferenced because we haven’t implemented that ability on our type. 
To enable dereferencing with the <code class="language-plaintext highlighter-rouge">*</code> operator, we implement the <code class="language-plaintext highlighter-rouge">Deref</code> trait.</p>

<h3 id="treating-a-type-like-a-reference-by-implementing-the-deref-trait">Treating a Type Like a Reference by Implementing the Deref Trait</h3>
<p>As discussed in Chapter 10, to implement a trait, we need to provide implementations for the trait’s required methods. 
The <code class="language-plaintext highlighter-rouge">Deref</code> trait, provided by the standard library, requires us to implement one method named <code class="language-plaintext highlighter-rouge">deref</code> that borrows <code class="language-plaintext highlighter-rouge">self</code> and returns a reference to the inner data. 
Listing 15-10 contains an implementation of <code class="language-plaintext highlighter-rouge">Deref</code> to add to the definition of <code class="language-plaintext highlighter-rouge">MyBox</code>:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ops</span><span class="p">::</span><span class="n">Deref</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Deref</span> <span class="k">for</span> <span class="n">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Target</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="na">.0</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-10-implementing-deref-on-myboxt">Listing 15-10: Implementing Deref on <code class="language-plaintext highlighter-rouge">MyBox&lt;T&gt;</code></h4>

<p>The <code class="language-plaintext highlighter-rouge">type Target = T;</code> syntax defines an associated type for the <code class="language-plaintext highlighter-rouge">Deref</code> trait to use. 
Associated types are a slightly different way of declaring a generic parameter, but you don’t need to worry about them for now; we’ll cover them in more detail in Chapter 19.</p>

<p>We fill in the body of the <code class="language-plaintext highlighter-rouge">deref</code> method with <code class="language-plaintext highlighter-rouge">&amp;self.0</code> so <code class="language-plaintext highlighter-rouge">deref</code> returns a reference to the value we want to access with the <code class="language-plaintext highlighter-rouge">*</code> operator. 
The main function in Listing 15-9 that calls <code class="language-plaintext highlighter-rouge">*</code> on the <code class="language-plaintext highlighter-rouge">MyBox&lt;T&gt;</code> value now compiles, and the assertions pass!</p>

<p>Without the <code class="language-plaintext highlighter-rouge">Deref</code> trait, the compiler can only dereference <code class="language-plaintext highlighter-rouge">&amp;</code> references. 
The <code class="language-plaintext highlighter-rouge">deref</code> method gives the compiler the ability to take a value of any type that implements <code class="language-plaintext highlighter-rouge">Deref</code> and call the <code class="language-plaintext highlighter-rouge">deref</code> method to get a <code class="language-plaintext highlighter-rouge">&amp;</code> reference that it knows how to dereference.</p>

<p>When we entered <code class="language-plaintext highlighter-rouge">*y</code> in Listing 15-9, behind the scenes Rust actually ran this code:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="nf">.deref</span><span class="p">())</span>
</code></pre></div></div>
<p>Rust substitutes the <code class="language-plaintext highlighter-rouge">*</code> operator with a call to the <code class="language-plaintext highlighter-rouge">deref</code> method and then a plain dereference so we don’t have to think about whether or not we need to call the <code class="language-plaintext highlighter-rouge">deref</code> method. 
This Rust feature lets us write code that functions identically whether we have a regular reference or a type that implements <code class="language-plaintext highlighter-rouge">Deref</code>.</p>

<p>The reason the <code class="language-plaintext highlighter-rouge">deref</code> method returns a reference to a value, and that the plain dereference outside the parentheses in <code class="language-plaintext highlighter-rouge">*(y.deref())</code> is still necessary, is the ownership system. 
If the <code class="language-plaintext highlighter-rouge">deref</code> method returned the value directly instead of a reference to the value, the value would be moved out of <code class="language-plaintext highlighter-rouge">self</code>. 
We don’t want to take ownership of the inner value inside <code class="language-plaintext highlighter-rouge">MyBox&lt;T&gt;</code> in this case or in most cases where we use the dereference operator.</p>

<p>Note that the <code class="language-plaintext highlighter-rouge">*</code> operator is replaced with a call to the <code class="language-plaintext highlighter-rouge">deref</code> method and then a call to the <code class="language-plaintext highlighter-rouge">*</code> operator just once, each time we use a <code class="language-plaintext highlighter-rouge">*</code> in our code. 
Because the substitution of the <code class="language-plaintext highlighter-rouge">*</code> operator does not recurse infinitely, we end up with data of type <code class="language-plaintext highlighter-rouge">i32</code>, which matches the <code class="language-plaintext highlighter-rouge">5</code> in <code class="language-plaintext highlighter-rouge">assert_eq!</code> in Listing 15-9.</p>

<h3 id="implicit-deref-coercions-with-functions-and-methods">Implicit Deref Coercions with Functions and Methods</h3>
<p><em>Deref coercion</em> is a convenience that Rust performs on arguments to functions and methods. 
Deref coercion works only on types that implement the <code class="language-plaintext highlighter-rouge">Deref</code> trait. 
Deref coercion converts such a type into a reference to another type. 
For example, deref coercion can convert <code class="language-plaintext highlighter-rouge">&amp;String</code> to <code class="language-plaintext highlighter-rouge">&amp;str</code> because <code class="language-plaintext highlighter-rouge">String</code> implements the <code class="language-plaintext highlighter-rouge">Deref</code> trait such that it returns <code class="language-plaintext highlighter-rouge">str</code>. 
Deref coercion happens automatically when we pass a reference to a particular type’s value as an argument to a function or method that doesn’t match the parameter type in the function or method definition. 
A sequence of calls to the <code class="language-plaintext highlighter-rouge">deref</code> method converts the type we provided into the type the parameter needs.</p>

<p>Deref coercion was added to Rust so that programmers writing function and method calls don’t need to add as many explicit references and dereferences with <code class="language-plaintext highlighter-rouge">&amp;</code> and <code class="language-plaintext highlighter-rouge">*</code>. 
The deref coercion feature also lets us write more code that can work for either references or smart pointers.</p>

<p>To see deref coercion in action, let’s use the <code class="language-plaintext highlighter-rouge">MyBox&lt;T&gt;</code> type we defined in Listing 15-8 as well as the implementation of <code class="language-plaintext highlighter-rouge">Deref</code> that we added in Listing 15-10. 
Listing 15-11 shows the definition of a function that has a string slice parameter:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>
<span class="k">fn</span> <span class="nf">hello</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello, {}!"</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-11-a-hello-function-that-has-the-parameter-name-of-type-str">Listing 15-11: A hello function that has the parameter name of type &amp;str</h4>

<p>We can call the <code class="language-plaintext highlighter-rouge">hello</code> function with a string slice as an argument, such as <code class="language-plaintext highlighter-rouge">hello("Rust");</code> for example. 
Deref coercion makes it possible to call <code class="language-plaintext highlighter-rouge">hello</code> with a reference to a value of type <code class="language-plaintext highlighter-rouge">MyBox&lt;String&gt;</code>, as shown in Listing 15-12:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="nn">MyBox</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Rust"</span><span class="p">));</span>
    <span class="nf">hello</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-12-calling-hello-with-a-reference-to-a-mybox-value-which-works-because-of-deref-coercion">Listing 15-12: Calling hello with a reference to a MyBox<String> value, which works because of deref coercion</String></h4>

<p>Here we’re calling the <code class="language-plaintext highlighter-rouge">hello</code> function with the argument <code class="language-plaintext highlighter-rouge">&amp;m</code>, which is a reference to a <code class="language-plaintext highlighter-rouge">MyBox&lt;String&gt;</code> value. 
Because we implemented the <code class="language-plaintext highlighter-rouge">Deref</code> trait on <code class="language-plaintext highlighter-rouge">MyBox&lt;T&gt;</code> in Listing 15-10, Rust can turn <code class="language-plaintext highlighter-rouge">&amp;MyBox&lt;String&gt;</code> into <code class="language-plaintext highlighter-rouge">&amp;String</code> by calling deref. 
The standard library provides an implementation of <code class="language-plaintext highlighter-rouge">Deref</code> on <code class="language-plaintext highlighter-rouge">String</code> that returns a string slice, and this is in the API documentation for <code class="language-plaintext highlighter-rouge">Deref</code>. 
Rust calls <code class="language-plaintext highlighter-rouge">deref</code> again to turn the <code class="language-plaintext highlighter-rouge">&amp;String</code> into <code class="language-plaintext highlighter-rouge">&amp;str</code>, which matches the <code class="language-plaintext highlighter-rouge">hello</code> function’s definition.</p>

<p>If Rust didn’t implement deref coercion, we would have to write the code in Listing 15-13 instead of the code in Listing 15-12 to call hello with a value of type <code class="language-plaintext highlighter-rouge">&amp;MyBox&lt;String&gt;</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="nn">MyBox</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Rust"</span><span class="p">));</span>
    <span class="nf">hello</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">m</span><span class="p">)[</span><span class="o">..</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-13-the-code-we-would-have-to-write-if-rust-didnt-have-deref-coercion">Listing 15-13: The code we would have to write if Rust didn’t have deref coercion</h4>

<p>The <code class="language-plaintext highlighter-rouge">(*m)</code> dereferences the <code class="language-plaintext highlighter-rouge">MyBox&lt;String&gt;</code> into a <code class="language-plaintext highlighter-rouge">String</code>. 
Then the <code class="language-plaintext highlighter-rouge">&amp;</code> and <code class="language-plaintext highlighter-rouge">[..]</code> take a string slice of the <code class="language-plaintext highlighter-rouge">String</code> that is equal to the whole string to match the signature of <code class="language-plaintext highlighter-rouge">hello</code>. 
The code without deref coercions is harder to read, write, and understand with all of these symbols involved. 
Deref coercion allows Rust to handle these conversions for us automatically.</p>

<p>When the <code class="language-plaintext highlighter-rouge">Deref</code> trait is defined for the types involved, Rust will analyze the types and use <code class="language-plaintext highlighter-rouge">Deref::deref</code> as many times as necessary to get a reference to match the parameter’s type. 
The number of times that <code class="language-plaintext highlighter-rouge">Deref::deref</code> needs to be inserted is resolved at compile time, so there is no runtime penalty for taking advantage of deref coercion!</p>

<h3 id="how-deref-coercion-interacts-with-mutability">How Deref Coercion Interacts with Mutability</h3>
<p>Similar to how you use the <code class="language-plaintext highlighter-rouge">Deref</code> trait to override the <code class="language-plaintext highlighter-rouge">*</code> operator on immutable references, you can use the <code class="language-plaintext highlighter-rouge">DerefMut</code> trait to override the <code class="language-plaintext highlighter-rouge">*</code> operator on mutable references.</p>

<p>Rust does deref coercion when it finds types and trait implementations in three cases:</p>

<ul>
  <li>From <code class="language-plaintext highlighter-rouge">&amp;T</code> to <code class="language-plaintext highlighter-rouge">&amp;U</code> when T: Deref&lt;Target=U&gt;</li>
  <li>From <code class="language-plaintext highlighter-rouge">&amp;mut T</code> to <code class="language-plaintext highlighter-rouge">&amp;mut U</code> when T: DerefMut&lt;Target=U&gt;</li>
  <li>From <code class="language-plaintext highlighter-rouge">&amp;mut T</code> to <code class="language-plaintext highlighter-rouge">&amp;U</code> when T: Deref&lt;Target=U&gt;</li>
</ul>

<p>The first two cases are the same except for mutability. 
The first case states that if you have a <code class="language-plaintext highlighter-rouge">&amp;T</code>, and <code class="language-plaintext highlighter-rouge">T</code> implements <code class="language-plaintext highlighter-rouge">Deref</code> to some type <code class="language-plaintext highlighter-rouge">U</code>, you can get a <code class="language-plaintext highlighter-rouge">&amp;U</code> transparently. 
The second case states that the same deref coercion happens for mutable references.</p>

<p>The third case is trickier: Rust will also coerce a mutable reference to an immutable one. 
But the reverse is <strong>not</strong> possible: immutable references will never coerce to mutable references. 
Because of the borrowing rules, if you have a mutable reference, that mutable reference must be the only reference to that data (otherwise, the program wouldn’t compile). 
Converting one mutable reference to one immutable reference will never break the borrowing rules. 
Converting an immutable reference to a mutable reference would require that the initial immutable reference is the only immutable reference to that data, but the borrowing rules don’t guarantee that. 
Therefore, Rust can’t make the assumption that converting an immutable reference to a mutable reference is possible.</p>

<h2 id="running-code-on-cleanup-with-the-drop-trait">Running Code on Cleanup with the Drop Trait</h2>
<p>The second trait important to the smart pointer pattern is <code class="language-plaintext highlighter-rouge">Drop</code>, which lets you customize what happens when a value is about to go out of scope. 
You can provide an implementation for the <code class="language-plaintext highlighter-rouge">Drop</code> trait on any type, and the code you specify can be used to release resources like files or network connections. 
We’re introducing <code class="language-plaintext highlighter-rouge">Drop</code> in the context of smart pointers because the functionality of the <code class="language-plaintext highlighter-rouge">Drop</code> trait is almost always used when implementing a smart pointer. 
For example, <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> customizes <code class="language-plaintext highlighter-rouge">Drop</code> to deallocate the space on the heap that the box points to.</p>

<p>In some languages, the programmer must call code to free memory or resources every time they finish using an instance of a smart pointer. 
If they forget, the system might become overloaded and crash. 
In Rust, you can specify that a particular bit of code be run whenever a value goes out of scope, and the compiler will insert this code automatically. 
As a result, you don’t need to be careful about placing cleanup code everywhere in a program that an instance of a particular type is finished with—you still won’t leak resources!</p>

<p>Specify the code to run when a value goes out of scope by implementing the <code class="language-plaintext highlighter-rouge">Drop</code> trait. 
The <code class="language-plaintext highlighter-rouge">Drop</code> trait requires you to implement one method named <code class="language-plaintext highlighter-rouge">drop</code> that takes a mutable reference to <code class="language-plaintext highlighter-rouge">self</code>. 
To see when Rust calls <code class="language-plaintext highlighter-rouge">drop</code>, let’s implement <code class="language-plaintext highlighter-rouge">drop</code> with <code class="language-plaintext highlighter-rouge">println!</code> statements for now.</p>

<p>Listing 15-14 shows a <code class="language-plaintext highlighter-rouge">CustomSmartPointer</code> struct whose only custom functionality is that it will print <code class="language-plaintext highlighter-rouge">Dropping CustomSmartPointer!</code> when the instance goes out of scope. 
This example demonstrates when Rust runs the <code class="language-plaintext highlighter-rouge">drop</code> function.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>
<span class="k">struct</span> <span class="n">CustomSmartPointer</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">CustomSmartPointer</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Dropping CustomSmartPointer with data `{}`!"</span><span class="p">,</span> <span class="k">self</span><span class="py">.data</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="n">CustomSmartPointer</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"my stuff"</span><span class="p">),</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="n">CustomSmartPointer</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"other stuff"</span><span class="p">),</span>
    <span class="p">};</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"CustomSmartPointers created."</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-14-a-customsmartpointer-struct-that-implements-the-drop-trait-where-we-would-put-our-cleanup-code">Listing 15-14: A CustomSmartPointer struct that implements the Drop trait where we would put our cleanup code</h4>

<p>The <code class="language-plaintext highlighter-rouge">Drop</code> trait is included in the prelude, so we don’t need to bring it into scope. 
We implement the <code class="language-plaintext highlighter-rouge">Drop</code> trait on <code class="language-plaintext highlighter-rouge">CustomSmartPointer</code> and provide an implementation for the <code class="language-plaintext highlighter-rouge">drop</code> method that calls <code class="language-plaintext highlighter-rouge">println!</code>. 
The body of the <code class="language-plaintext highlighter-rouge">drop</code> function is where you would place any logic that you wanted to run when an instance of your type goes out of scope. We’re printing some text here to demonstrate when Rust will call <code class="language-plaintext highlighter-rouge">drop</code>.</p>

<p>In <code class="language-plaintext highlighter-rouge">main</code>, we create two instances of <code class="language-plaintext highlighter-rouge">CustomSmartPointer</code> and then print <code class="language-plaintext highlighter-rouge">CustomSmartPointers created.</code> At the end of <code class="language-plaintext highlighter-rouge">main</code>, our instances of <code class="language-plaintext highlighter-rouge">CustomSmartPointer</code> will go out of scope, and Rust will call the code we put in the <code class="language-plaintext highlighter-rouge">drop</code> method, printing our final message. 
Note that we didn’t need to call the drop method explicitly.</p>

<p>When we run this program, we’ll see the following output:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="nb">drop</span><span class="o">-</span><span class="n">example</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/drop-example)</span>
    <span class="n">Finished</span> <span class="n">dev</span> <span class="p">[</span><span class="n">unoptimized</span> <span class="o">+</span> <span class="n">debuginfo</span><span class="p">]</span> <span class="nf">target</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">in</span> <span class="mf">0.60</span><span class="n">s</span>
     <span class="n">Running</span> <span class="err">`</span><span class="n">target</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="nb">drop</span><span class="o">-</span><span class="n">example</span><span class="err">`</span>
<span class="n">CustomSmartPointers</span> <span class="n">created</span><span class="py">.
Dropping</span> <span class="n">CustomSmartPointer</span> <span class="n">with</span> <span class="n">data</span> <span class="err">`</span><span class="n">other</span> <span class="n">stuff</span><span class="err">`</span><span class="o">!</span>
<span class="n">Dropping</span> <span class="n">CustomSmartPointer</span> <span class="n">with</span> <span class="n">data</span> <span class="err">`</span><span class="n">my</span> <span class="n">stuff</span><span class="err">`</span><span class="o">!</span>
</code></pre></div></div>
<p>Rust automatically called <code class="language-plaintext highlighter-rouge">drop</code> for us when our instances went out of scope, calling the code we specified. 
Variables are dropped in the reverse order of their creation, so <code class="language-plaintext highlighter-rouge">d</code> was dropped before <code class="language-plaintext highlighter-rouge">c</code>. 
This example gives you a visual guide to how the <code class="language-plaintext highlighter-rouge">drop</code> method works; usually you would specify the cleanup code that your type needs to run rather than a print message.</p>

<h3 id="dropping-a-value-early-with-stdmemdrop">Dropping a Value Early with std::mem::drop</h3>
<p>Unfortunately, it’s not straightforward to disable the automatic <code class="language-plaintext highlighter-rouge">drop</code> functionality. 
Disabling <code class="language-plaintext highlighter-rouge">drop</code> isn’t usually necessary; the whole point of the <code class="language-plaintext highlighter-rouge">Drop</code> trait is that it’s taken care of automatically. 
Occasionally, however, you might want to clean up a value early. 
One example is when using smart pointers that manage locks: you might want to force the <code class="language-plaintext highlighter-rouge">drop</code> method that releases the lock so that other code in the same scope can acquire the lock. 
Rust doesn’t let you call the <code class="language-plaintext highlighter-rouge">Drop</code> trait’s <code class="language-plaintext highlighter-rouge">drop</code> method manually; instead you have to call the <code class="language-plaintext highlighter-rouge">std::mem::drop</code> function provided by the standard library if you want to force a value to be dropped before the end of its scope.</p>

<p>If we try to call the <code class="language-plaintext highlighter-rouge">Drop</code> trait’s <code class="language-plaintext highlighter-rouge">drop</code> method manually by modifying the main function from Listing 15-14, as shown in Listing 15-15, we’ll get a compiler error:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="n">CustomSmartPointer</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"some data"</span><span class="p">),</span>
    <span class="p">};</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"CustomSmartPointer created."</span><span class="p">);</span>
    <span class="n">c</span><span class="nf">.drop</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"CustomSmartPointer dropped before the end of main."</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-15-attempting-to-call-the-drop-method-from-the-drop-trait-manually-to-clean-up-early">Listing 15-15: Attempting to call the drop method from the Drop trait manually to clean up early</h4>

<p>When we try to compile this code, we’ll get this error:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="nb">drop</span><span class="o">-</span><span class="n">example</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/drop-example)</span>
<span class="n">error</span><span class="p">[</span><span class="n">E0040</span><span class="p">]:</span> <span class="n">explicit</span> <span class="k">use</span> <span class="n">of</span> <span class="n">destructor</span> <span class="n">method</span>
  <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">16</span><span class="p">:</span><span class="mi">7</span>
   <span class="p">|</span>
<span class="mi">16</span> <span class="p">|</span>     <span class="n">c</span><span class="nf">.drop</span><span class="p">();</span>
   <span class="p">|</span>       <span class="o">^^^^</span> <span class="n">explicit</span> <span class="n">destructor</span> <span class="n">calls</span> <span class="n">not</span> <span class="n">allowed</span>

<span class="n">error</span><span class="p">:</span> <span class="n">aborting</span> <span class="n">due</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">error</span>

<span class="n">For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">about</span> <span class="n">this</span> <span class="n">error</span><span class="p">,</span> <span class="k">try</span> <span class="err">`</span><span class="n">rustc</span> <span class="o">--</span><span class="n">explain</span> <span class="n">E0040</span><span class="err">`</span><span class="py">.
error</span><span class="p">:</span> <span class="n">could</span> <span class="n">not</span> <span class="n">compile</span> <span class="err">`</span><span class="nb">drop</span><span class="o">-</span><span class="n">example</span><span class="err">`</span><span class="py">.

To</span> <span class="n">learn</span> <span class="n">more</span><span class="p">,</span> <span class="n">run</span> <span class="n">the</span> <span class="n">command</span> <span class="n">again</span> <span class="n">with</span> <span class="o">--</span><span class="n">verbose</span><span class="err">.</span>
</code></pre></div></div>
<p>This error message states that we’re not allowed to explicitly call <code class="language-plaintext highlighter-rouge">drop</code>. 
The error message uses the term <em>destructor</em>, which is the general programming term for a function that cleans up an instance. 
A <em>destructor</em> is analogous to a <em>constructor</em>, which creates an instance. 
The <code class="language-plaintext highlighter-rouge">drop</code> function in Rust is one particular destructor.</p>

<p>Rust doesn’t let us call <code class="language-plaintext highlighter-rouge">drop</code> explicitly because Rust would still automatically call <code class="language-plaintext highlighter-rouge">drop</code> on the value at the end of main. 
This would be a <em>double free</em> error because Rust would be trying to clean up the same value twice.</p>

<p>We can’t disable the automatic insertion of <code class="language-plaintext highlighter-rouge">drop</code> when a value goes out of scope, and we can’t call the <code class="language-plaintext highlighter-rouge">drop</code> method explicitly. 
So, if we need to force a value to be cleaned up early, we can use the <code class="language-plaintext highlighter-rouge">std::mem::drop</code> function.</p>

<p>The <code class="language-plaintext highlighter-rouge">std::mem::drop</code> function is different from the <code class="language-plaintext highlighter-rouge">drop</code> method in the <code class="language-plaintext highlighter-rouge">Drop</code> trait. 
We call it by passing the value we want to force to be dropped early as an argument. 
The function is in the prelude, so we can modify <code class="language-plaintext highlighter-rouge">main</code> in Listing 15-15 to call the drop function, as shown in Listing 15-16:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="n">CustomSmartPointer</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"some data"</span><span class="p">),</span>
    <span class="p">};</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"CustomSmartPointer created."</span><span class="p">);</span>
    <span class="nf">drop</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"CustomSmartPointer dropped before the end of main."</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-16-calling-stdmemdrop-to-explicitly-drop-a-value-before-it-goes-out-of-scope">Listing 15-16: Calling std::mem::drop to explicitly drop a value before it goes out of scope</h4>

<p>Running this code will print the following:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="nb">drop</span><span class="o">-</span><span class="n">example</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/drop-example)</span>
    <span class="n">Finished</span> <span class="n">dev</span> <span class="p">[</span><span class="n">unoptimized</span> <span class="o">+</span> <span class="n">debuginfo</span><span class="p">]</span> <span class="nf">target</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">in</span> <span class="mf">0.73</span><span class="n">s</span>
     <span class="n">Running</span> <span class="err">`</span><span class="n">target</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="nb">drop</span><span class="o">-</span><span class="n">example</span><span class="err">`</span>
<span class="n">CustomSmartPointer</span> <span class="n">created</span><span class="py">.
Dropping</span> <span class="n">CustomSmartPointer</span> <span class="n">with</span> <span class="n">data</span> <span class="err">`</span><span class="n">some</span> <span class="n">data</span><span class="err">`</span><span class="o">!</span>
<span class="n">CustomSmartPointer</span> <span class="n">dropped</span> <span class="n">before</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">main</span><span class="err">.</span>
</code></pre></div></div>
<p>The text <code class="language-plaintext highlighter-rouge">Dropping CustomSmartPointer with data 'some data'!</code> is printed between the <code class="language-plaintext highlighter-rouge">CustomSmartPointer created.</code> 
and <code class="language-plaintext highlighter-rouge">CustomSmartPointer dropped before the end of main.</code> text, showing that the <code class="language-plaintext highlighter-rouge">drop</code> method code is called to drop <code class="language-plaintext highlighter-rouge">c</code> at that point.</p>

<p>You can use code specified in a <code class="language-plaintext highlighter-rouge">Drop</code> trait implementation in many ways to make cleanup convenient and safe: for instance, you could use it to create your own memory allocator! With the <code class="language-plaintext highlighter-rouge">Drop</code> trait and Rust’s ownership system, you don’t have to remember to clean up because Rust does it automatically.</p>

<p>You also don’t have to worry about problems resulting from accidentally cleaning up values still in use: the ownership system that makes sure references are always valid also ensures that <code class="language-plaintext highlighter-rouge">drop</code> gets called <strong>only once</strong> when the value is no longer being used.</p>

<p>Now that we’ve examined <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> and some of the characteristics of smart pointers, let’s look at a few other smart pointers defined in the standard library.</p>

<h2 id="154-start-rc-the-reference-counted-smart-pointer">15.4 start Rc<T>, the Reference Counted Smart Pointer</T></h2>
<p>In the majority of cases, ownership is clear: you know exactly which variable owns a given value. However, there are cases when a single value might have multiple owners. For example, in graph data structures, multiple edges might point to the same node, and that node is conceptually owned by all of the edges that point to it. A node shouldn’t be cleaned up unless it doesn’t have any edges pointing to it.</p>

<p>To enable multiple ownership, Rust has a type called <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code>, which is an abbreviation for <em>reference counting</em>. The <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> type keeps track of the number of references to a value which determines whether or not a value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid.</p>

<p>Imagine <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> as a TV in a family room. When one person enters to watch TV, they turn it on. 
Others can come into the room and watch the TV. When the last person leaves the room, they turn off the TV because it’s no longer being used. 
If someone turns off the TV while others are still watching it, there would be uproar from the remaining TV watchers!</p>

<p>We use the <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> type when we want to allocate some data on the heap for multiple parts of our program to read and we can’t determine at compile time which part will finish using the data last. 
If we knew which part would finish last, we could just make that part the data’s owner, and the normal ownership rules enforced at compile time would take effect.</p>

<p>Note that <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> is only for use in single-threaded scenarios. When we discuss concurrency in Chapter 16, we’ll cover how to do reference counting in multithreaded programs.</p>

<h3 id="using-rc-to-share-data">Using Rc<T> to Share Data</T></h3>
<p>Let’s return to our cons list example in Listing 15-5. Recall that we defined it using <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code>. 
This time, we’ll create two lists that both share ownership of a third list. Conceptually, this looks similar to Figure 15-3:</p>

<p><img src="/assets/images/rust/trpl15-03.svg" alt="Figure 15-3" width="70%" height="60%" /></p>
<h4 id="figure-15-3-two-lists-b-and-c-sharing-ownership-of-a-third-list-a">Figure 15-3: Two lists, b and c, sharing ownership of a third list, a</h4>

<p>We’ll create list <code class="language-plaintext highlighter-rouge">a</code> that contains 5 and then 10. 
Then we’ll make two more lists: <code class="language-plaintext highlighter-rouge">b</code> that starts with 3 and <code class="language-plaintext highlighter-rouge">c</code> that starts with 4. 
Both <code class="language-plaintext highlighter-rouge">b</code> and <code class="language-plaintext highlighter-rouge">c</code> lists will then continue on to the first a list containing 5 and 10. 
In other words, both lists will share the first list containing 5 and 10.</p>

<p>Trying to implement this scenario using our definition of <code class="language-plaintext highlighter-rouge">List</code> with <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> won’t work, as shown in Listing 15-17:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>
<span class="k">enum</span> <span class="n">List</span> <span class="p">{</span>
    <span class="nf">Cons</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="nb">Nil</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="nn">List</span><span class="p">::{</span><span class="nb">Cons</span><span class="p">,</span> <span class="nb">Nil</span><span class="p">};</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nf">Cons</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Cons</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nb">Nil</span><span class="p">))));</span>
    <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="nf">Cons</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
    <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="nf">Cons</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-17-demonstrating-were-not-allowed-to-have-two-lists-using-box-that-try-to-share-ownership-of-a-third-list">Listing 15-17: Demonstrating we’re not allowed to have two lists using Box<T> that try to share ownership of a third list</T></h4>

<p>When we compile this code, we get this error:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="n">cons</span><span class="o">-</span><span class="n">list</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/cons-list)</span>
<span class="n">error</span><span class="p">[</span><span class="n">E0382</span><span class="p">]:</span> <span class="k">use</span> <span class="n">of</span> <span class="n">moved</span> <span class="n">value</span><span class="p">:</span> <span class="err">`</span><span class="n">a</span><span class="err">`</span>
  <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">11</span><span class="p">:</span><span class="mi">30</span>
   <span class="p">|</span>
<span class="mi">9</span>  <span class="p">|</span>     <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nf">Cons</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Cons</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nb">Nil</span><span class="p">))));</span>
   <span class="p">|</span>         <span class="o">-</span> <span class="k">move</span> <span class="n">occurs</span> <span class="n">because</span> <span class="err">`</span><span class="n">a</span><span class="err">`</span> <span class="n">has</span> <span class="k">type</span> <span class="err">`</span><span class="n">List</span><span class="err">`</span><span class="p">,</span> <span class="n">which</span> <span class="n">does</span> <span class="n">not</span> <span class="n">implement</span> <span class="n">the</span> <span class="err">`</span><span class="nb">Copy</span><span class="err">`</span> <span class="k">trait</span>
<span class="mi">10</span> <span class="p">|</span>     <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="nf">Cons</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
   <span class="p">|</span>                              <span class="o">-</span> <span class="n">value</span> <span class="n">moved</span> <span class="n">here</span>
<span class="mi">11</span> <span class="p">|</span>     <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="nf">Cons</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
   <span class="p">|</span>                              <span class="o">^</span> <span class="n">value</span> <span class="n">used</span> <span class="n">here</span> <span class="n">after</span> <span class="k">move</span>

<span class="n">error</span><span class="p">:</span> <span class="n">aborting</span> <span class="n">due</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">error</span>

<span class="n">For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">about</span> <span class="n">this</span> <span class="n">error</span><span class="p">,</span> <span class="k">try</span> <span class="err">`</span><span class="n">rustc</span> <span class="o">--</span><span class="n">explain</span> <span class="n">E0382</span><span class="err">`</span><span class="py">.
error</span><span class="p">:</span> <span class="n">could</span> <span class="n">not</span> <span class="n">compile</span> <span class="err">`</span><span class="n">cons</span><span class="o">-</span><span class="n">list</span><span class="err">`</span><span class="py">.

To</span> <span class="n">learn</span> <span class="n">more</span><span class="p">,</span> <span class="n">run</span> <span class="n">the</span> <span class="n">command</span> <span class="n">again</span> <span class="n">with</span> <span class="o">--</span><span class="n">verbose</span><span class="err">.</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">Cons</code> variants own the data they hold, so when we create the <code class="language-plaintext highlighter-rouge">b</code> list, <code class="language-plaintext highlighter-rouge">a</code> is moved into <code class="language-plaintext highlighter-rouge">b</code> and <code class="language-plaintext highlighter-rouge">b</code> owns <code class="language-plaintext highlighter-rouge">a</code>. 
Then, when we try to use <code class="language-plaintext highlighter-rouge">a</code> again when creating <code class="language-plaintext highlighter-rouge">c</code>, we’re not allowed to because a has been moved.</p>

<p>We could change the definition of <code class="language-plaintext highlighter-rouge">Cons</code> to hold references instead, but then we would have to specify lifetime parameters. By specifying lifetime parameters, we would be specifying that every element in the list will live at least as long as the entire list. The borrow checker wouldn’t <code class="language-plaintext highlighter-rouge">let us compile let a = Cons(10, &amp;Nil);</code> for example, because the temporary <code class="language-plaintext highlighter-rouge">Nil</code> value would be dropped before <code class="language-plaintext highlighter-rouge">a</code> could take a reference to it.</p>

<p>Instead, we’ll change our definition of <code class="language-plaintext highlighter-rouge">List</code> to use <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> in place of <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code>, as shown in Listing 15-18. 
Each <code class="language-plaintext highlighter-rouge">Cons</code> variant will now hold a value and an <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> pointing to a <code class="language-plaintext highlighter-rouge">List</code>. 
When we create <code class="language-plaintext highlighter-rouge">b</code>, instead of taking ownership of <code class="language-plaintext highlighter-rouge">a</code>, we’ll clone the <code class="language-plaintext highlighter-rouge">Rc&lt;List&gt;</code> that <code class="language-plaintext highlighter-rouge">a</code> is holding, thereby increasing the number of references from one to two and letting <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> share ownership of the data in that <code class="language-plaintext highlighter-rouge">Rc&lt;List&gt;</code>. We’ll also clone a when creating <code class="language-plaintext highlighter-rouge">c</code>, increasing the number of references from two to three. 
Every time we call <code class="language-plaintext highlighter-rouge">Rc::clone</code>, the reference count to the data within the <code class="language-plaintext highlighter-rouge">Rc&lt;List&gt;</code> will increase, and the data won’t be cleaned up unless there are zero references to it.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>
<span class="k">enum</span> <span class="n">List</span> <span class="p">{</span>
    <span class="nf">Cons</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">Rc</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="nb">Nil</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="nn">List</span><span class="p">::{</span><span class="nb">Cons</span><span class="p">,</span> <span class="nb">Nil</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Cons</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Cons</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nb">Nil</span><span class="p">)))));</span>
    <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="nf">Cons</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">));</span>
    <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="nf">Cons</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-18-a-definition-of-list-that-uses-rc">Listing 15-18: A definition of List that uses Rc<T></T></h4>

<p>We need to add a <code class="language-plaintext highlighter-rouge">use</code> statement to bring <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> into scope because it’s not in the prelude. In <code class="language-plaintext highlighter-rouge">main</code>, we create the list holding 5 and 10 and store it in a new <code class="language-plaintext highlighter-rouge">Rc&lt;List&gt;</code> in <code class="language-plaintext highlighter-rouge">a</code>. Then when we create <code class="language-plaintext highlighter-rouge">b</code> and <code class="language-plaintext highlighter-rouge">c</code>, we call the <code class="language-plaintext highlighter-rouge">Rc::clone</code> function and pass a reference to the <code class="language-plaintext highlighter-rouge">Rc&lt;List&gt;</code> in a as an argument.</p>

<p>We could have called <code class="language-plaintext highlighter-rouge">a.clone()</code> rather than <code class="language-plaintext highlighter-rouge">Rc::clone(&amp;a)</code>, but Rust’s convention is to use <code class="language-plaintext highlighter-rouge">Rc::clone</code> in this case. 
The implementation of <code class="language-plaintext highlighter-rouge">Rc::clone</code> doesn’t make a deep copy of all the data like most types’ implementations of <code class="language-plaintext highlighter-rouge">clone</code> do. 
The call to <code class="language-plaintext highlighter-rouge">Rc::clone</code> only increments the reference count, which doesn’t take much time. Deep copies of data can take a lot of time. By using <code class="language-plaintext highlighter-rouge">Rc::clone</code> for reference counting, we can visually distinguish between the deep-copy kinds of clones and the kinds of clones that increase the reference count. When looking for performance problems in the code, we only need to consider the deep-copy clones and can disregard calls to <code class="language-plaintext highlighter-rouge">Rc::clone</code>.</p>

<h3 id="cloning-an-rc-increases-the-reference-count">Cloning an Rc<T> Increases the Reference Count</T></h3>
<p>Let’s change our working example in Listing 15-18 so we can see the reference counts changing as we create and drop references to the <code class="language-plaintext highlighter-rouge">Rc&lt;List&gt;</code> in <code class="language-plaintext highlighter-rouge">a</code>.</p>

<p>In Listing 15-19, we’ll change <code class="language-plaintext highlighter-rouge">main</code> so it has an inner scope around list <code class="language-plaintext highlighter-rouge">c</code>; then we can see how the reference count changes when <code class="language-plaintext highlighter-rouge">c</code> goes out of scope.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Cons</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Cons</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nb">Nil</span><span class="p">)))));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"count after creating a = {}"</span><span class="p">,</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">));</span>
    <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="nf">Cons</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"count after creating b = {}"</span><span class="p">,</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">));</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="nf">Cons</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">));</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"count after creating c = {}"</span><span class="p">,</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"count after c goes out of scope = {}"</span><span class="p">,</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-19-printing-the-reference-count">Listing 15-19: Printing the reference count</h4>

<p>At each point in the program where the reference count changes, we print the reference count, which we can get by calling the <code class="language-plaintext highlighter-rouge">Rc::strong_count</code> function. This function is named <code class="language-plaintext highlighter-rouge">strong_count</code> rather than count because the <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> type also has a <code class="language-plaintext highlighter-rouge">weak_count</code>; we’ll see what <code class="language-plaintext highlighter-rouge">weak_count</code> is used for in the “Preventing Reference Cycles: Turning an <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> into a <code class="language-plaintext highlighter-rouge">Weak&lt;T&gt;</code>” section.</p>

<p>This code prints the following:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="n">cons</span><span class="o">-</span><span class="n">list</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/cons-list)</span>
    <span class="n">Finished</span> <span class="n">dev</span> <span class="p">[</span><span class="n">unoptimized</span> <span class="o">+</span> <span class="n">debuginfo</span><span class="p">]</span> <span class="nf">target</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">in</span> <span class="mf">0.45</span><span class="n">s</span>
     <span class="n">Running</span> <span class="err">`</span><span class="n">target</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">cons</span><span class="o">-</span><span class="n">list</span><span class="err">`</span>
<span class="n">count</span> <span class="n">after</span> <span class="n">creating</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">count</span> <span class="n">after</span> <span class="n">creating</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">count</span> <span class="n">after</span> <span class="n">creating</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">count</span> <span class="n">after</span> <span class="n">c</span> <span class="n">goes</span> <span class="n">out</span> <span class="n">of</span> <span class="n">scope</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div></div>
<p>We can see that the <code class="language-plaintext highlighter-rouge">Rc&lt;List&gt;</code> in <code class="language-plaintext highlighter-rouge">a</code> has an initial reference count of 1; then each time we call <code class="language-plaintext highlighter-rouge">clone</code>, the count goes up by 1. When <code class="language-plaintext highlighter-rouge">c</code> goes out of scope, the count goes down by 1. We don’t have to call a function to decrease the reference count like we have to call <code class="language-plaintext highlighter-rouge">Rc::clone</code> to increase the reference count: the implementation of the <code class="language-plaintext highlighter-rouge">Drop</code> trait decreases the reference count automatically when an <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> value goes out of scope.</p>

<p>What we can’t see in this example is that when <code class="language-plaintext highlighter-rouge">b</code> and then <code class="language-plaintext highlighter-rouge">a</code> go out of scope at the end of <code class="language-plaintext highlighter-rouge">main</code>, the count is then 0, and the <code class="language-plaintext highlighter-rouge">Rc&lt;List&gt;</code> is cleaned up completely at that point. Using <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> allows a single value to have multiple owners, and the count ensures that the value remains valid as long as any of the owners still exist.</p>

<p>Via immutable references, <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> allows you to share data between multiple parts of your program for reading only. If <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> allowed you to have multiple mutable references too, you might violate one of the borrowing rules discussed in Chapter 4: multiple mutable borrows to the same place can cause data races and inconsistencies. But being able to mutate data is very useful! In the next section, we’ll discuss the interior mutability pattern and the <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> type that you can use in conjunction with an <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> to work with this immutability restriction.</p>

<h2 id="refcell-and-the-interior-mutability-pattern">RefCell<T> and the Interior Mutability Pattern</T></h2>
<p><em>Interior mutability</em> is a design pattern in Rust that allows you to mutate data even when there are immutable references to that data; normally, this action is disallowed by the borrowing rules. To mutate data, the pattern uses <code class="language-plaintext highlighter-rouge">unsafe</code> code inside a data structure to bend Rust’s usual rules that govern mutation and borrowing. We haven’t yet covered unsafe code; we will in Chapter 19. We can use types that use the interior mutability pattern when we can ensure that the borrowing rules will be followed at runtime, even though the compiler can’t guarantee that. The <code class="language-plaintext highlighter-rouge">unsafe</code> code involved is then wrapped in a safe API, and the outer type is still immutable.</p>

<p>Let’s explore this concept by looking at the <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> type that follows the interior mutability pattern.</p>

<h3 id="enforcing-borrowing-rules-at-runtime-with-refcell">Enforcing Borrowing Rules at Runtime with RefCell<T></T></h3>
<p>Unlike <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code>, the <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> type represents single ownership over the data it holds. So, what makes <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> different from a type like <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code>? Recall the borrowing rules you learned in Chapter 4:</p>
<ul>
  <li>At any given time, you can have <em>either</em> (but not both of) one mutable reference or any number of immutable references.</li>
  <li>References must always be valid.</li>
</ul>

<p>With references and <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code>, the borrowing rules’ invariants are enforced at compile time. With <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code>, these invariants are enforced at <em>runtime</em>. With references, if you break these rules, you’ll get a compiler error. With <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code>, if you break these rules, your program will panic and exit.</p>

<p>The advantages of checking the borrowing rules at compile time are that errors will be caught sooner in the development process, and there is no impact on runtime performance because all the analysis is completed beforehand. For those reasons, checking the borrowing rules at compile time is the best choice in the majority of cases, which is why this is Rust’s default.</p>

<p>The advantage of checking the borrowing rules at runtime instead is that certain memory-safe scenarios are then allowed, whereas they are disallowed by the compile-time checks. Static analysis, like the Rust compiler, is inherently conservative. Some properties of code are impossible to detect by analyzing the code: the most famous example is the Halting Problem, which is beyond the scope of this book but is an interesting topic to research.</p>

<p>Because some analysis is impossible, if the Rust compiler can’t be sure the code complies with the ownership rules, it might reject a correct program; in this way, it’s conservative. If Rust accepted an incorrect program, users wouldn’t be able to trust in the guarantees Rust makes. However, if Rust rejects a correct program, the programmer will be inconvenienced, but nothing catastrophic can occur. The <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> type is useful when you’re sure your code follows the borrowing rules but the compiler is unable to understand and guarantee that.</p>

<p>Similar to <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code>, <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> is only for use in single-threaded scenarios and will give you a compile-time error if you try using it in a multithreaded context. We’ll talk about how to get the functionality of <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> in a multithreaded program in Chapter 16.</p>

<p>Here is a recap of the reasons to choose <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code>, <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code>, or <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> enables multiple owners of the same data; <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> and <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> have single owners.</li>
  <li><code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> allows immutable or mutable borrows checked at compile time; <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> allows only immutable borrows checked at compile time; <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> allows immutable or mutable borrows checked at runtime.</li>
  <li>Because <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> allows mutable borrows checked at runtime, you can mutate the value inside the <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> even when the <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> is immutable.</li>
</ul>

<p>Mutating the value inside an immutable value is the <em>interior mutability</em> pattern. Let’s look at a situation in which interior mutability is useful and examine how it’s possible.</p>

<h3 id="interior-mutability-a-mutable-borrow-to-an-immutable-value">Interior Mutability: A Mutable Borrow to an Immutable Value</h3>
<p>A consequence of the borrowing rules is that when you have an immutable value, you can’t borrow it mutably. For example, this code won’t compile:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>If you tried to compile this code, you’d get the following error:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="n">borrowing</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/borrowing)</span>
<span class="n">error</span><span class="p">[</span><span class="n">E0596</span><span class="p">]:</span> <span class="n">cannot</span> <span class="n">borrow</span> <span class="err">`</span><span class="n">x</span><span class="err">`</span> <span class="k">as</span> <span class="n">mutable</span><span class="p">,</span> <span class="k">as</span> <span class="n">it</span> <span class="n">is</span> <span class="n">not</span> <span class="n">declared</span> <span class="k">as</span> <span class="n">mutable</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="mi">13</span>
  <span class="p">|</span>
<span class="mi">2</span> <span class="p">|</span>     <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="p">|</span>         <span class="o">-</span> <span class="n">help</span><span class="p">:</span> <span class="n">consider</span> <span class="n">changing</span> <span class="n">this</span> <span class="n">to</span> <span class="n">be</span> <span class="n">mutable</span><span class="p">:</span> <span class="err">`</span><span class="k">mut</span> <span class="n">x</span><span class="err">`</span>
<span class="mi">3</span> <span class="p">|</span>     <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">|</span>             <span class="o">^^^^^^</span> <span class="n">cannot</span> <span class="n">borrow</span> <span class="k">as</span> <span class="n">mutable</span>

<span class="n">error</span><span class="p">:</span> <span class="n">aborting</span> <span class="n">due</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">error</span>

<span class="n">For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">about</span> <span class="n">this</span> <span class="n">error</span><span class="p">,</span> <span class="k">try</span> <span class="err">`</span><span class="n">rustc</span> <span class="o">--</span><span class="n">explain</span> <span class="n">E0596</span><span class="err">`</span><span class="py">.
error</span><span class="p">:</span> <span class="n">could</span> <span class="n">not</span> <span class="n">compile</span> <span class="err">`</span><span class="n">borrowing</span><span class="err">`</span><span class="py">.

To</span> <span class="n">learn</span> <span class="n">more</span><span class="p">,</span> <span class="n">run</span> <span class="n">the</span> <span class="n">command</span> <span class="n">again</span> <span class="n">with</span> <span class="o">--</span><span class="n">verbose</span><span class="err">.</span>
</code></pre></div></div>
<p>However, there are situations in which it would be useful for a value to mutate itself in its methods but appear immutable to other code. Code outside the value’s methods would not be able to mutate the value. Using <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> is one way to get the ability to have interior mutability. But <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> doesn’t get around the borrowing rules completely: the borrow checker in the compiler allows this interior mutability, and the borrowing rules are checked at runtime instead. If you violate the rules, you’ll get a <code class="language-plaintext highlighter-rouge">panic!</code> instead of a compiler error.</p>

<p>Let’s work through a practical example where we can use <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> to mutate an immutable value and see why that is useful.</p>

<h3 id="a-use-case-for-interior-mutability-mock-objects">A Use Case for Interior Mutability: Mock Objects</h3>
<p>A <em>test double</em> is the general programming concept for a type used in place of another type during testing. <em>Mock objects</em> are specific types of test doubles that record what happens during a test so you can assert that the correct actions took place.</p>

<p>Rust doesn’t have objects in the same sense as other languages have objects, and Rust doesn’t have mock object functionality built into the standard library as some other languages do. However, you can definitely create a struct that will serve the same purposes as a mock object.</p>

<p>Here’s the scenario we’ll test: we’ll create a library that tracks a value against a maximum value and sends messages based on how close to the maximum value the current value is. This library could be used to keep track of a user’s quota for the number of API calls they’re allowed to make, for example.</p>

<p>Our library will only provide the functionality of tracking how close to the maximum a value is and what the messages should be at what times. Applications that use our library will be expected to provide the mechanism for sending the messages: the application could put a message in the application, send an email, send a text message, or something else. The library doesn’t need to know that detail. All it needs is something that implements a trait we’ll provide called <code class="language-plaintext highlighter-rouge">Messenger</code>. Listing 15-20 shows the library code:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>
<span class="k">pub</span> <span class="k">trait</span> <span class="n">Messenger</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">send</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">LimitTracker</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">Messenger</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">messenger</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">,</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">max</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">LimitTracker</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="n">Messenger</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">messenger</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">max</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">LimitTracker</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">LimitTracker</span> <span class="p">{</span>
            <span class="n">messenger</span><span class="p">,</span>
            <span class="n">value</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">max</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">set_value</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">percentage_of_max</span> <span class="o">=</span> <span class="k">self</span><span class="py">.value</span> <span class="k">as</span> <span class="nb">f64</span> <span class="o">/</span> <span class="k">self</span><span class="py">.max</span> <span class="k">as</span> <span class="nb">f64</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">percentage_of_max</span> <span class="o">&gt;=</span> <span class="mf">1.0</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.messenger</span><span class="nf">.send</span><span class="p">(</span><span class="s">"Error: You are over your quota!"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">percentage_of_max</span> <span class="o">&gt;=</span> <span class="mf">0.9</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.messenger</span>
                <span class="nf">.send</span><span class="p">(</span><span class="s">"Urgent warning: You've used up over 90% of your quota!"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">percentage_of_max</span> <span class="o">&gt;=</span> <span class="mf">0.75</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.messenger</span>
                <span class="nf">.send</span><span class="p">(</span><span class="s">"Warning: You've used up over 75% of your quota!"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-20-a-library-to-keep-track-of-how-close-a-value-is-to-a-maximum-value-and-warn-when-the-value-is-at-certain-levels">Listing 15-20: A library to keep track of how close a value is to a maximum value and warn when the value is at certain levels</h4>

<p>One important part of this code is that the <code class="language-plaintext highlighter-rouge">Messenger</code> trait has one method called <code class="language-plaintext highlighter-rouge">send</code> that takes an immutable reference to <code class="language-plaintext highlighter-rouge">self</code> and the text of the message. This is the interface our mock object needs to have. The other important part is that we want to test the behavior of the <code class="language-plaintext highlighter-rouge">set_value</code> method on the <code class="language-plaintext highlighter-rouge">LimitTracker</code>. We can change what we pass in for the <code class="language-plaintext highlighter-rouge">value</code> parameter, but <code class="language-plaintext highlighter-rouge">set_value</code> doesn’t return anything for us to make assertions on. We want to be able to say that if we create a <code class="language-plaintext highlighter-rouge">LimitTracker</code> with something that implements the <code class="language-plaintext highlighter-rouge">Messenger</code> trait and a particular value for <code class="language-plaintext highlighter-rouge">max</code>, when we pass different numbers for <code class="language-plaintext highlighter-rouge">value</code>, the messenger is told to send the appropriate messages.</p>

<p>We need a mock object that, instead of sending an email or text message when we call <code class="language-plaintext highlighter-rouge">send</code>, will only keep track of the messages it’s told to send. We can create a new instance of the mock object, create a <code class="language-plaintext highlighter-rouge">LimitTracker</code> that uses the mock object, call the <code class="language-plaintext highlighter-rouge">set_value</code> method on <code class="language-plaintext highlighter-rouge">LimitTracker</code>, and then check that the mock object has the messages we expect. Listing 15-21 shows an attempt to implement a mock object to do just that, but the borrow checker won’t allow it:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>
<span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">MockMessenger</span> <span class="p">{</span>
        <span class="n">sent_messages</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">impl</span> <span class="n">MockMessenger</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">MockMessenger</span> <span class="p">{</span>
            <span class="n">MockMessenger</span> <span class="p">{</span>
                <span class="n">sent_messages</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[],</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">impl</span> <span class="n">Messenger</span> <span class="k">for</span> <span class="n">MockMessenger</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">send</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.sent_messages</span><span class="nf">.push</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">message</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">it_sends_an_over_75_percent_warning_message</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">mock_messenger</span> <span class="o">=</span> <span class="nn">MockMessenger</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">limit_tracker</span> <span class="o">=</span> <span class="nn">LimitTracker</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mock_messenger</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>

        <span class="n">limit_tracker</span><span class="nf">.set_value</span><span class="p">(</span><span class="mi">80</span><span class="p">);</span>

        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">mock_messenger</span><span class="py">.sent_messages</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-21-an-attempt-to-implement-a-mockmessenger-that-isnt-allowed-by-the-borrow-checker">Listing 15-21: An attempt to implement a MockMessenger that isn’t allowed by the borrow checker</h4>

<p>This test code defines a <code class="language-plaintext highlighter-rouge">MockMessenger</code> struct that has a <code class="language-plaintext highlighter-rouge">sent_messages</code> field with a <code class="language-plaintext highlighter-rouge">Vec</code> of <code class="language-plaintext highlighter-rouge">String</code> values to keep track of the messages it’s told to send. We also define an associated function new to make it convenient to create new <code class="language-plaintext highlighter-rouge">MockMessenger</code> values that start with an empty list of messages. We then implement the <code class="language-plaintext highlighter-rouge">Messenger</code> trait for <code class="language-plaintext highlighter-rouge">MockMessenger</code> so we can give a <code class="language-plaintext highlighter-rouge">MockMessenger</code> to a <code class="language-plaintext highlighter-rouge">LimitTracker</code>. In the definition of the <code class="language-plaintext highlighter-rouge">send</code> method, we take the message passed in as a parameter and store it in the <code class="language-plaintext highlighter-rouge">MockMessenger</code> list of <code class="language-plaintext highlighter-rouge">sent_messages</code>.</p>

<p>In the test, we’re testing what happens when the <code class="language-plaintext highlighter-rouge">LimitTracker</code> is told to set <code class="language-plaintext highlighter-rouge">value</code> to something that is more than 75 percent of the <code class="language-plaintext highlighter-rouge">max</code> value. First, we create a new <code class="language-plaintext highlighter-rouge">MockMessenger</code>, which will start with an empty list of messages. Then we create a new <code class="language-plaintext highlighter-rouge">LimitTracker</code> and give it a reference to the new <code class="language-plaintext highlighter-rouge">MockMessenger</code> and a <code class="language-plaintext highlighter-rouge">max</code> value of 100. We call the <code class="language-plaintext highlighter-rouge">set_value</code> method on the <code class="language-plaintext highlighter-rouge">LimitTracker</code> with a value of 80, which is more than 75 percent of 100. Then we assert that the list of messages that the <code class="language-plaintext highlighter-rouge">MockMessenger</code> is keeping track of should now have one message in it.</p>

<p>However, there’s one problem with this test, as shown here:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">test</span>
   <span class="n">Compiling</span> <span class="n">limit</span><span class="o">-</span><span class="n">tracker</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/limit-tracker)</span>
<span class="n">error</span><span class="p">[</span><span class="n">E0596</span><span class="p">]:</span> <span class="n">cannot</span> <span class="n">borrow</span> <span class="err">`</span><span class="k">self</span><span class="py">.sent_messages</span><span class="err">`</span> <span class="k">as</span> <span class="n">mutable</span><span class="p">,</span> <span class="k">as</span> <span class="n">it</span> <span class="n">is</span> <span class="n">behind</span> <span class="n">a</span> <span class="err">`</span><span class="o">&amp;</span><span class="err">`</span> <span class="n">reference</span>
  <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">lib</span><span class="py">.rs</span><span class="p">:</span><span class="mi">58</span><span class="p">:</span><span class="mi">13</span>
   <span class="p">|</span>
<span class="mi">57</span> <span class="p">|</span>         <span class="k">fn</span> <span class="nf">send</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
   <span class="p">|</span>                 <span class="o">-----</span> <span class="n">help</span><span class="p">:</span> <span class="n">consider</span> <span class="n">changing</span> <span class="n">this</span> <span class="n">to</span> <span class="n">be</span> <span class="n">a</span> <span class="n">mutable</span> <span class="n">reference</span><span class="p">:</span> <span class="err">`</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="err">`</span>
<span class="mi">58</span> <span class="p">|</span>             <span class="k">self</span><span class="py">.sent_messages</span><span class="nf">.push</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">message</span><span class="p">));</span>
   <span class="p">|</span>             <span class="o">^^^^^^^^^^^^^^^^^^</span> <span class="err">`</span><span class="k">self</span><span class="err">`</span> <span class="n">is</span> <span class="n">a</span> <span class="err">`</span><span class="o">&amp;</span><span class="err">`</span> <span class="n">reference</span><span class="p">,</span> <span class="n">so</span> <span class="n">the</span> <span class="n">data</span> <span class="n">it</span> <span class="n">refers</span> <span class="n">to</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">borrowed</span> <span class="k">as</span> <span class="n">mutable</span>

<span class="n">error</span><span class="p">:</span> <span class="n">aborting</span> <span class="n">due</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">error</span>

<span class="n">For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">about</span> <span class="n">this</span> <span class="n">error</span><span class="p">,</span> <span class="k">try</span> <span class="err">`</span><span class="n">rustc</span> <span class="o">--</span><span class="n">explain</span> <span class="n">E0596</span><span class="err">`</span><span class="py">.
error</span><span class="p">:</span> <span class="n">could</span> <span class="n">not</span> <span class="n">compile</span> <span class="err">`</span><span class="n">limit</span><span class="o">-</span><span class="n">tracker</span><span class="err">`</span><span class="py">.

To</span> <span class="n">learn</span> <span class="n">more</span><span class="p">,</span> <span class="n">run</span> <span class="n">the</span> <span class="n">command</span> <span class="n">again</span> <span class="n">with</span> <span class="o">--</span><span class="n">verbose</span><span class="err">.</span>
</code></pre></div></div>

<p>We can’t modify the <code class="language-plaintext highlighter-rouge">MockMessenger</code> to keep track of the messages, because the <code class="language-plaintext highlighter-rouge">send</code> method takes an immutable reference to <code class="language-plaintext highlighter-rouge">self</code>. We also can’t take the suggestion from the error text to use <code class="language-plaintext highlighter-rouge">&amp;mut self</code> instead, because then the signature of <code class="language-plaintext highlighter-rouge">send</code> wouldn’t match the signature in the <code class="language-plaintext highlighter-rouge">Messenger</code> trait definition (feel free to try and see what error message you get).</p>

<p>This is a situation in which interior mutability can help! We’ll store the <code class="language-plaintext highlighter-rouge">sent_messages</code> within a <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code>, and then the <code class="language-plaintext highlighter-rouge">send</code> message will be able to modify <code class="language-plaintext highlighter-rouge">sent_messages</code> to store the messages we’ve seen. Listing 15-22 shows what that looks like:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>

<span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">MockMessenger</span> <span class="p">{</span>
        <span class="n">sent_messages</span><span class="p">:</span> <span class="n">RefCell</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">impl</span> <span class="n">MockMessenger</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">MockMessenger</span> <span class="p">{</span>
            <span class="n">MockMessenger</span> <span class="p">{</span>
                <span class="n">sent_messages</span><span class="p">:</span> <span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[]),</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">impl</span> <span class="n">Messenger</span> <span class="k">for</span> <span class="n">MockMessenger</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">send</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.sent_messages</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="nf">.push</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">message</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">it_sends_an_over_75_percent_warning_message</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// --snip--</span>

        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">mock_messenger</span><span class="py">.sent_messages</span><span class="nf">.borrow</span><span class="p">()</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-22-using-refcell-to-mutate-an-inner-value-while-the-outer-value-is-considered-immutable">Listing 15-22: Using RefCell<T> to mutate an inner value while the outer value is considered immutable</T></h4>

<p>The <code class="language-plaintext highlighter-rouge">sent_messages</code> field is now of type <code class="language-plaintext highlighter-rouge">RefCell&lt;Vec&lt;String&gt;&gt;</code> instead of <code class="language-plaintext highlighter-rouge">Vec&lt;String&gt;</code>. In the new function, we create a new <code class="language-plaintext highlighter-rouge">RefCell&lt;Vec&lt;String&gt;&gt;</code> instance around the empty vector.</p>

<p>For the implementation of the <code class="language-plaintext highlighter-rouge">send</code> method, the first parameter is still an immutable borrow of <code class="language-plaintext highlighter-rouge">self</code>, which matches the trait definition. We call <code class="language-plaintext highlighter-rouge">borrow_mut</code> on the <code class="language-plaintext highlighter-rouge">RefCell&lt;Vec&lt;String&gt;&gt;</code> in <code class="language-plaintext highlighter-rouge">self.sent_messages</code> to get a mutable reference to the value inside the <code class="language-plaintext highlighter-rouge">RefCell&lt;Vec&lt;String&gt;&gt;</code>, which is the vector. Then we can call <code class="language-plaintext highlighter-rouge">push</code> on the mutable reference to the vector to keep track of the messages sent during the test.</p>

<p>The last change we have to make is in the assertion: to see how many items are in the inner vector, we call <code class="language-plaintext highlighter-rouge">borrow</code> on the <code class="language-plaintext highlighter-rouge">RefCell&lt;Vec&lt;String&gt;&gt;</code> to get an immutable reference to the vector.</p>

<p>Now that you’ve seen how to use <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code>, let’s dig into how it works!</p>

<h3 id="keeping-track-of-borrows-at-runtime-with-refcell">Keeping Track of Borrows at Runtime with RefCell<T></T></h3>
<p>When creating immutable and mutable references, we use the <code class="language-plaintext highlighter-rouge">&amp;</code> and <code class="language-plaintext highlighter-rouge">&amp;mut</code> syntax, respectively. With <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code>, we use the <code class="language-plaintext highlighter-rouge">borrow</code> and <code class="language-plaintext highlighter-rouge">borrow_mut</code> methods, which are part of the safe API that belongs to <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code>. The <code class="language-plaintext highlighter-rouge">borrow</code> method returns the smart pointer type <code class="language-plaintext highlighter-rouge">Ref&lt;T&gt;</code>, and <code class="language-plaintext highlighter-rouge">borrow_mut</code> returns the smart pointer type <code class="language-plaintext highlighter-rouge">RefMut&lt;T&gt;</code>. Both types implement <code class="language-plaintext highlighter-rouge">Deref</code>, so we can treat them like regular references.</p>

<p>The <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> keeps track of how many <code class="language-plaintext highlighter-rouge">Ref&lt;T&gt;</code> and <code class="language-plaintext highlighter-rouge">RefMut&lt;T&gt;</code> smart pointers are currently active. Every time we call <code class="language-plaintext highlighter-rouge">borrow</code>, the <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> increases its count of how many immutable borrows are active. When a <code class="language-plaintext highlighter-rouge">Ref&lt;T&gt;</code> value goes out of scope, the count of immutable borrows goes down by one. Just like the compile-time borrowing rules, <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> lets us have many immutable borrows or one mutable borrow at any point in time.</p>

<p>If we try to violate these rules, rather than getting a compiler error as we would with references, the implementation of <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> will panic at runtime. Listing 15-23 shows a modification of the implementation of <code class="language-plaintext highlighter-rouge">send</code> in Listing 15-22. We’re deliberately trying to create two mutable borrows active for the same scope to illustrate that <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> prevents us from doing this at runtime.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>
    <span class="k">impl</span> <span class="n">Messenger</span> <span class="k">for</span> <span class="n">MockMessenger</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">send</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">one_borrow</span> <span class="o">=</span> <span class="k">self</span><span class="py">.sent_messages</span><span class="nf">.borrow_mut</span><span class="p">();</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">two_borrow</span> <span class="o">=</span> <span class="k">self</span><span class="py">.sent_messages</span><span class="nf">.borrow_mut</span><span class="p">();</span>

            <span class="n">one_borrow</span><span class="nf">.push</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">message</span><span class="p">));</span>
            <span class="n">two_borrow</span><span class="nf">.push</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">message</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-23-creating-two-mutable-references-in-the-same-scope-to-see-that-refcell-will-panic">Listing 15-23: Creating two mutable references in the same scope to see that RefCell<T> will panic</T></h4>

<p>We create a variable <code class="language-plaintext highlighter-rouge">one_borrow</code> for the <code class="language-plaintext highlighter-rouge">RefMut&lt;T&gt;</code> smart pointer returned from <code class="language-plaintext highlighter-rouge">borrow_mut</code>. Then we create another mutable borrow in the same way in the variable <code class="language-plaintext highlighter-rouge">two_borrow</code>. This makes two mutable references in the same scope, which isn’t allowed. When we run the tests for our library, the code in Listing 15-23 will compile without any errors, but the test will fail:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">test</span>
   <span class="n">Compiling</span> <span class="n">limit</span><span class="o">-</span><span class="n">tracker</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/limit-tracker)</span>
    <span class="n">Finished</span> <span class="n">test</span> <span class="p">[</span><span class="n">unoptimized</span> <span class="o">+</span> <span class="n">debuginfo</span><span class="p">]</span> <span class="nf">target</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">in</span> <span class="mf">0.91</span><span class="n">s</span>
     <span class="n">Running</span> <span class="n">target</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">deps</span><span class="o">/</span><span class="n">limit_tracker</span><span class="o">-</span><span class="n">d1b2637139dca6ca</span>

<span class="n">running</span> <span class="mi">1</span> <span class="n">test</span>
<span class="n">test</span> <span class="nn">tests</span><span class="p">::</span><span class="n">it_sends_an_over_75_percent_warning_message</span> <span class="o">...</span> <span class="n">FAILED</span>

<span class="n">failures</span><span class="p">:</span>

<span class="o">----</span> <span class="nn">tests</span><span class="p">::</span><span class="n">it_sends_an_over_75_percent_warning_message</span> <span class="n">stdout</span> <span class="o">----</span>
<span class="n">thread</span> <span class="nv">'main</span><span class="err">'</span> <span class="n">panicked</span> <span class="n">at</span> <span class="nv">'already</span> <span class="n">borrowed</span><span class="p">:</span> <span class="n">BorrowMutError</span><span class="err">'</span><span class="p">,</span> <span class="n">src</span><span class="o">/</span><span class="n">libcore</span><span class="o">/</span><span class="n">result</span><span class="py">.rs</span><span class="p">:</span><span class="mi">1188</span><span class="p">:</span><span class="mi">5</span>
<span class="n">note</span><span class="p">:</span> <span class="n">run</span> <span class="n">with</span> <span class="err">`</span><span class="n">RUST_BACKTRACE</span><span class="o">=</span><span class="mi">1</span><span class="err">`</span> <span class="n">environment</span> <span class="n">variable</span> <span class="n">to</span> <span class="n">display</span> <span class="n">a</span> <span class="n">backtrace</span><span class="py">.


failures</span><span class="p">:</span>
    <span class="nn">tests</span><span class="p">::</span><span class="n">it_sends_an_over_75_percent_warning_message</span>

<span class="n">test</span> <span class="n">result</span><span class="p">:</span> <span class="n">FAILED</span><span class="na">. 0</span> <span class="n">passed</span><span class="p">;</span> <span class="mi">1</span> <span class="n">failed</span><span class="p">;</span> <span class="mi">0</span> <span class="n">ignored</span><span class="p">;</span> <span class="mi">0</span> <span class="n">measured</span><span class="p">;</span> <span class="mi">0</span> <span class="n">filtered</span> <span class="n">out</span>

<span class="n">error</span><span class="p">:</span> <span class="n">test</span> <span class="n">failed</span><span class="p">,</span> <span class="n">to</span> <span class="n">rerun</span> <span class="n">pass</span> <span class="err">'</span><span class="o">--</span><span class="n">lib</span><span class="err">'</span>
</code></pre></div></div>
<p>Notice that the code panicked with the message <code class="language-plaintext highlighter-rouge">already borrowed: BorrowMutError</code>. This is how <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> handles violations of the borrowing rules at runtime.</p>

<p>Catching borrowing errors at runtime rather than compile time means that you would find a mistake in your code later in the development process and possibly not until your code was deployed to production. Also, your code would incur a small runtime performance penalty as a result of keeping track of the borrows at runtime rather than compile time. However, using <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> makes it possible to write a mock object that can modify itself to keep track of the messages it has seen while you’re using it in a context where only immutable values are allowed. You can use <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> despite its trade-offs to get more functionality than regular references provide.</p>

<h3 id="having-multiple-owners-of-mutable-data-by-combining-rc-and-refcell">Having Multiple Owners of Mutable Data by Combining Rc<T> and RefCell<T></T></T></h3>
<p>A common way to use <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> is in combination with <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code>. Recall that <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> lets you have multiple owners of some data, but it only gives immutable access to that data. If you have an <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> that holds a <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code>, you can get a value that can have multiple owners <em>and</em> that you can mutate!</p>

<p>For example, recall the cons list example in Listing 15-18 where we used <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> to allow multiple lists to share ownership of another list. Because <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> holds only immutable values, we can’t change any of the values in the list once we’ve created them. Let’s add in <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> to gain the ability to change the values in the lists. Listing 15-24 shows that by using a <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> in the Cons definition, we can modify the value stored in all the lists:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>
<span class="nd">#[derive(Debug)]</span>
<span class="k">enum</span> <span class="n">List</span> <span class="p">{</span>
    <span class="nf">Cons</span><span class="p">(</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="nb">Rc</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="nb">Nil</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="nn">List</span><span class="p">::{</span><span class="nb">Cons</span><span class="p">,</span> <span class="nb">Nil</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>

    <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Cons</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">),</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nb">Nil</span><span class="p">)));</span>

    <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="nf">Cons</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">6</span><span class="p">)),</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">));</span>
    <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="nf">Cons</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">10</span><span class="p">)),</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">));</span>

    <span class="o">*</span><span class="n">value</span><span class="nf">.borrow_mut</span><span class="p">()</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"a after = {:?}"</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"b after = {:?}"</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"c after = {:?}"</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-24-using-rcrefcell-to-create-a-list-that-we-can-mutate">Listing 15-24: Using Rc&lt;RefCell<i32>&gt; to create a List that we can mutate</i32></h4>

<p>We create a value that is an instance of <code class="language-plaintext highlighter-rouge">Rc&lt;RefCell&lt;i32&gt;&gt;</code> and store it in a variable named value so we can access it directly later. Then we create a <code class="language-plaintext highlighter-rouge">List</code> in <code class="language-plaintext highlighter-rouge">a</code> with a <code class="language-plaintext highlighter-rouge">Cons</code> variant that holds <code class="language-plaintext highlighter-rouge">value</code>. We need to clone <code class="language-plaintext highlighter-rouge">value</code> so both <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">value</code> have ownership of the inner <code class="language-plaintext highlighter-rouge">5</code> value rather than transferring ownership from <code class="language-plaintext highlighter-rouge">value</code> to <code class="language-plaintext highlighter-rouge">a</code> or having <code class="language-plaintext highlighter-rouge">a</code> borrow from <code class="language-plaintext highlighter-rouge">value</code>.</p>

<p>We wrap the list <code class="language-plaintext highlighter-rouge">a</code> in an <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> so when we create lists <code class="language-plaintext highlighter-rouge">b</code> and <code class="language-plaintext highlighter-rouge">c</code>, they can both refer to <code class="language-plaintext highlighter-rouge">a</code>, which is what we did in Listing 15-18.</p>

<p>After we’ve created the lists in <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, and <code class="language-plaintext highlighter-rouge">c</code>, we add 10 to the value in <code class="language-plaintext highlighter-rouge">value</code>. We do this by calling <code class="language-plaintext highlighter-rouge">borrow_mut</code> on <code class="language-plaintext highlighter-rouge">value</code>, which uses the automatic dereferencing feature we discussed in Chapter 5 (see the section “Where’s the -&gt; Operator?”) to dereference the <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> to the inner <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> value. The <code class="language-plaintext highlighter-rouge">borrow_mut</code> method returns a <code class="language-plaintext highlighter-rouge">RefMut&lt;T&gt;</code> smart pointer, and we use the dereference operator on it and change the inner value.</p>

<p>When we print <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, and <code class="language-plaintext highlighter-rouge">c</code>, we can see that they all have the modified value of 15 rather than 5:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="n">cons</span><span class="o">-</span><span class="n">list</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/cons-list)</span>
    <span class="n">Finished</span> <span class="n">dev</span> <span class="p">[</span><span class="n">unoptimized</span> <span class="o">+</span> <span class="n">debuginfo</span><span class="p">]</span> <span class="nf">target</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">in</span> <span class="mf">0.63</span><span class="n">s</span>
     <span class="n">Running</span> <span class="err">`</span><span class="n">target</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">cons</span><span class="o">-</span><span class="n">list</span><span class="err">`</span>
<span class="n">a</span> <span class="n">after</span> <span class="o">=</span> <span class="nf">Cons</span><span class="p">(</span><span class="n">RefCell</span> <span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="mi">15</span> <span class="p">},</span> <span class="nb">Nil</span><span class="p">)</span>
<span class="n">b</span> <span class="n">after</span> <span class="o">=</span> <span class="nf">Cons</span><span class="p">(</span><span class="n">RefCell</span> <span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="mi">6</span> <span class="p">},</span> <span class="nf">Cons</span><span class="p">(</span><span class="n">RefCell</span> <span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="mi">15</span> <span class="p">},</span> <span class="nb">Nil</span><span class="p">))</span>
<span class="n">c</span> <span class="n">after</span> <span class="o">=</span> <span class="nf">Cons</span><span class="p">(</span><span class="n">RefCell</span> <span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="mi">10</span> <span class="p">},</span> <span class="nf">Cons</span><span class="p">(</span><span class="n">RefCell</span> <span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="mi">15</span> <span class="p">},</span> <span class="nb">Nil</span><span class="p">))</span>
</code></pre></div></div>
<p>This technique is pretty neat! By using <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code>, we have an outwardly immutable <code class="language-plaintext highlighter-rouge">List</code> value. But we can use the methods on <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> that provide access to its interior mutability so we can modify our data when we need to. The runtime checks of the borrowing rules protect us from data races, and it’s sometimes worth trading a bit of speed for this flexibility in our data structures.</p>

<p>The standard library has other types that provide interior mutability, such as <code class="language-plaintext highlighter-rouge">Cell&lt;T&gt;</code>, which is similar except that instead of giving references to the inner value, the value is copied in and out of the <code class="language-plaintext highlighter-rouge">Cell&lt;T&gt;</code>. There’s also <code class="language-plaintext highlighter-rouge">Mutex&lt;T&gt;</code>, which offers interior mutability that’s safe to use across threads; we’ll discuss its use in Chapter 16. Check out the standard library docs for more details on the differences between these types.</p>

<h2 id="reference-cycles-can-leak-memory">Reference Cycles Can Leak Memory</h2>
<p>Rust’s memory safety guarantees make it difficult, but not impossible, to accidentally create memory that is never cleaned up (known as a <em>memory leak</em>). 
Preventing memory leaks entirely is not one of Rust’s guarantees in the same way that disallowing data races at compile time is, meaning memory leaks are memory safe in Rust. 
We can see that Rust allows memory leaks by using <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> and <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code>: it’s possible to create references where items refer to each other in a cycle. 
This creates memory leaks because the reference count of each item in the cycle will never reach 0, and the values will never be dropped.</p>

<h3 id="creating-a-reference-cycle">Creating a Reference Cycle</h3>
<p>Let’s look at how a reference cycle might happen and how to prevent it, starting with the definition of the <code class="language-plaintext highlighter-rouge">List</code> enum and a <code class="language-plaintext highlighter-rouge">tail</code> method in Listing 15-25:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>
<span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="nn">List</span><span class="p">::{</span><span class="nb">Cons</span><span class="p">,</span> <span class="nb">Nil</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="p">;</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">enum</span> <span class="n">List</span> <span class="p">{</span>
    <span class="nf">Cons</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="n">RefCell</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;&gt;</span><span class="p">),</span>
    <span class="nb">Nil</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">List</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">tail</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="nf">Cons</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="n">item</span><span class="p">),</span>
            <span class="nb">Nil</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{}</span>
</code></pre></div></div>
<h4 id="listing-15-25-a-cons-list-definition-that-holds-a-refcell-so-we-can-modify-what-a-cons-variant-is-referring-to">Listing 15-25: A cons list definition that holds a RefCell<T> so we can modify what a Cons variant is referring to</T></h4>

<p>We’re using another variation of the <code class="language-plaintext highlighter-rouge">List</code> definition from Listing 15-5. 
The second element in the <code class="language-plaintext highlighter-rouge">Cons</code> variant is now <code class="language-plaintext highlighter-rouge">RefCell&lt;Rc&lt;List&gt;&gt;</code>, meaning that instead of having the ability to modify the <code class="language-plaintext highlighter-rouge">i32</code> value as we did in Listing 15-24, we want to modify which <code class="language-plaintext highlighter-rouge">List</code> value a <code class="language-plaintext highlighter-rouge">Cons</code> variant is pointing to. 
We’re also adding a <code class="language-plaintext highlighter-rouge">tail</code> method to make it convenient for us to access the second item if we have a <code class="language-plaintext highlighter-rouge">Cons</code> variant.</p>

<p>In Listing 15-26, we’re adding a <code class="language-plaintext highlighter-rouge">main</code> function that uses the definitions in Listing 15-25. 
This code creates a list in <code class="language-plaintext highlighter-rouge">a</code> and a list in <code class="language-plaintext highlighter-rouge">b</code> that points to the list in <code class="language-plaintext highlighter-rouge">a</code>. 
Then it modifies the list in <code class="language-plaintext highlighter-rouge">a</code> to point to <code class="language-plaintext highlighter-rouge">b</code>, creating a reference cycle. 
There are <code class="language-plaintext highlighter-rouge">println!</code> statements along the way to show what the reference counts are at various points in this process.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Cons</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nb">Nil</span><span class="p">))));</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"a initial rc count = {}"</span><span class="p">,</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"a next item = {:?}"</span><span class="p">,</span> <span class="n">a</span><span class="nf">.tail</span><span class="p">());</span>

    <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Cons</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">))));</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"a rc count after b creation = {}"</span><span class="p">,</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"b initial rc count = {}"</span><span class="p">,</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"b next item = {:?}"</span><span class="p">,</span> <span class="n">b</span><span class="nf">.tail</span><span class="p">());</span>

    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">link</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span><span class="nf">.tail</span><span class="p">()</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">link</span><span class="nf">.borrow_mut</span><span class="p">()</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"b rc count after changing a = {}"</span><span class="p">,</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"a rc count after changing a = {}"</span><span class="p">,</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">));</span>

    <span class="c1">// Uncomment the next line to see that we have a cycle;</span>
    <span class="c1">// it will overflow the stack</span>
    <span class="c1">// println!("a next item = {:?}", a.tail());</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-26-creating-a-reference-cycle-of-two-list-values-pointing-to-each-other">Listing 15-26: Creating a reference cycle of two List values pointing to each other</h4>

<p>We create an <code class="language-plaintext highlighter-rouge">Rc&lt;List&gt;</code> instance holding a <code class="language-plaintext highlighter-rouge">List</code> value in the variable <code class="language-plaintext highlighter-rouge">a</code> with an initial list of <code class="language-plaintext highlighter-rouge">5</code>, <code class="language-plaintext highlighter-rouge">Nil</code>. We then create an <code class="language-plaintext highlighter-rouge">Rc&lt;List&gt;</code> instance holding another <code class="language-plaintext highlighter-rouge">List</code> value in the variable <code class="language-plaintext highlighter-rouge">b</code> that contains the value 10 and points to the list in <code class="language-plaintext highlighter-rouge">a</code>.</p>

<p>We modify <code class="language-plaintext highlighter-rouge">a</code> so it points to <code class="language-plaintext highlighter-rouge">b</code> instead of <code class="language-plaintext highlighter-rouge">Nil</code>, creating a cycle. 
We do that by using the <code class="language-plaintext highlighter-rouge">tail</code> method to get a reference to the <code class="language-plaintext highlighter-rouge">RefCell&lt;Rc&lt;List&gt;&gt;</code> in <code class="language-plaintext highlighter-rouge">a</code>, which we put in the variable <code class="language-plaintext highlighter-rouge">link</code>. 
Then we use the <code class="language-plaintext highlighter-rouge">borrow_mut</code> method on the <code class="language-plaintext highlighter-rouge">RefCell&lt;Rc&lt;List&gt;&gt;</code> to change the value inside from an <code class="language-plaintext highlighter-rouge">Rc&lt;List</code>&gt; that holds a <code class="language-plaintext highlighter-rouge">Nil</code> value to the <code class="language-plaintext highlighter-rouge">Rc&lt;List&gt;</code> in <code class="language-plaintext highlighter-rouge">b</code>.</p>

<p>When we run this code, keeping the last <code class="language-plaintext highlighter-rouge">println!</code> commented out for the moment, we’ll get this output:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="n">cons</span><span class="o">-</span><span class="n">list</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/cons-list)</span>
    <span class="n">Finished</span> <span class="n">dev</span> <span class="p">[</span><span class="n">unoptimized</span> <span class="o">+</span> <span class="n">debuginfo</span><span class="p">]</span> <span class="nf">target</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">in</span> <span class="mf">0.53</span><span class="n">s</span>
     <span class="n">Running</span> <span class="err">`</span><span class="n">target</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">cons</span><span class="o">-</span><span class="n">list</span><span class="err">`</span>
<span class="n">a</span> <span class="n">initial</span> <span class="n">rc</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">a</span> <span class="n">next</span> <span class="n">item</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">RefCell</span> <span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="nb">Nil</span> <span class="p">})</span>
<span class="n">a</span> <span class="n">rc</span> <span class="n">count</span> <span class="n">after</span> <span class="n">b</span> <span class="n">creation</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">b</span> <span class="n">initial</span> <span class="n">rc</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">b</span> <span class="n">next</span> <span class="n">item</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">RefCell</span> <span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="nf">Cons</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">RefCell</span> <span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="nb">Nil</span> <span class="p">})</span> <span class="p">})</span>
<span class="n">b</span> <span class="n">rc</span> <span class="n">count</span> <span class="n">after</span> <span class="n">changing</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">a</span> <span class="n">rc</span> <span class="n">count</span> <span class="n">after</span> <span class="n">changing</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div></div>

<p>The reference count of the <code class="language-plaintext highlighter-rouge">Rc&lt;List&gt;</code> instances in both <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> are 2 after we change the list in <code class="language-plaintext highlighter-rouge">a</code> to point to <code class="language-plaintext highlighter-rouge">b</code>. 
At the end of <code class="language-plaintext highlighter-rouge">main</code>, Rust will try to drop <code class="language-plaintext highlighter-rouge">b</code> first, which will decrease the count of the <code class="language-plaintext highlighter-rouge">Rc&lt;List&gt;</code> instance in <code class="language-plaintext highlighter-rouge">b</code> by 1.</p>

<p>However, because <code class="language-plaintext highlighter-rouge">a</code> is still referencing the <code class="language-plaintext highlighter-rouge">Rc&lt;List&gt;</code> that was in <code class="language-plaintext highlighter-rouge">b</code>, that <code class="language-plaintext highlighter-rouge">Rc&lt;List&gt;</code> has a count of 1 rather than 0, so the memory the <code class="language-plaintext highlighter-rouge">Rc&lt;List&gt;</code> has on the heap won’t be dropped. 
The memory will just sit there with a count of 1, forever. To visualize this reference cycle, we’ve created a diagram in Figure 15-4.</p>

<p><img src="/assets/images/rust/trpl15-04.svg" alt="Figure 15-4" width="40%" height="40%" /></p>
<h4 id="figure-15-4-a-reference-cycle-of-lists-a-and-b-pointing-to-each-other">Figure 15-4: A reference cycle of lists a and b pointing to each other</h4>

<p>If you uncomment the last <code class="language-plaintext highlighter-rouge">println!</code> and run the program, Rust will try to print this cycle with <code class="language-plaintext highlighter-rouge">a</code> pointing to <code class="language-plaintext highlighter-rouge">b</code> pointing to <code class="language-plaintext highlighter-rouge">a</code> and so forth until it overflows the stack.</p>

<p>In this case, right after we create the reference cycle, the program ends. The consequences of this cycle aren’t very dire. However, if a more complex program allocated lots of memory in a cycle and held onto it for a long time, the program would use more memory than it needed and might overwhelm the system, causing it to run out of available memory.</p>

<p>Creating reference cycles is not easily done, but it’s not impossible either. If you have <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> values that contain <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> values or similar nested combinations of types with interior mutability and reference counting, you must ensure that you don’t create cycles; you can’t rely on Rust to catch them. Creating a reference cycle would be a logic bug in your program that you should use automated tests, code reviews, and other software development practices to minimize.</p>

<p>Another solution for avoiding reference cycles is reorganizing your data structures so that some references express ownership and some references don’t. As a result, you can have cycles made up of some ownership relationships and some non-ownership relationships, and only the ownership relationships affect whether or not a value can be dropped. In Listing 15-25, we always want <code class="language-plaintext highlighter-rouge">Cons</code> variants to own their list, so reorganizing the data structure isn’t possible. Let’s look at an example using graphs made up of parent nodes and child nodes to see when non-ownership relationships are an appropriate way to prevent reference cycles.</p>

<h3 id="preventing-reference-cycles-turning-an-rc-into-a-weak">Preventing Reference Cycles: Turning an Rc<T> into a Weak<T></T></T></h3>
<p>So far, we’ve demonstrated that calling <code class="language-plaintext highlighter-rouge">Rc::clone</code> increases the <code class="language-plaintext highlighter-rouge">strong_count</code> of an <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> instance, and an <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> instance is only cleaned up if its <code class="language-plaintext highlighter-rouge">strong_count</code> is 0. 
You can also create a <em>weak reference</em> to the value within an <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> instance by calling <code class="language-plaintext highlighter-rouge">Rc::downgrade</code> and passing a reference to the <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code>. 
When you call <code class="language-plaintext highlighter-rouge">Rc::downgrade</code>, you get a smart pointer of type <code class="language-plaintext highlighter-rouge">Weak&lt;T&gt;</code>. 
Instead of increasing the <code class="language-plaintext highlighter-rouge">strong_count</code> in the <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> instance by 1, calling <code class="language-plaintext highlighter-rouge">Rc::downgrade</code> increases the <code class="language-plaintext highlighter-rouge">weak_count</code> by 1. 
The <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> type uses <code class="language-plaintext highlighter-rouge">weak_count</code> to keep track of how many <code class="language-plaintext highlighter-rouge">Weak&lt;T&gt;</code> references exist, similar to <code class="language-plaintext highlighter-rouge">strong_count</code>. 
The difference is the <code class="language-plaintext highlighter-rouge">weak_count</code> doesn’t need to be 0 for the <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> instance to be cleaned up.</p>

<p>Strong references are how you can share ownership of an <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> instance. 
Weak references don’t express an ownership relationship. 
They won’t cause a reference cycle because any cycle involving some weak references will be broken once the strong reference count of values involved is 0.</p>

<p>Because the value that <code class="language-plaintext highlighter-rouge">Weak&lt;T&gt;</code> references might have been dropped, to do anything with the value that a <code class="language-plaintext highlighter-rouge">Weak&lt;T&gt;</code> is pointing to, you must make sure the value still exists. 
Do this by calling the <code class="language-plaintext highlighter-rouge">upgrade</code> method on a <code class="language-plaintext highlighter-rouge">Weak&lt;T&gt;</code> instance, which will return an <code class="language-plaintext highlighter-rouge">Option&lt;Rc&lt;T&gt;&gt;</code>. 
You’ll get a result of <code class="language-plaintext highlighter-rouge">Some</code> if the <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> value has not been dropped yet and a result of <code class="language-plaintext highlighter-rouge">None</code> if the <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> value has been dropped. 
Because <code class="language-plaintext highlighter-rouge">upgrade</code> returns an <code class="language-plaintext highlighter-rouge">Option&lt;Rc&lt;T&gt;&gt;</code>, Rust will ensure that the <code class="language-plaintext highlighter-rouge">Some</code> case and the <code class="language-plaintext highlighter-rouge">None</code> case are handled, and there won’t be an invalid pointer.</p>

<p>As an example, rather than using a list whose items know only about the next item, we’ll create a tree whose items know about their children items <em>and</em> their parent items.</p>

<h3 id="creating-a-tree-data-structure-a-node-with-child-nodes">Creating a Tree Data Structure: a Node with Child Nodes</h3>
<p>To start, we’ll build a tree with nodes that know about their child nodes. We’ll create a struct named <code class="language-plaintext highlighter-rouge">Node</code> that holds its own <code class="language-plaintext highlighter-rouge">i32</code> value as well as references to its children <code class="language-plaintext highlighter-rouge">Node</code> values:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="p">;</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">children</span><span class="p">:</span> <span class="n">RefCell</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>
<p>We want a <code class="language-plaintext highlighter-rouge">Node</code> to own its children, and we want to share that ownership with variables so we can access each <code class="language-plaintext highlighter-rouge">Node</code> in the tree directly. 
To do this, we define the <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code> items to be values of type <code class="language-plaintext highlighter-rouge">Rc&lt;Node&gt;</code>. 
We also want to modify which nodes are children of another node, so we have a <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> in <code class="language-plaintext highlighter-rouge">children</code> around the <code class="language-plaintext highlighter-rouge">Vec&lt;Rc&lt;Node&gt;&gt;</code>.</p>

<p>Next, we’ll use our struct definition and create one <code class="language-plaintext highlighter-rouge">Node</code> instance named <code class="language-plaintext highlighter-rouge">leaf</code> with the value 3 and no children, and another instance named <code class="language-plaintext highlighter-rouge">branch</code> with the value 5 and <code class="language-plaintext highlighter-rouge">leaf</code> as one of its children, as shown in Listing 15-27:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">leaf</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Node</span> <span class="p">{</span>
        <span class="n">value</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">children</span><span class="p">:</span> <span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[]),</span>
    <span class="p">});</span>

    <span class="k">let</span> <span class="n">branch</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Node</span> <span class="p">{</span>
        <span class="n">value</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">children</span><span class="p">:</span> <span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="p">)]),</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-27-creating-a-leaf-node-with-no-children-and-a-branch-node-with-leaf-as-one-of-its-children">Listing 15-27: Creating a leaf node with no children and a branch node with leaf as one of its children</h4>

<p>We clone the <code class="language-plaintext highlighter-rouge">Rc&lt;Node&gt;</code> in <code class="language-plaintext highlighter-rouge">leaf</code> and store that in <code class="language-plaintext highlighter-rouge">branch</code>, meaning the <code class="language-plaintext highlighter-rouge">Node</code> in <code class="language-plaintext highlighter-rouge">leaf</code> now has two owners: <code class="language-plaintext highlighter-rouge">leaf</code> and <code class="language-plaintext highlighter-rouge">branch</code>. 
We can get from <code class="language-plaintext highlighter-rouge">branch</code> to <code class="language-plaintext highlighter-rouge">leaf</code> through <code class="language-plaintext highlighter-rouge">branch.children</code>, but there’s no way to get from <code class="language-plaintext highlighter-rouge">leaf</code> to <code class="language-plaintext highlighter-rouge">branch</code>. 
The reason is that <code class="language-plaintext highlighter-rouge">leaf</code> has no reference to <code class="language-plaintext highlighter-rouge">branch</code> and doesn’t know they’re related. 
We want <code class="language-plaintext highlighter-rouge">leaf</code> to know that <code class="language-plaintext highlighter-rouge">branch</code> is its parent. We’ll do that next.</p>

<h3 id="adding-a-reference-from-a-child-to-its-parent">Adding a Reference from a Child to Its Parent</h3>
<p>To make the child node aware of its parent, we need to add a <code class="language-plaintext highlighter-rouge">parent</code> field to our <code class="language-plaintext highlighter-rouge">Node</code> struct definition. 
The trouble is in deciding what the type of <code class="language-plaintext highlighter-rouge">parent</code> should be. 
We know it can’t contain an <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code>, because that would create a reference cycle with <code class="language-plaintext highlighter-rouge">leaf.parent</code> pointing to <code class="language-plaintext highlighter-rouge">branch</code> and <code class="language-plaintext highlighter-rouge">branch.children</code> pointing to <code class="language-plaintext highlighter-rouge">leaf</code>, which would cause their <code class="language-plaintext highlighter-rouge">strong_count</code> values to never be 0.</p>

<p>Thinking about the relationships another way, a parent node should own its children: if a parent node is dropped, its child nodes should be dropped as well. However, a child should not own its parent: if we drop a child node, the parent should still exist. This is a case for weak references!</p>

<p>So instead of <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code>, we’ll make the type of <code class="language-plaintext highlighter-rouge">parent</code> use <code class="language-plaintext highlighter-rouge">Weak&lt;T&gt;</code>, specifically a <code class="language-plaintext highlighter-rouge">RefCell&lt;Weak&lt;Node&gt;&gt;</code>. 
Now our Node struct definition looks like this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::{</span><span class="nb">Rc</span><span class="p">,</span> <span class="n">Weak</span><span class="p">};</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">parent</span><span class="p">:</span> <span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Weak</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">children</span><span class="p">:</span> <span class="n">RefCell</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>
<p>A node will be able to refer to its parent node but doesn’t own its parent. In Listing 15-28, we update <code class="language-plaintext highlighter-rouge">main</code> to use this new definition so the <code class="language-plaintext highlighter-rouge">leaf</code> node will have a way to refer to its parent, <code class="language-plaintext highlighter-rouge">branch</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">leaf</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Node</span> <span class="p">{</span>
        <span class="n">value</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">:</span> <span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Weak</span><span class="p">::</span><span class="nf">new</span><span class="p">()),</span>
        <span class="n">children</span><span class="p">:</span> <span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[]),</span>
    <span class="p">});</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"leaf parent = {:?}"</span><span class="p">,</span> <span class="n">leaf</span><span class="py">.parent</span><span class="nf">.borrow</span><span class="p">()</span><span class="nf">.upgrade</span><span class="p">());</span>

    <span class="k">let</span> <span class="n">branch</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Node</span> <span class="p">{</span>
        <span class="n">value</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">:</span> <span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Weak</span><span class="p">::</span><span class="nf">new</span><span class="p">()),</span>
        <span class="n">children</span><span class="p">:</span> <span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="p">)]),</span>
    <span class="p">});</span>

    <span class="o">*</span><span class="n">leaf</span><span class="py">.parent</span><span class="nf">.borrow_mut</span><span class="p">()</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">downgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="n">branch</span><span class="p">);</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"leaf parent = {:?}"</span><span class="p">,</span> <span class="n">leaf</span><span class="py">.parent</span><span class="nf">.borrow</span><span class="p">()</span><span class="nf">.upgrade</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-28-a-leaf-node-with-a-weak-reference-to-its-parent-node-branch">Listing 15-28: A leaf node with a weak reference to its parent node branch</h4>

<p>Creating the <code class="language-plaintext highlighter-rouge">leaf</code> node looks similar to how creating the <code class="language-plaintext highlighter-rouge">leaf</code> node looked in Listing 15-27 with the exception of the <code class="language-plaintext highlighter-rouge">parent</code> field: <code class="language-plaintext highlighter-rouge">leaf</code> starts out without a parent, so we create a new, empty <code class="language-plaintext highlighter-rouge">Weak&lt;Node&gt;</code> reference instance.</p>

<p>At this point, when we try to get a reference to the parent of <code class="language-plaintext highlighter-rouge">leaf</code> by using the <code class="language-plaintext highlighter-rouge">upgrade</code> method, we get a <code class="language-plaintext highlighter-rouge">None</code> value. 
We see this in the output from the first <code class="language-plaintext highlighter-rouge">println!</code> statement:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">leaf</span> <span class="n">parent</span> <span class="o">=</span> <span class="nb">None</span>
</code></pre></div></div>
<p>When we create the <code class="language-plaintext highlighter-rouge">branch</code> node, it will also have a new <code class="language-plaintext highlighter-rouge">Weak&lt;Node&gt;</code> reference in the <code class="language-plaintext highlighter-rouge">parent</code> field, because <code class="language-plaintext highlighter-rouge">branch</code> doesn’t have a parent node. 
We still have <code class="language-plaintext highlighter-rouge">leaf</code> as one of the children of <code class="language-plaintext highlighter-rouge">branch</code>. 
Once we have the <code class="language-plaintext highlighter-rouge">Node</code> instance in <code class="language-plaintext highlighter-rouge">branch</code>, we can modify <code class="language-plaintext highlighter-rouge">leaf</code> to give it a <code class="language-plaintext highlighter-rouge">Weak&lt;Node&gt;</code> reference to its parent. 
We use the <code class="language-plaintext highlighter-rouge">borrow_mut</code> method on the <code class="language-plaintext highlighter-rouge">RefCell&lt;Weak&lt;Node&gt;&gt;</code> in the <code class="language-plaintext highlighter-rouge">parent</code> field of <code class="language-plaintext highlighter-rouge">leaf</code>, and then we use the <code class="language-plaintext highlighter-rouge">Rc::downgrade</code> function to create a <code class="language-plaintext highlighter-rouge">Weak&lt;Node&gt;</code> reference to <code class="language-plaintext highlighter-rouge">branch</code> from the <code class="language-plaintext highlighter-rouge">Rc&lt;Node&gt;</code> in <code class="language-plaintext highlighter-rouge">branch</code>.</p>

<p>When we print the parent of <code class="language-plaintext highlighter-rouge">leaf</code> again, this time we’ll get a <code class="language-plaintext highlighter-rouge">Some</code> variant holding <code class="language-plaintext highlighter-rouge">branch</code>: now <code class="language-plaintext highlighter-rouge">leaf</code> can access its parent! When we print <code class="language-plaintext highlighter-rouge">leaf</code>, we also avoid the cycle that eventually ended in a stack overflow like we had in Listing 15-26; the <code class="language-plaintext highlighter-rouge">Weak&lt;Node&gt;</code> references are printed as <code class="language-plaintext highlighter-rouge">(Weak)</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">leaf</span> <span class="n">parent</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">Node</span> <span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="n">RefCell</span> <span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="p">(</span><span class="n">Weak</span><span class="p">)</span> <span class="p">},</span>
<span class="n">children</span><span class="p">:</span> <span class="n">RefCell</span> <span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="p">[</span><span class="n">Node</span> <span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="n">RefCell</span> <span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="p">(</span><span class="n">Weak</span><span class="p">)</span> <span class="p">},</span>
<span class="n">children</span><span class="p">:</span> <span class="n">RefCell</span> <span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="p">[]</span> <span class="p">}</span> <span class="p">}]</span> <span class="p">}</span> <span class="p">})</span>
</code></pre></div></div>
<p>The lack of infinite output indicates that this code didn’t create a reference cycle. We can also tell this by looking at the values we get from calling <code class="language-plaintext highlighter-rouge">Rc::strong_count</code> and <code class="language-plaintext highlighter-rouge">Rc::weak_count</code>.</p>

<h3 id="visualizing-changes-to-strong_count-and-weak_count">Visualizing Changes to strong_count and weak_count</h3>
<p>Let’s look at how the <code class="language-plaintext highlighter-rouge">strong_count</code> and <code class="language-plaintext highlighter-rouge">weak_count</code> values of the <code class="language-plaintext highlighter-rouge">Rc&lt;Node&gt;</code> instances change by creating a new inner scope and moving the creation of <code class="language-plaintext highlighter-rouge">branch</code> into that scope. 
By doing so, we can see what happens when <code class="language-plaintext highlighter-rouge">branch</code> is created and then dropped when it goes out of scope. The modifications are shown in Listing 15-29:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">leaf</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Node</span> <span class="p">{</span>
        <span class="n">value</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">:</span> <span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Weak</span><span class="p">::</span><span class="nf">new</span><span class="p">()),</span>
        <span class="n">children</span><span class="p">:</span> <span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[]),</span>
    <span class="p">});</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"leaf strong = {}, weak = {}"</span><span class="p">,</span>
        <span class="nn">Rc</span><span class="p">::</span><span class="nf">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="p">),</span>
        <span class="nn">Rc</span><span class="p">::</span><span class="nf">weak_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="p">),</span>
    <span class="p">);</span>

    <span class="p">{</span>
        <span class="k">let</span> <span class="n">branch</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Node</span> <span class="p">{</span>
            <span class="n">value</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">:</span> <span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Weak</span><span class="p">::</span><span class="nf">new</span><span class="p">()),</span>
            <span class="n">children</span><span class="p">:</span> <span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="p">)]),</span>
        <span class="p">});</span>

        <span class="o">*</span><span class="n">leaf</span><span class="py">.parent</span><span class="nf">.borrow_mut</span><span class="p">()</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">downgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="n">branch</span><span class="p">);</span>

        <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"branch strong = {}, weak = {}"</span><span class="p">,</span>
            <span class="nn">Rc</span><span class="p">::</span><span class="nf">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">branch</span><span class="p">),</span>
            <span class="nn">Rc</span><span class="p">::</span><span class="nf">weak_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">branch</span><span class="p">),</span>
        <span class="p">);</span>

        <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"leaf strong = {}, weak = {}"</span><span class="p">,</span>
            <span class="nn">Rc</span><span class="p">::</span><span class="nf">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="p">),</span>
            <span class="nn">Rc</span><span class="p">::</span><span class="nf">weak_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="p">),</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"leaf parent = {:?}"</span><span class="p">,</span> <span class="n">leaf</span><span class="py">.parent</span><span class="nf">.borrow</span><span class="p">()</span><span class="nf">.upgrade</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"leaf strong = {}, weak = {}"</span><span class="p">,</span>
        <span class="nn">Rc</span><span class="p">::</span><span class="nf">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="p">),</span>
        <span class="nn">Rc</span><span class="p">::</span><span class="nf">weak_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="p">),</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-15-29-creating-branch-in-an-inner-scope-and-examining-strong-and-weak-reference-counts">Listing 15-29: Creating branch in an inner scope and examining strong and weak reference counts</h4>

<p>After <code class="language-plaintext highlighter-rouge">leaf</code> is created, its <code class="language-plaintext highlighter-rouge">Rc&lt;Node&gt;</code> has a strong count of 1 and a weak count of 0. 
In the inner scope, we create <code class="language-plaintext highlighter-rouge">branch</code> and associate it with <code class="language-plaintext highlighter-rouge">leaf</code>, at which point when we print the counts, the <code class="language-plaintext highlighter-rouge">Rc&lt;Node&gt;</code> in <code class="language-plaintext highlighter-rouge">branch</code> will have a strong count of 1 and a weak count of 1 (for <code class="language-plaintext highlighter-rouge">leaf.parent</code> pointing to <code class="language-plaintext highlighter-rouge">branch</code> with a <code class="language-plaintext highlighter-rouge">Weak&lt;Node&gt;</code>). When we print the counts in <code class="language-plaintext highlighter-rouge">leaf</code>, we’ll see it will have a strong count of 2, because <code class="language-plaintext highlighter-rouge">branch</code> now has a clone of the <code class="language-plaintext highlighter-rouge">Rc&lt;Node&gt;</code> of <code class="language-plaintext highlighter-rouge">leaf</code> stored in <code class="language-plaintext highlighter-rouge">branch.children</code>, but will still have a weak count of 0.</p>

<p>When the inner scope ends, <code class="language-plaintext highlighter-rouge">branch</code> goes out of scope and the strong count of the <code class="language-plaintext highlighter-rouge">Rc&lt;Node&gt;</code> decreases to 0, so its <code class="language-plaintext highlighter-rouge">Node</code> is dropped. 
The weak count of 1 from <code class="language-plaintext highlighter-rouge">leaf.parent</code> has no bearing on whether or not <code class="language-plaintext highlighter-rouge">Node</code> is dropped, so we don’t get any memory leaks!</p>

<p>If we try to access the parent of <code class="language-plaintext highlighter-rouge">leaf</code> after the end of the scope, we’ll get <code class="language-plaintext highlighter-rouge">None</code> again. 
At the end of the program, the <code class="language-plaintext highlighter-rouge">Rc&lt;Node&gt;</code> in <code class="language-plaintext highlighter-rouge">leaf</code> has a strong count of 1 and a weak count of 0, because the variable <code class="language-plaintext highlighter-rouge">leaf</code> is now the only reference to the <code class="language-plaintext highlighter-rouge">Rc&lt;Node&gt;</code> again.</p>

<p>All of the logic that manages the counts and value dropping is built into <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> and <code class="language-plaintext highlighter-rouge">Weak&lt;T&gt;</code> and their implementations of the <code class="language-plaintext highlighter-rouge">Drop</code> trait. 
By specifying that the relationship from a child to its parent should be a <code class="language-plaintext highlighter-rouge">Weak&lt;T&gt;</code> reference in the definition of <code class="language-plaintext highlighter-rouge">Node</code>, you’re able to have parent nodes point to child nodes and vice versa without creating a reference cycle and memory leaks.</p>

<h2 id="summary">Summary</h2>
<p>This chapter covered how to use smart pointers to make different guarantees and trade-offs from those Rust makes by default with regular references. 
The <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> type has a known size and points to data allocated on the heap. The <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> type keeps track of the number of references to data on the heap so that data can have multiple owners. The <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> type with its interior mutability gives us a type that we can use when we need an immutable type but need to change an inner value of that type; it also enforces the borrowing rules at runtime instead of at compile time.</p>

<p>Also discussed were the <code class="language-plaintext highlighter-rouge">Deref</code> and <code class="language-plaintext highlighter-rouge">Drop</code> traits, which enable a lot of the functionality of smart pointers. We explored reference cycles that can cause memory leaks and how to prevent them using <code class="language-plaintext highlighter-rouge">Weak&lt;T&gt;</code>.</p>

<p>If this chapter has piqued your interest and you want to implement your own smart pointers, check out “The Rustonomicon” for more useful information.</p>

<p>Next, we’ll talk about concurrency in Rust. You’ll even learn about a few new smart pointers.</p>

        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/#pointer" class="page__taxonomy-item" rel="tag">Pointer</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#smart-pointer" class="page__taxonomy-item" rel="tag">Smart Pointer</a>
    
    </span>
  </p>




  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/categories/#rust-language" class="page__taxonomy-item" rel="tag">RUST Language</a>
    
    </span>
  </p>


        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2020-04-20T00:00:00+00:00">April 20, 2020</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?text=RUST+%3A+15.+Smart+Pointers%20https%3A%2F%2Fjjungs-lee.github.io%2F%2Frust%2F15.Smart-Pointers" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fjjungs-lee.github.io%2F%2Frust%2F15.Smart-Pointers" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fjjungs-lee.github.io%2F%2Frust%2F15.Smart-Pointers" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/rust/14.More-About-Cargo-and-Crates.io" class="pagination--pager" title="RUST : 14. More About Cargo and Crates.io
">Previous</a>
    
    
      <a href="/rust/How-to-null-check-in-rust" class="pagination--pager" title="RUST : How to check null value in rust
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/rust/4.Variable-Bindings" rel="permalink">Rust by Example : 4. Variable Bindings
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  2 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">Rust provides type safety via static typing. 
Variable bindings can be type annotated when declared. 
However, in most cases, the compiler will be able to in...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/rust/3.Custom-Types" rel="permalink">Rust by Example : 3. Custom Types
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  8 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">Rust custom data types are formed mainly through the two keywords:
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/rust/2.Primitives" rel="permalink">Rust by Example : 2. Primitives
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  6 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">Rust provides access to a wide variety of primitives. A sample includes:
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/rust/1.Hello-World" rel="permalink">Rust by Example : 1. Hello World
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  13 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">This is the source code of the traditional Hello World program.
</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
      
        
      
        
          <li><a href="https://github.com/jjungs-lee" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
      
        
      
        
      
        
          <li><a href="https://www.linkedin.com/in/jjungs-lee" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
    

    <li><a href="NONE"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 JJungs-lee. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script src="https://kit.fontawesome.com/4eee35f757.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>







  </body>
</html>
