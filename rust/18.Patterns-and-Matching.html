<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.17.2 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html -->

<!----><title>Yes! I Take IT :)</title>
<meta name="description" content="Patterns and MatchingPatterns are a special syntax in Rust for matching against the structure of types, both complex and simple. Using patterns in conjunction with match expressions and other constructs gives you more control over a program’s control flow. A pattern consists of some combination of the following:">


  <meta name="author" content="JJungs-lee">


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Yes! I Take IT">
<meta property="og:title" content="RUST : 18. Patterns and Matching">
<meta property="og:url" content="https://jjungs-lee.github.io//rust/18.Patterns-and-Matching">


  <meta property="og:description" content="Patterns and MatchingPatterns are a special syntax in Rust for matching against the structure of types, both complex and simple. Using patterns in conjunction with match expressions and other constructs gives you more control over a program’s control flow. A pattern consists of some combination of the following:">







  <meta property="article:published_time" content="2020-12-14T00:00:00+00:00">





  

  


<link rel="canonical" href="https://jjungs-lee.github.io//rust/18.Patterns-and-Matching">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "JJungs-lee",
      "url": "https://jjungs-lee.github.io//"
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="NONE" type="application/atom+xml" rel="alternate" title="Yes! I Take IT Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          <b>I.T.I</b> <small>by JHLee</small>
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/posts/" >Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/kernel/" >Kernel</a>
            </li><li class="masthead__menu-item">
              <a href="/swim/" >Swim</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="/assets/images/author_jhl.png" alt="JJungs-lee" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">JJungs-lee</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>Do Coding! Do Study!</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Somewhere</span>
        </li>
      

      
        
          
        
          
        
          
        
          
        
          
            <li><a href="https://github.com/jjungs-lee" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
          
        
          
        
          
            <li><a href="https://www.linkedin.com/in/jjungs-lee" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="RUST : 18. Patterns and Matching">
    <meta itemprop="description" content="Patterns and MatchingPatterns are a special syntax in Rust for matching against the structure of types, both complex and simple. Using patterns in conjunction with match expressions and other constructs gives you more control over a program’s control flow. A pattern consists of some combination of the following:">
    <meta itemprop="datePublished" content="2020-12-14T00:00:00+00:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">RUST : 18. Patterns and Matching
</h1>
          
            <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  38 minute read

</p>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
        <h2 id="patterns-and-matching">Patterns and Matching</h2>
<p>Patterns are a special syntax in Rust for matching against the structure of types, both complex and simple. 
Using patterns in conjunction with <code class="language-plaintext highlighter-rouge">match</code> expressions and other constructs gives you more control over a program’s control flow. 
A pattern consists of some combination of the following:</p>

<ul>
  <li>Literals</li>
  <li>Destructured arrays, enums, structs, or tuples</li>
  <li>Variables</li>
  <li>Wildcards</li>
  <li>Placeholders</li>
</ul>

<p>These components describe the shape of the data we’re working with, which we then match against values to determine whether our program has the correct data to continue running a particular piece of code.</p>

<p>To use a pattern, we compare it to some value. 
If the pattern matches the value, we use the value parts in our code. 
Recall the <code class="language-plaintext highlighter-rouge">match</code> expressions in Chapter 6 that used patterns, such as the coin-sorting machine example. 
If the value fits the shape of the pattern, we can use the named pieces. 
If it doesn’t, the code associated with the pattern won’t run.</p>

<p>This chapter is a reference on all things related to patterns. 
We’ll cover the valid places to use patterns, the difference between refutable and irrefutable patterns, and the different kinds of pattern syntax that you might see. 
By the end of the chapter, you’ll know how to use patterns to express many concepts in a clear way.</p>

<h2 id="all-the-places-patterns-can-be-used">All the Places Patterns Can Be Used</h2>
<p>Patterns pop up in a number of places in Rust, and you’ve been using them a lot without realizing it! 
This section discusses all the places where patterns are valid.</p>

<h3 id="match-arms">match Arms</h3>
<p>As discussed in Chapter 6, we use patterns in the arms of <code class="language-plaintext highlighter-rouge">match</code> expressions. 
Formally, <code class="language-plaintext highlighter-rouge">match</code> expressions are defined as the keyword match, a value to match on, and one or more match arms that consist of a pattern and an expression to run if the value matches that arm’s pattern, like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">match</span> <span class="n">VALUE</span> <span class="p">{</span>
    <span class="n">PATTERN</span> <span class="k">=&gt;</span> <span class="n">EXPRESSION</span><span class="p">,</span>
    <span class="n">PATTERN</span> <span class="k">=&gt;</span> <span class="n">EXPRESSION</span><span class="p">,</span>
    <span class="n">PATTERN</span> <span class="k">=&gt;</span> <span class="n">EXPRESSION</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>
<p>One requirement for <code class="language-plaintext highlighter-rouge">match</code> expressions is that they need to be <em>exhaustive</em> in the sense that all possibilities for the value in the <code class="language-plaintext highlighter-rouge">match</code> expression must be accounted for. 
One way to ensure you’ve covered every possibility is to have a catchall pattern for the last arm: 
for example, a variable name matching any value can never fail and thus covers every remaining case.</p>

<p>A particular pattern <code class="language-plaintext highlighter-rouge">_</code> will match anything, but it never binds to a variable, so it’s often used in the last match arm. 
The <code class="language-plaintext highlighter-rouge">_</code> pattern can be useful when you want to ignore any value not specified, for example. 
We’ll cover the <code class="language-plaintext highlighter-rouge">_</code> pattern in more detail in the “Ignoring Values in a Pattern” section later in this chapter.</p>

<h3 id="conditional-if-let-expressions">Conditional if let Expressions</h3>
<p>In Chapter 6 we discussed how to use <code class="language-plaintext highlighter-rouge">if let</code> expressions mainly as a shorter way to write the equivalent of a <code class="language-plaintext highlighter-rouge">match</code> that only matches one case. 
Optionally, <code class="language-plaintext highlighter-rouge">if let</code> can have a corresponding <code class="language-plaintext highlighter-rouge">else</code> containing code to run if the pattern in the <code class="language-plaintext highlighter-rouge">if let</code> doesn’t match.</p>

<p>Listing 18-1 shows that it’s also possible to mix and match <code class="language-plaintext highlighter-rouge">if let</code>, <code class="language-plaintext highlighter-rouge">else if</code>, and <code class="language-plaintext highlighter-rouge">else if let</code> expressions. 
Doing so gives us more flexibility than a <code class="language-plaintext highlighter-rouge">match</code> expression in which we can express only one value to compare with the patterns. 
Also, the conditions in a series of <code class="language-plaintext highlighter-rouge">if let</code>, <code class="language-plaintext highlighter-rouge">else if</code>, <code class="language-plaintext highlighter-rouge">else if let</code> arms aren’t required to relate to each other.</p>

<p>The code in Listing 18-1 shows a series of checks for several conditions that decide what the background color should be. 
For this example, we’ve created variables with hardcoded values that a real program might receive from user input.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Filename: src/main.rs</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">favorite_color</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">is_tuesday</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">age</span><span class="p">:</span> <span class="n">Result</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="mi">_</span><span class="o">&gt;</span> <span class="o">=</span> <span class="s">"34"</span><span class="nf">.parse</span><span class="p">();</span>

    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="o">=</span> <span class="n">favorite_color</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Using your favorite color, {}, as the background"</span><span class="p">,</span> <span class="n">color</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">is_tuesday</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Tuesday is green day!"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">let</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">age</span><span class="p">)</span> <span class="o">=</span> <span class="n">age</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">age</span> <span class="o">&gt;</span> <span class="mi">30</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Using purple as the background color"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Using orange as the background color"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Using blue as the background color"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-18-1-mixing-if-let-else-if-else-if-let-and-else">Listing 18-1: Mixing if let, else if, else if let, and else</h4>

<p>If the user specifies a favorite color, that color is the background color. 
If today is Tuesday, the background color is green. 
If the user specifies their age as a string and we can parse it as a number successfully, the color is either purple or orange depending on the value of the number. 
If none of these conditions apply, the background color is blue.</p>

<p>This conditional structure lets us support complex requirements. 
With the hardcoded values we have here, this example will print <code class="language-plaintext highlighter-rouge">Using purple as the background color</code>.</p>

<p>You can see that <code class="language-plaintext highlighter-rouge">if let</code> can also introduce shadowed variables in the same way that <code class="language-plaintext highlighter-rouge">match</code> arms can: the line <code class="language-plaintext highlighter-rouge">if let Ok(age) = age</code> introduces a new shadowed <code class="language-plaintext highlighter-rouge">age</code> variable that contains the value inside the <code class="language-plaintext highlighter-rouge">Ok</code> variant. 
This means we need to place the <code class="language-plaintext highlighter-rouge">if age &gt; 30</code> condition within that block: we can’t combine these two conditions into <code class="language-plaintext highlighter-rouge">if let Ok(age) = age &amp;&amp; age &gt; 30</code>. The shadowed age we want to compare to 30 isn’t valid until the new scope starts with the curly bracket.</p>

<p>The downside of using <code class="language-plaintext highlighter-rouge">if let</code> expressions is that the compiler doesn’t check exhaustiveness, whereas with <code class="language-plaintext highlighter-rouge">match</code> expressions it does. 
If we omitted the last <code class="language-plaintext highlighter-rouge">else</code> block and therefore missed handling some cases, the compiler would not alert us to the possible logic bug.</p>

<h3 id="while-let-conditional-loops">while let Conditional Loops</h3>
<p>Similar in construction to <code class="language-plaintext highlighter-rouge">if let</code>, the <code class="language-plaintext highlighter-rouge">while let</code> conditional loop allows a <code class="language-plaintext highlighter-rouge">while</code> loop to run for as long as a pattern continues to match. 
The example in Listing 18-2 shows a <code class="language-plaintext highlighter-rouge">while let</code> loop that uses a vector as a stack and prints the values in the vector in the opposite order in which they were pushed.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="k">mut</span> <span class="n">stack</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="n">stack</span><span class="nf">.push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">stack</span><span class="nf">.push</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">stack</span><span class="nf">.push</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">top</span><span class="p">)</span> <span class="o">=</span> <span class="n">stack</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">top</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-18-2-using-a-while-let-loop-to-print-values-for-as-long-as-stackpop-returns-some">Listing 18-2: Using a <code class="language-plaintext highlighter-rouge">while let</code> loop to print values for as long as <code class="language-plaintext highlighter-rouge">stack.pop()</code> returns Some</h4>

<p>This example prints 3, 2, and then 1. 
The <code class="language-plaintext highlighter-rouge">pop</code> method takes the last element out of the vector and returns <code class="language-plaintext highlighter-rouge">Some(value)</code>. 
If the vector is empty, <code class="language-plaintext highlighter-rouge">pop</code> returns <code class="language-plaintext highlighter-rouge">None</code>. 
The <code class="language-plaintext highlighter-rouge">while</code> loop continues running the code in its block as long as <code class="language-plaintext highlighter-rouge">pop</code> returns <code class="language-plaintext highlighter-rouge">Some</code>. 
When <code class="language-plaintext highlighter-rouge">pop</code> returns <code class="language-plaintext highlighter-rouge">None</code>, the loop stops. 
We can use <code class="language-plaintext highlighter-rouge">while let</code> to pop every element off our stack.</p>

<h3 id="for-loops">for Loops</h3>
<p>In Chapter 3, we mentioned that the <code class="language-plaintext highlighter-rouge">for</code> loop is the most common loop construction in Rust code, but we haven’t yet discussed the pattern that <code class="language-plaintext highlighter-rouge">for</code> takes. 
In a <code class="language-plaintext highlighter-rouge">for</code> loop, the pattern is the value that directly follows the keyword <code class="language-plaintext highlighter-rouge">for</code>, so in <code class="language-plaintext highlighter-rouge">for x in y</code> the <code class="language-plaintext highlighter-rouge">x</code> is the pattern.</p>

<p>Listing 18-3 demonstrates how to use a pattern in a <code class="language-plaintext highlighter-rouge">for</code> loop to destructure, or break apart, a tuple as part of the <code class="language-plaintext highlighter-rouge">for</code> loop.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="sc">'a'</span><span class="p">,</span> <span class="sc">'b'</span><span class="p">,</span> <span class="sc">'c'</span><span class="p">];</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="n">in</span> <span class="n">v</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{} is at index {}"</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
   <span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-18-3-using-a-pattern-in-a-for-loop-to-destructure-a-tuple">Listing 18-3: Using a pattern in a for loop to destructure a tuple</h4>

<p>The code in Listing 18-3 will print the following:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="n">patterns</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="c">///projects/patterns)</span>
    <span class="n">Finished</span> <span class="n">dev</span> <span class="p">[</span><span class="n">unoptimized</span> <span class="o">+</span> <span class="n">debuginfo</span><span class="p">]</span> <span class="nf">target</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="n">in</span> <span class="mf">0.52</span><span class="n">s</span>
     <span class="n">Running</span> <span class="err">`</span><span class="n">target</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">patterns</span><span class="err">`</span>
<span class="n">a</span> <span class="n">is</span> <span class="n">at</span> <span class="n">index</span> <span class="mi">0</span>
<span class="n">b</span> <span class="n">is</span> <span class="n">at</span> <span class="n">index</span> <span class="mi">1</span>
<span class="n">c</span> <span class="n">is</span> <span class="n">at</span> <span class="n">index</span> <span class="mi">2</span>
</code></pre></div></div>
<p>We use the <code class="language-plaintext highlighter-rouge">enumerate</code> method to adapt an iterator to produce a value and that value’s index in the iterator, placed into a tuple. The first call to <code class="language-plaintext highlighter-rouge">enumerate</code> produces the tuple <code class="language-plaintext highlighter-rouge">(0, 'a')</code>. When this value is matched to the pattern <code class="language-plaintext highlighter-rouge">(index, value)</code>, <code class="language-plaintext highlighter-rouge">index</code> will be <code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">value</code> will be <code class="language-plaintext highlighter-rouge">'a'</code>, printing the first line of the output.</p>

<h3 id="let-statements">let Statements</h3>
<p>Prior to this chapter, we had only explicitly discussed using patterns with <code class="language-plaintext highlighter-rouge">match</code> and <code class="language-plaintext highlighter-rouge">if let</code>, but in fact, we’ve used patterns in other places as well, including in <code class="language-plaintext highlighter-rouge">let</code> statements. 
For example, consider this straightforward variable assignment with <code class="language-plaintext highlighter-rouge">let</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</code></pre></div></div>
<p>Throughout this book, we’ve used <code class="language-plaintext highlighter-rouge">let</code> like this hundreds of times, and although you might not have realized it, you were using patterns! More formally, a <code class="language-plaintext highlighter-rouge">let</code> statement looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let PATTERN = EXPRESSION;
</code></pre></div></div>
<p>In statements like <code class="language-plaintext highlighter-rouge">let x = 5;</code> with a variable name in the <code class="language-plaintext highlighter-rouge">PATTERN</code> slot, the variable name is just a particularly simple form of a pattern. 
Rust compares the expression against the pattern and assigns any names it finds. 
So in the <code class="language-plaintext highlighter-rouge">let x = 5;</code> example, <code class="language-plaintext highlighter-rouge">x</code> is a pattern that means “bind what matches here to the variable <code class="language-plaintext highlighter-rouge">x</code>.” 
Because the name <code class="language-plaintext highlighter-rouge">x</code> is the whole pattern, this pattern effectively means “bind everything to the variable <code class="language-plaintext highlighter-rouge">x</code>, whatever the value is.”</p>

<p>To see the pattern matching aspect of <code class="language-plaintext highlighter-rouge">let</code> more clearly, consider Listing 18-4, which uses a pattern with <code class="language-plaintext highlighter-rouge">let</code> to destructure a tuple.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</code></pre></div></div>
<h4 id="listing-18-4-using-a-pattern-to-destructure-a-tuple-and-create-three-variables-at-once">Listing 18-4: Using a pattern to destructure a tuple and create three variables at once</h4>

<p>Here, we match a tuple against a pattern. 
Rust compares the value <code class="language-plaintext highlighter-rouge">(1, 2, 3)</code> to the pattern <code class="language-plaintext highlighter-rouge">(x, y, z)</code> and sees that the value matches the pattern, so Rust binds <code class="language-plaintext highlighter-rouge">1</code> to <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">2</code> to <code class="language-plaintext highlighter-rouge">y</code>, and <code class="language-plaintext highlighter-rouge">3</code> to <code class="language-plaintext highlighter-rouge">z</code>. 
You can think of this tuple pattern as nesting three individual variable patterns inside it.</p>

<p>If the number of elements in the pattern doesn’t match the number of elements in the tuple, the overall type won’t match and we’ll get a compiler error. 
For example, Listing 18-5 shows an attempt to destructure a tuple with three elements into two variables, which won’t work.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</code></pre></div></div>
<h4 id="listing-18-5-incorrectly-constructing-a-pattern-whose-variables-dont-match-the-number-of-elements-in-the-tuple">Listing 18-5: Incorrectly constructing a pattern whose variables don’t match the number of elements in the tuple</h4>

<p>Attempting to compile this code results in this type error:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="n">patterns</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="c">///projects/patterns)</span>
<span class="n">error</span><span class="p">[</span><span class="n">E0308</span><span class="p">]:</span> <span class="n">mismatched</span> <span class="n">types</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">9</span>
  <span class="p">|</span>
<span class="mi">2</span> <span class="p">|</span>     <span class="k">let</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="p">|</span>         <span class="o">^^^^^^</span> <span class="n">expected</span> <span class="n">a</span> <span class="n">tuple</span> <span class="n">with</span> <span class="mi">3</span> <span class="n">elements</span><span class="p">,</span> <span class="n">found</span> <span class="n">one</span> <span class="n">with</span> <span class="mi">2</span> <span class="n">elements</span>
  <span class="p">|</span>
  <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">expected</span> <span class="n">tuple</span> <span class="err">`</span><span class="p">({</span><span class="n">integer</span><span class="p">},</span> <span class="p">{</span><span class="n">integer</span><span class="p">},</span> <span class="p">{</span><span class="n">integer</span><span class="p">})</span><span class="err">`</span>
             <span class="n">found</span> <span class="n">tuple</span> <span class="err">`</span><span class="p">(</span><span class="mi">_</span><span class="p">,</span> <span class="mi">_</span><span class="p">)</span><span class="err">`</span>

<span class="n">error</span><span class="p">:</span> <span class="n">aborting</span> <span class="n">due</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">error</span>

<span class="n">For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">about</span> <span class="n">this</span> <span class="n">error</span><span class="p">,</span> <span class="n">try</span> <span class="err">`</span><span class="n">rustc</span> <span class="o">--</span><span class="n">explain</span> <span class="n">E0308</span><span class="err">`</span><span class="py">.
error</span><span class="p">:</span> <span class="n">could</span> <span class="n">not</span> <span class="n">compile</span> <span class="err">`</span><span class="n">patterns</span><span class="err">`</span><span class="py">.

To</span> <span class="n">learn</span> <span class="n">more</span><span class="p">,</span> <span class="n">run</span> <span class="n">the</span> <span class="n">command</span> <span class="n">again</span> <span class="n">with</span> <span class="o">--</span><span class="n">verbose</span><span class="err">.</span>
</code></pre></div></div>
<p>If we wanted to <strong>ignore</strong> one or more of the values in the tuple, we could use <code class="language-plaintext highlighter-rouge">_</code> or <code class="language-plaintext highlighter-rouge">..</code>, as you’ll see in the “Ignoring Values in a Pattern” section. 
If the problem is that we have too many variables in the pattern, the solution is to make the types match by removing variables so the number of variables equals the number of elements in the tuple.</p>

<h3 id="function-parameters">Function Parameters</h3>
<p>Function parameters can also be patterns. 
The code in Listing 18-6, which declares a function named <code class="language-plaintext highlighter-rouge">foo</code> that takes one parameter named <code class="language-plaintext highlighter-rouge">x</code> of type <code class="language-plaintext highlighter-rouge">i32</code>, should by now look familiar.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// code goes here</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-18-6-a-function-signature-uses-patterns-in-the-parameters">Listing 18-6: A function signature uses patterns in the parameters</h4>

<p>The <code class="language-plaintext highlighter-rouge">x</code> part is a pattern! As we did with <code class="language-plaintext highlighter-rouge">let</code>, we could match a tuple in a function’s arguments to the pattern. Listing 18-7 splits the values in a tuple as we pass it to a function.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Filename: src/main.rs</span>

<span class="k">fn</span> <span class="nf">print_coordinates</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="o">&amp;</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">))</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Current location: ({}, {})"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">point</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="nf">print_coordinates</span><span class="p">(</span><span class="o">&amp;</span><span class="n">point</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-18-7-a-function-with-parameters-that-destructure-a-tuple">Listing 18-7: A function with parameters that destructure a tuple</h4>

<p>This code prints <code class="language-plaintext highlighter-rouge">Current location: (3, 5)</code>. The values <code class="language-plaintext highlighter-rouge">&amp;(3, 5)</code> match the pattern <code class="language-plaintext highlighter-rouge">&amp;(x, y)</code>, so <code class="language-plaintext highlighter-rouge">x</code> is the value <code class="language-plaintext highlighter-rouge">3</code> and <code class="language-plaintext highlighter-rouge">y</code> is the value <code class="language-plaintext highlighter-rouge">5</code>.</p>

<p>We can also use patterns in closure parameter lists in the same way as in function parameter lists, because closures are similar to functions, as discussed in Chapter 13.</p>

<p>At this point, you’ve seen several ways of using patterns, but patterns don’t work the same in every place we can use them. 
In some places, the patterns must be irrefutable; in other circumstances, they can be refutable. We’ll discuss these two concepts next.</p>

<h2 id="refutability-whether-a-pattern-might-fail-to-match">Refutability: Whether a Pattern Might Fail to Match</h2>
<p>Patterns come in two forms: <strong>refutable</strong> and <strong>irrefutable</strong>. 
Patterns that will match for any possible value passed are <em>irrefutable</em>. 
An example would be <code class="language-plaintext highlighter-rouge">x</code> in the statement <code class="language-plaintext highlighter-rouge">let x = 5;</code> because <code class="language-plaintext highlighter-rouge">x</code> matches anything and therefore cannot fail to match. 
Patterns that can fail to match for some possible value are <em>refutable</em>. 
An example would be <code class="language-plaintext highlighter-rouge">Some(x)</code> in the expression <code class="language-plaintext highlighter-rouge">if let Some(x) = a_value</code> because if the value in the <code class="language-plaintext highlighter-rouge">a_value</code> variable is <code class="language-plaintext highlighter-rouge">None</code> rather than <code class="language-plaintext highlighter-rouge">Some</code>, the <code class="language-plaintext highlighter-rouge">Some(x)</code> pattern will not match.</p>

<p>Function parameters, <code class="language-plaintext highlighter-rouge">let</code> statements, and <code class="language-plaintext highlighter-rouge">for</code> loops can only accept irrefutable patterns, because the program cannot do anything meaningful when values don’t match. 
The <code class="language-plaintext highlighter-rouge">if let</code> and <code class="language-plaintext highlighter-rouge">while let</code> expressions accept refutable and irrefutable patterns, but the compiler warns against irrefutable patterns because by definition they’re intended to handle possible failure: the functionality of a conditional is in its ability to perform differently depending on success or failure.</p>

<p>In general, you shouldn’t have to worry about the distinction between refutable and irrefutable patterns; 
however, you do need to be familiar with the concept of refutability so you can respond when you see it in an error message. 
In those cases, you’ll need to change either the pattern or the construct you’re using the pattern with, depending on the intended behavior of the code.</p>

<p>Let’s look at an example of what happens when we try to use a refutable pattern where Rust requires an irrefutable pattern and vice versa. 
Listing 18-8 shows a <code class="language-plaintext highlighter-rouge">let</code> statement, but for the pattern we’ve specified <code class="language-plaintext highlighter-rouge">Some(x)</code>, a refutable pattern. As you might expect, this code will not compile.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">some_option_value</span><span class="p">;</span>
</code></pre></div></div>
<h4 id="listing-18-8-attempting-to-use-a-refutable-pattern-with-let">Listing 18-8: Attempting to use a refutable pattern with let</h4>

<p>If <code class="language-plaintext highlighter-rouge">some_option_value</code> was a <code class="language-plaintext highlighter-rouge">None</code> value, it would fail to match the pattern <code class="language-plaintext highlighter-rouge">Some(x)</code>, meaning the pattern is refutable. 
However, the <code class="language-plaintext highlighter-rouge">let</code> statement can only accept an irrefutable pattern because there is nothing valid the code can do with a <code class="language-plaintext highlighter-rouge">None</code> value. 
At compile time, Rust will complain that we’ve tried to use a refutable pattern where an irrefutable pattern is required:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="n">patterns</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="c">///projects/patterns)</span>
<span class="n">error</span><span class="p">[</span><span class="n">E0005</span><span class="p">]:</span> <span class="n">refutable</span> <span class="n">pattern</span> <span class="n">in</span> <span class="n">local</span> <span class="n">binding</span><span class="p">:</span> <span class="err">`</span><span class="nb">None</span><span class="err">`</span> <span class="n">not</span> <span class="n">covered</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="mi">9</span>
  <span class="p">|</span>
<span class="mi">3</span> <span class="p">|</span>     <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">some_option_value</span><span class="p">;</span>
  <span class="p">|</span>         <span class="o">^^^^^^^</span> <span class="n">pattern</span> <span class="err">`</span><span class="nb">None</span><span class="err">`</span> <span class="n">not</span> <span class="n">covered</span>
  <span class="p">|</span>
  <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="err">`</span><span class="k">let</span><span class="err">`</span> <span class="n">bindings</span> <span class="n">require</span> <span class="n">an</span> <span class="s">"irrefutable pattern"</span><span class="p">,</span> <span class="n">like</span> <span class="n">a</span> <span class="err">`</span><span class="k">struct</span><span class="err">`</span> <span class="n">or</span> <span class="n">an</span> <span class="err">`</span><span class="k">enum</span><span class="err">`</span> <span class="n">with</span> <span class="n">only</span> <span class="n">one</span> <span class="n">variant</span>
  <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="k">for</span> <span class="n">more</span> <span class="n">information</span><span class="p">,</span> <span class="n">visit</span> <span class="n">https</span><span class="p">:</span><span class="c">//doc.rust-lang.org/book/ch18-02-refutability.html</span>
<span class="n">help</span><span class="p">:</span> <span class="n">you</span> <span class="n">might</span> <span class="n">want</span> <span class="n">to</span> <span class="k">use</span> <span class="err">`</span><span class="k">if</span> <span class="k">let</span><span class="err">`</span> <span class="n">to</span> <span class="n">ignore</span> <span class="n">the</span> <span class="n">variant</span> <span class="n">that</span> <span class="n">isn</span><span class="nv">'t</span> <span class="n">matched</span>
  <span class="p">|</span>
<span class="mi">3</span> <span class="p">|</span>     <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">some_option_value</span> <span class="p">{</span> <span class="cm">/* */</span> <span class="p">}</span>
  <span class="p">|</span>

<span class="n">error</span><span class="p">:</span> <span class="n">aborting</span> <span class="n">due</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">error</span>

<span class="n">For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">about</span> <span class="n">this</span> <span class="n">error</span><span class="p">,</span> <span class="n">try</span> <span class="err">`</span><span class="n">rustc</span> <span class="o">--</span><span class="n">explain</span> <span class="n">E0005</span><span class="err">`</span><span class="py">.
error</span><span class="p">:</span> <span class="n">could</span> <span class="n">not</span> <span class="n">compile</span> <span class="err">`</span><span class="n">patterns</span><span class="err">`</span><span class="py">.

To</span> <span class="n">learn</span> <span class="n">more</span><span class="p">,</span> <span class="n">run</span> <span class="n">the</span> <span class="n">command</span> <span class="n">again</span> <span class="n">with</span> <span class="o">--</span><span class="n">verbose</span><span class="err">.</span>
</code></pre></div></div>
<p>Because we didn’t cover (and couldn’t cover!) every valid value with the pattern <code class="language-plaintext highlighter-rouge">Some(x)</code>, Rust rightfully produces a compiler error.</p>

<p>To fix the problem where we have a refutable pattern where an irrefutable pattern is needed, we can change the code that uses the pattern: instead of using <code class="language-plaintext highlighter-rouge">let</code>, we can use <code class="language-plaintext highlighter-rouge">if let</code>. 
Then if the pattern doesn’t match, the code will just skip the code in the curly brackets, giving it a way to continue validly. Listing 18-9 shows how to fix the code in Listing 18-8.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">some_option_value</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-18-9-using-if-let-and-a-block-with-refutable-patterns-instead-of-let">Listing 18-9: Using if let and a block with refutable patterns instead of let</h4>

<p>We’ve given the code an out! This code is perfectly valid, although it means we cannot use an irrefutable pattern without receiving an error. 
If we give <code class="language-plaintext highlighter-rouge">if let</code> a pattern that will always match, such as <code class="language-plaintext highlighter-rouge">x</code>, as shown in Listing 18-10, the compiler will give a warning.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="p">};</span>
</code></pre></div></div>
<h4 id="listing-18-10-attempting-to-use-an-irrefutable-pattern-with-if-let">Listing 18-10: Attempting to use an irrefutable pattern with if let</h4>

<p>Rust complains that it doesn’t make sense to use <code class="language-plaintext highlighter-rouge">if let</code> with an irrefutable pattern:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="n">patterns</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="c">///projects/patterns)</span>
<span class="n">warning</span><span class="p">:</span> <span class="n">irrefutable</span> <span class="k">if</span><span class="o">-</span><span class="k">let</span> <span class="n">pattern</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span>
  <span class="p">|</span>
<span class="mi">2</span> <span class="p">|</span> <span class="o">/</span>     <span class="k">if</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span> <span class="p">{</span>
<span class="mi">3</span> <span class="p">|</span> <span class="p">|</span>         <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="mi">4</span> <span class="p">|</span> <span class="p">|</span>     <span class="p">};</span>
  <span class="p">|</span> <span class="p">|</span><span class="mi">_____</span><span class="o">^</span>
  <span class="p">|</span>
  <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="err">`</span><span class="nd">#[warn(irrefutable_let_patterns)]</span><span class="err">`</span> <span class="n">on</span> <span class="n">by</span> <span class="n">default</span>

    <span class="n">Finished</span> <span class="n">dev</span> <span class="p">[</span><span class="n">unoptimized</span> <span class="o">+</span> <span class="n">debuginfo</span><span class="p">]</span> <span class="nf">target</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="n">in</span> <span class="mf">0.39</span><span class="n">s</span>
     <span class="n">Running</span> <span class="err">`</span><span class="n">target</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">patterns</span><span class="err">`</span>
</code></pre></div></div>
<p>For this reason, match arms must use refutable patterns, except for the last arm, which should match any remaining values with an irrefutable pattern. 
Rust allows us to use an irrefutable pattern in a <code class="language-plaintext highlighter-rouge">match</code> with only one arm, but this syntax isn’t particularly useful and could be replaced with a simpler <code class="language-plaintext highlighter-rouge">let</code> statement.</p>

<p>Now that you know where to use patterns and the difference between refutable and irrefutable patterns, let’s cover all the syntax we can use to create patterns.</p>

<h2 id="pattern-syntax">Pattern Syntax</h2>
<p>Throughout the book, you’ve seen examples of many kinds of patterns. In this section, we gather all the syntax valid in patterns and discuss why you might want to use each one.</p>

<h3 id="matching-literals">Matching Literals</h3>
<p>As you saw in Chapter 6, you can match patterns against literals directly. 
The following code gives some examples:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">match</span> <span class="n">x</span> <span class="p">{</span>
        <span class="mi">1</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"one"</span><span class="p">),</span>
        <span class="mi">2</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"two"</span><span class="p">),</span>
        <span class="mi">3</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"three"</span><span class="p">),</span>
        <span class="mi">_</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"anything"</span><span class="p">),</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>This code prints <code class="language-plaintext highlighter-rouge">one</code> because the value in <code class="language-plaintext highlighter-rouge">x</code> is <code class="language-plaintext highlighter-rouge">1</code>. 
This syntax is useful when you want your code to take an action if it gets a particular concrete value.</p>

<h3 id="matching-named-variables">Matching Named Variables</h3>
<p>Named variables are <strong>irrefutable</strong> patterns that match any value, and we’ve used them many times in the book. 
However, there is a complication when you use named variables in <code class="language-plaintext highlighter-rouge">match</code> expressions. 
Because <code class="language-plaintext highlighter-rouge">match</code> starts a new scope, variables declared as part of a pattern inside the <code class="language-plaintext highlighter-rouge">match</code> expression will shadow those with the same name outside the <code class="language-plaintext highlighter-rouge">match</code> construct, as is the case with all variables. 
In Listing 18-11, we declare a variable named <code class="language-plaintext highlighter-rouge">x</code> with the value <code class="language-plaintext highlighter-rouge">Some(5)</code> and a variable <code class="language-plaintext highlighter-rouge">y</code> with the value <code class="language-plaintext highlighter-rouge">10</code>. 
We then create a <code class="language-plaintext highlighter-rouge">match</code> expression on the value <code class="language-plaintext highlighter-rouge">x</code>. 
Look at the patterns in the match arms and <code class="language-plaintext highlighter-rouge">println!</code> at the end, and try to figure out what the code will print before running this code or reading further.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Filename: src/main.rs</span>

    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="k">match</span> <span class="n">x</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Got 50"</span><span class="p">),</span>
        <span class="nf">Some</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Matched, y = {:?}"</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span>
        <span class="mi">_</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Default case, x = {:?}"</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"at the end: x = {:?}, y = {:?}"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</code></pre></div></div>
<h4 id="listing-18-11-a-match-expression-with-an-arm-that-introduces-a-shadowed-variable-y">Listing 18-11: A match expression with an arm that introduces a shadowed variable y</h4>

<p>Let’s walk through what happens when the <code class="language-plaintext highlighter-rouge">match</code> expression runs. 
The pattern in the first match arm doesn’t match the defined value of <code class="language-plaintext highlighter-rouge">x</code>, so the code continues.</p>

<p>The pattern in the second match arm introduces a new variable named <code class="language-plaintext highlighter-rouge">y</code> that will match any value inside a <code class="language-plaintext highlighter-rouge">Some</code> value. 
Because we’re in a new scope inside the <code class="language-plaintext highlighter-rouge">match</code> expression, this is a <strong>new</strong> <code class="language-plaintext highlighter-rouge">y</code> variable, not the <code class="language-plaintext highlighter-rouge">y</code> we declared at the beginning with the value 10. 
This new <code class="language-plaintext highlighter-rouge">y</code> binding will match any value inside a <code class="language-plaintext highlighter-rouge">Some</code>, which is what we have in <code class="language-plaintext highlighter-rouge">x</code>. 
Therefore, this new <code class="language-plaintext highlighter-rouge">y</code> binds to the inner value of the <code class="language-plaintext highlighter-rouge">Some</code> in <code class="language-plaintext highlighter-rouge">x</code>. 
That value is <code class="language-plaintext highlighter-rouge">5</code>, so the expression for that arm executes and prints <code class="language-plaintext highlighter-rouge">Matched, y = 5</code>.</p>

<p>If <code class="language-plaintext highlighter-rouge">x</code> had been a <code class="language-plaintext highlighter-rouge">None</code> value instead of <code class="language-plaintext highlighter-rouge">Some(5)</code>, the patterns in the first two arms wouldn’t have matched, so the value would have matched to the underscore. 
We didn’t introduce the <code class="language-plaintext highlighter-rouge">x</code> variable in the pattern of the underscore arm, so the <code class="language-plaintext highlighter-rouge">x</code> in the expression is still the <em>outer</em> <code class="language-plaintext highlighter-rouge">x</code> that hasn’t been shadowed. 
In this hypothetical case, the <code class="language-plaintext highlighter-rouge">match</code> would print <code class="language-plaintext highlighter-rouge">Default case, x = None</code>.</p>

<p>When the <code class="language-plaintext highlighter-rouge">match</code> expression is done, its scope ends, and so does the scope of the inner <code class="language-plaintext highlighter-rouge">y</code>. 
The last <code class="language-plaintext highlighter-rouge">println!</code> produces <code class="language-plaintext highlighter-rouge">at the end: x = Some(5), y = 10</code>.</p>

<p>To create a <code class="language-plaintext highlighter-rouge">match</code> expression that compares the values of the outer <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code>, rather than introducing a shadowed variable, we would need to use a match guard conditional instead. We’ll talk about match guards later in the “Extra Conditionals with Match Guards” section.</p>

<h3 id="multiple-patterns">Multiple Patterns</h3>
<p>In <code class="language-plaintext highlighter-rouge">match</code> expressions, you can match multiple patterns using the <code class="language-plaintext highlighter-rouge">|</code> syntax, which means <em>or</em>. 
For example, the following code matches the value of <code class="language-plaintext highlighter-rouge">x</code> against the match arms, the first of which has an <em>or</em> option, meaning if the value of <code class="language-plaintext highlighter-rouge">x</code> matches either of the values in that arm, that arm’s code will run:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">match</span> <span class="n">x</span> <span class="p">{</span>
        <span class="mi">1</span> <span class="p">|</span> <span class="mi">2</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"one or two"</span><span class="p">),</span>
        <span class="mi">3</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"three"</span><span class="p">),</span>
        <span class="mi">_</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"anything"</span><span class="p">),</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>This code prints <code class="language-plaintext highlighter-rouge">one or two</code>.</p>

<h3 id="matching-ranges-of-values-with-">Matching Ranges of Values with ..=</h3>
<p>The <code class="language-plaintext highlighter-rouge">..=</code> syntax allows us to match to an inclusive range of values. 
In the following code, when a pattern matches any of the values within the range, that arm will execute:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="k">match</span> <span class="n">x</span> <span class="p">{</span>
        <span class="mi">1</span><span class="o">..=</span><span class="mi">5</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"one through five"</span><span class="p">),</span>
        <span class="mi">_</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"something else"</span><span class="p">),</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>If <code class="language-plaintext highlighter-rouge">x</code> is 1, 2, 3, 4, or 5, the first arm will match. 
This syntax is more convenient than using the <code class="language-plaintext highlighter-rouge">|</code> operator to express the same idea; instead of <code class="language-plaintext highlighter-rouge">1..=5</code>, we would have to specify <code class="language-plaintext highlighter-rouge">1 | 2 | 3 | 4 | 5</code> if we used <code class="language-plaintext highlighter-rouge">|</code>. Specifying a range is much shorter, especially if we want to match, say, any number between 1 and 1,000!</p>

<p>Ranges are only allowed with numeric values or <code class="language-plaintext highlighter-rouge">char</code> values, because the compiler checks that the range isn’t empty at compile time. 
The only types for which Rust can tell if a range is empty or not are <code class="language-plaintext highlighter-rouge">char</code> and numeric values.</p>

<p>Here is an example using ranges of <code class="language-plaintext highlighter-rouge">char</code> values:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="sc">'c'</span><span class="p">;</span>

    <span class="k">match</span> <span class="n">x</span> <span class="p">{</span>
        <span class="sc">'a'</span><span class="o">..=</span><span class="sc">'j'</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"early ASCII letter"</span><span class="p">),</span>
        <span class="sc">'k'</span><span class="o">..=</span><span class="sc">'z'</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"late ASCII letter"</span><span class="p">),</span>
        <span class="mi">_</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"something else"</span><span class="p">),</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>Rust can tell that <code class="language-plaintext highlighter-rouge">c</code> is within the first pattern’s range and prints <code class="language-plaintext highlighter-rouge">early ASCII letter</code>.</p>

<h3 id="destructuring-to-break-apart-values">Destructuring to Break Apart Values</h3>
<p>We can also use patterns to destructure structs, enums, tuples, and references to use different parts of these values. Let’s walk through each value.</p>

<h3 id="destructuring-structs">Destructuring Structs</h3>
<p>Listing 18-12 shows a <code class="language-plaintext highlighter-rouge">Point</code> struct with two fields, <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code>, that we can break apart using a pattern with a <code class="language-plaintext highlighter-rouge">let</code> statement.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Filename: src/main.rs</span>

<span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">7</span> <span class="p">};</span>

    <span class="k">let</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">b</span> <span class="p">}</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-18-12-destructuring-a-structs-fields-into-separate-variables">Listing 18-12: Destructuring a struct’s fields into separate variables</h4>

<p>This code creates the variables <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> that match the values of the <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> fields of the p struct. 
This example shows that the names of the variables in the pattern don’t have to match the field names of the struct. 
But it’s common to want the variable names to match the field names to make it easier to remember which variables came from which fields.</p>

<p>Because having variable names match the fields is common and because writing <code class="language-plaintext highlighter-rouge">let Point { x: x, y: y } = p;</code> contains a lot of duplication, there is a shorthand for patterns that match struct fields: you only need to list the name of the struct field, and the variables created from the pattern will have the same names. 
Listing 18-13 shows code that behaves in the same way as the code in Listing 18-12, but the variables created in the <code class="language-plaintext highlighter-rouge">let</code> pattern are <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> instead of <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Filename: src/main.rs</span>

<span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">7</span> <span class="p">};</span>

    <span class="k">let</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">}</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-18-13-destructuring-struct-fields-using-struct-field-shorthand">Listing 18-13: Destructuring struct fields using struct field shorthand</h4>

<p>This code creates the variables <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> that match the <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> fields of the <code class="language-plaintext highlighter-rouge">p</code> variable. 
The outcome is that the variables x and y contain the values from the p struct.</p>

<p>We can also destructure with literal values as part of the struct pattern rather than creating variables for all the fields. 
Doing so allows us to test some of the fields for particular values while creating variables to destructure the other fields.</p>

<p>Listing 18-14 shows a <code class="language-plaintext highlighter-rouge">match</code> expression that separates <code class="language-plaintext highlighter-rouge">Point</code> values into three cases: points that lie directly on the <code class="language-plaintext highlighter-rouge">x</code> axis (which is true when <code class="language-plaintext highlighter-rouge">y = 0</code>), on the <code class="language-plaintext highlighter-rouge">y</code> axis (<code class="language-plaintext highlighter-rouge">x = 0</code>), or neither.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Filename: src/main.rs</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">7</span> <span class="p">};</span>

    <span class="k">match</span> <span class="n">p</span> <span class="p">{</span>
        <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">0</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"On the x axis at {}"</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span>
        <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"On the y axis at {}"</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span>
        <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"On neither axis: ({}, {})"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-18-14-destructuring-and-matching-literal-values-in-one-pattern">Listing 18-14: Destructuring and matching literal values in one pattern</h4>

<p>The first arm will match any point that lies on the <code class="language-plaintext highlighter-rouge">x</code> axis by specifying that the <code class="language-plaintext highlighter-rouge">y</code> field matches if its value matches the literal <code class="language-plaintext highlighter-rouge">0</code>. 
The pattern still creates an <code class="language-plaintext highlighter-rouge">x</code> variable that we can use in the code for this arm.</p>

<p>Similarly, the second arm matches any point on the <code class="language-plaintext highlighter-rouge">y</code> axis by specifying that the <code class="language-plaintext highlighter-rouge">x</code> field matches if its value is <code class="language-plaintext highlighter-rouge">0</code> and creates a variable <code class="language-plaintext highlighter-rouge">y</code> for the value of the <code class="language-plaintext highlighter-rouge">y</code> field. 
The third arm doesn’t specify any literals, so it matches any other <code class="language-plaintext highlighter-rouge">Point</code> and creates variables for both the <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> fields.</p>

<p>In this example, the value <code class="language-plaintext highlighter-rouge">p</code> matches the second arm by virtue of <code class="language-plaintext highlighter-rouge">x</code> containing a 0, so this code will print <code class="language-plaintext highlighter-rouge">On the y axis at 7</code>.</p>

<h3 id="destructuring-enums">Destructuring Enums</h3>
<p>We’ve destructured enums earlier in this book, for example, when we destructured <code class="language-plaintext highlighter-rouge">Option&lt;i32&gt;</code> in Listing 6-5 in Chapter 6. 
One detail we haven’t mentioned explicitly is that the pattern to destructure an enum should correspond to the way the data stored within the enum is defined. 
As an example, in Listing 18-15 we use the <code class="language-plaintext highlighter-rouge">Message</code> enum from Listing 6-2 and write a <code class="language-plaintext highlighter-rouge">match</code> with patterns that will destructure each inner value.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Filename: src/main.rs</span>

<span class="k">enum</span> <span class="n">Message</span> <span class="p">{</span>
    <span class="n">Quit</span><span class="p">,</span>
    <span class="n">Move</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">i32</span> <span class="p">},</span>
    <span class="nf">Write</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
    <span class="nf">ChangeColor</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">msg</span> <span class="o">=</span> <span class="nn">Message</span><span class="p">::</span><span class="nf">ChangeColor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>

    <span class="k">match</span> <span class="n">msg</span> <span class="p">{</span>
        <span class="nn">Message</span><span class="p">::</span><span class="n">Quit</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"The Quit variant has no data to destructure."</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nn">Message</span><span class="p">::</span><span class="n">Move</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span>
                <span class="s">"Move in the x direction {} and in the y direction {}"</span><span class="p">,</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
            <span class="p">);</span>
        <span class="p">}</span>
        <span class="nn">Message</span><span class="p">::</span><span class="nf">Write</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Text message: {}"</span><span class="p">,</span> <span class="n">text</span><span class="p">),</span>
        <span class="nn">Message</span><span class="p">::</span><span class="nf">ChangeColor</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"Change the color to red {}, green {}, and blue {}"</span><span class="p">,</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span>
        <span class="p">),</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-18-15-destructuring-enum-variants-that-hold-different-kinds-of-values">Listing 18-15: Destructuring enum variants that hold different kinds of values</h4>

<p>This code will print <code class="language-plaintext highlighter-rouge">Change the color to red 0, green 160, and blue 255</code>. 
Try changing the value of <code class="language-plaintext highlighter-rouge">msg</code> to see the code from the other arms run.</p>

<p>For enum variants without any data, like <code class="language-plaintext highlighter-rouge">Message::Quit</code>, we can’t destructure the value any further. We can only match on the literal <code class="language-plaintext highlighter-rouge">Message::Quit</code> value, and no variables are in that pattern.</p>

<p>For struct-like enum variants, such as <code class="language-plaintext highlighter-rouge">Message::Move</code>, we can use a pattern similar to the pattern we specify to match structs. After the variant name, we place curly brackets and then list the fields with variables so we break apart the pieces to use in the code for this arm. Here we use the shorthand form as we did in Listing 18-13.</p>

<p>For tuple-like enum variants, like <code class="language-plaintext highlighter-rouge">Message::Write</code> that holds a tuple with one element and <code class="language-plaintext highlighter-rouge">Message::ChangeColor</code> that holds a tuple with three elements, the pattern is similar to the pattern we specify to match tuples. The number of variables in the pattern must match the number of elements in the variant we’re matching.</p>

<h3 id="destructuring-nested-structs-and-enums">Destructuring Nested Structs and Enums</h3>
<p>Until now, all our examples have been matching structs or enums that were one level deep. 
Matching can work on nested items too!</p>

<p>For example, we can refactor the code in Listing 18-15 to support RGB and HSV colors in the ChangeColor message, as shown in Listing 18-16.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Color</span> <span class="p">{</span>
    <span class="nf">Rgb</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">),</span>
    <span class="nf">Hsv</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">Message</span> <span class="p">{</span>
    <span class="n">Quit</span><span class="p">,</span>
    <span class="n">Move</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">i32</span> <span class="p">},</span>
    <span class="nf">Write</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
    <span class="nf">ChangeColor</span><span class="p">(</span><span class="n">Color</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">msg</span> <span class="o">=</span> <span class="nn">Message</span><span class="p">::</span><span class="nf">ChangeColor</span><span class="p">(</span><span class="nn">Color</span><span class="p">::</span><span class="nf">Hsv</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">255</span><span class="p">));</span>

    <span class="k">match</span> <span class="n">msg</span> <span class="p">{</span>
        <span class="nn">Message</span><span class="p">::</span><span class="nf">ChangeColor</span><span class="p">(</span><span class="nn">Color</span><span class="p">::</span><span class="nf">Rgb</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"Change the color to red {}, green {}, and blue {}"</span><span class="p">,</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span>
        <span class="p">),</span>
        <span class="nn">Message</span><span class="p">::</span><span class="nf">ChangeColor</span><span class="p">(</span><span class="nn">Color</span><span class="p">::</span><span class="nf">Hsv</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"Change the color to hue {}, saturation {}, and value {}"</span><span class="p">,</span>
            <span class="n">h</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span>
        <span class="p">),</span>
        <span class="mi">_</span> <span class="k">=&gt;</span> <span class="p">(),</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-18-16-matching-on-nested-enums">Listing 18-16: Matching on nested enums</h4>

<p>The pattern of the first arm in the match expression matches a <code class="language-plaintext highlighter-rouge">Message::ChangeColor</code> enum variant that contains a <code class="language-plaintext highlighter-rouge">Color::Rgb</code> variant; then the pattern binds to the three inner <code class="language-plaintext highlighter-rouge">i32</code> values. 
The pattern of the second arm also matches a <code class="language-plaintext highlighter-rouge">Message::ChangeColor</code> enum variant, but the inner enum matches the <code class="language-plaintext highlighter-rouge">Color::Hsv</code> variant instead. 
We can specify these complex conditions in one <code class="language-plaintext highlighter-rouge">match</code> expression, even though two enums are involved.</p>

<h3 id="destructuring-structs-and-tuples">Destructuring Structs and Tuples</h3>
<p>We can mix, match, and nest destructuring patterns in even more complex ways. 
The following example shows a complicated destructure where we nest structs and tuples inside a tuple and destructure all the primitive values out:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="p">((</span><span class="n">feet</span><span class="p">,</span> <span class="n">inches</span><span class="p">),</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">})</span> <span class="o">=</span> <span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">-</span><span class="mi">10</span> <span class="p">});</span>
</code></pre></div></div>
<p>This code lets us break complex types into their component parts so we can use the values we’re interested in separately.</p>

<p>Destructuring with patterns is a convenient way to use pieces of values, such as the value from each field in a struct, separately from each other.</p>

<h3 id="ignoring-values-in-a-pattern">Ignoring Values in a Pattern</h3>
<p>You’ve seen that it’s sometimes useful to ignore values in a pattern, such as in the last arm of a <code class="language-plaintext highlighter-rouge">match</code>, to get a catchall that doesn’t actually do anything but does account for all remaining possible values. 
There are a few ways to ignore entire values or parts of values in a pattern: using the <code class="language-plaintext highlighter-rouge">_</code> pattern (which you’ve seen), using the <code class="language-plaintext highlighter-rouge">_</code> pattern within another pattern, using a name that starts with an underscore, or using <code class="language-plaintext highlighter-rouge">..</code> to ignore remaining parts of a value. Let’s explore how and why to use each of these patterns.</p>

<h3 id="ignoring-an-entire-value-with-_">Ignoring an Entire Value with _</h3>
<p>We’ve used the underscore (<code class="language-plaintext highlighter-rouge">_</code>) as a wildcard pattern that will match any value but not bind to the value. 
Although the underscore <code class="language-plaintext highlighter-rouge">_</code> pattern is especially useful as the last arm in a <code class="language-plaintext highlighter-rouge">match</code> expression, we can use it in any pattern, including function parameters, as shown in Listing 18-17.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Filename: src/main.rs</span>

<span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="mi">_</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"This code only uses the y parameter: {}"</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">foo</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-18-17-using-_-in-a-function-signature">Listing 18-17: Using _ in a function signature</h4>

<p>This code will completely ignore the value passed as the first argument, <code class="language-plaintext highlighter-rouge">3</code>, and will print <code class="language-plaintext highlighter-rouge">This code only uses the y parameter: 4</code>.</p>

<p>In most cases when you no longer need a particular function parameter, you would change the signature so it doesn’t include the unused parameter. 
Ignoring a function parameter can be especially useful in some cases, for example, when implementing a trait when you need a certain type signature but the function body in your implementation doesn’t need one of the parameters. 
The compiler will then not warn about unused function parameters, as it would if you used a name instead.</p>

<h3 id="ignoring-parts-of-a-value-with-a-nested-_">Ignoring Parts of a Value with a Nested _</h3>
<p>We can also use <code class="language-plaintext highlighter-rouge">_</code> inside another pattern to ignore just part of a value, for example, when we want to test for only part of a value but have no use for the other parts in the corresponding code we want to run. 
Listing 18-18 shows code responsible for managing a setting’s value. 
The business requirements are that the user should not be allowed to overwrite an existing customization of a setting but can unset the setting and give it a value if it is currently unset.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="k">mut</span> <span class="n">setting_value</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">new_setting_value</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="k">match</span> <span class="p">(</span><span class="n">setting_value</span><span class="p">,</span> <span class="n">new_setting_value</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="mi">_</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Can't overwrite an existing customized value"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="mi">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="n">setting_value</span> <span class="o">=</span> <span class="n">new_setting_value</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"setting is {:?}"</span><span class="p">,</span> <span class="n">setting_value</span><span class="p">);</span>
</code></pre></div></div>
<h4 id="listing-18-18-using-an-underscore-within-patterns-that-match-some-variants-when-we-dont-need-to-use-the-value-inside-the-some">Listing 18-18: Using an underscore within patterns that match Some variants when we don’t need to use the value inside the Some</h4>

<p>This code will print <code class="language-plaintext highlighter-rouge">Can't overwrite an existing customized value</code> and then <code class="language-plaintext highlighter-rouge">setting is Some(5)</code>. 
In the first match arm, we don’t need to match on or use the values inside either <code class="language-plaintext highlighter-rouge">Some</code> variant, but we do need to test for the case when <code class="language-plaintext highlighter-rouge">setting_value</code> and <code class="language-plaintext highlighter-rouge">new_setting_value</code> are the <code class="language-plaintext highlighter-rouge">Some</code> variant. 
In that case, we print why we’re not changing <code class="language-plaintext highlighter-rouge">setting_value</code>, and it doesn’t get changed.</p>

<p>In all other cases (if either <code class="language-plaintext highlighter-rouge">setting_value</code> or <code class="language-plaintext highlighter-rouge">new_setting_value</code> are <code class="language-plaintext highlighter-rouge">None</code>) expressed by the <code class="language-plaintext highlighter-rouge">_</code> pattern in the second arm, we want to allow <code class="language-plaintext highlighter-rouge">new_setting_value</code> to become <code class="language-plaintext highlighter-rouge">setting_value</code>.</p>

<p>We can also use underscores in multiple places within one pattern to ignore particular values. 
Listing 18-19 shows an example of ignoring the second and fourth values in a tuple of five items.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>

    <span class="k">match</span> <span class="n">numbers</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="mi">_</span><span class="p">,</span> <span class="n">third</span><span class="p">,</span> <span class="mi">_</span><span class="p">,</span> <span class="n">fifth</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Some numbers: {}, {}, {}"</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">third</span><span class="p">,</span> <span class="n">fifth</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-18-19-ignoring-multiple-parts-of-a-tuple">Listing 18-19: Ignoring multiple parts of a tuple</h4>

<p>This code will print <code class="language-plaintext highlighter-rouge">Some numbers: 2, 8, 32</code>, and the values 4 and 16 will be ignored.</p>

<h3 id="ignoring-an-unused-variable-by-starting-its-name-with-_">Ignoring an Unused Variable by Starting Its Name with _</h3>
<p>If you create a variable but don’t use it anywhere, Rust will usually issue a warning because that could be a bug. 
But sometimes it’s useful to create a variable you won’t use yet, such as when you’re prototyping or just starting a project. 
In this situation, you can tell Rust not to warn you about the unused variable by starting the name of the variable with an underscore. 
In Listing 18-20, we create two unused variables, but when we run this code, we should only get a warning about one of them.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Filename: src/main.rs</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="mi">_</span><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-18-20-starting-a-variable-name-with-an-underscore-to-avoid-getting-unused-variable-warnings">Listing 18-20: Starting a variable name with an underscore to avoid getting unused variable warnings</h4>

<p>Here we get a warning about not using the variable <code class="language-plaintext highlighter-rouge">y</code>, but we don’t get a warning about not using the variable preceded by the underscore.</p>

<p>Note that there is a subtle difference between using only <code class="language-plaintext highlighter-rouge">_</code> and using a name that starts with an underscore. 
The syntax <code class="language-plaintext highlighter-rouge">_x</code> still binds the value to the variable, whereas <code class="language-plaintext highlighter-rouge">_</code> doesn’t bind at all. 
To show a case where this distinction matters, Listing 18-21 will provide us with an error.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Hello!"</span><span class="p">));</span>

    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">_</span><span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="n">s</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"found a string"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</code></pre></div></div>
<h4 id="listing-18-21-an-unused-variable-starting-with-an-underscore-still-binds-the-value-which-might-take-ownership-of-the-value">Listing 18-21: An unused variable starting with an underscore still binds the value, which might take ownership of the value</h4>

<p>We’ll receive an error because the <code class="language-plaintext highlighter-rouge">s</code> value will still be moved into <code class="language-plaintext highlighter-rouge">_s</code>, which prevents us from using <code class="language-plaintext highlighter-rouge">s</code> again. 
However, using the underscore by itself doesn’t ever bind to the value. 
Listing 18-22 will compile without any errors because <code class="language-plaintext highlighter-rouge">s</code> doesn’t get moved into <code class="language-plaintext highlighter-rouge">_</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Hello!"</span><span class="p">));</span>

    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">s</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"found a string"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</code></pre></div></div>
<h4 id="listing-18-22-using-an-underscore-does-not-bind-the-value">Listing 18-22: Using an underscore does not bind the value</h4>

<p>This code works just fine because we never bind <code class="language-plaintext highlighter-rouge">s</code> to anything; it isn’t moved.</p>

<h3 id="ignoring-remaining-parts-of-a-value-with-">Ignoring Remaining Parts of a Value with ..</h3>
<p>With values that have many parts, we can use the <code class="language-plaintext highlighter-rouge">..</code> syntax to use only a few parts and ignore the rest, avoiding the need to list underscores for each ignored value. 
The <code class="language-plaintext highlighter-rouge">..</code> pattern ignores any parts of a value that we haven’t explicitly matched in the rest of the pattern. 
In Listing 18-23, we have a <code class="language-plaintext highlighter-rouge">Point</code> struct that holds a coordinate in three-dimensional space. 
In the match expression, we want to operate only on the <code class="language-plaintext highlighter-rouge">x</code> coordinate and ignore the values in the <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code> fields.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
        <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
        <span class="n">y</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
        <span class="n">z</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">origin</span> <span class="o">=</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="mi">0</span> <span class="p">};</span>

    <span class="k">match</span> <span class="n">origin</span> <span class="p">{</span>
        <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"x is {}"</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span>
    <span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-18-23-ignoring-all-fields-of-a-point-except-for-x-by-using-">Listing 18-23: Ignoring all fields of a Point except for x by using ..</h4>

<p>We list the <code class="language-plaintext highlighter-rouge">x</code> value and then just include the <code class="language-plaintext highlighter-rouge">..</code> pattern. 
This is quicker than having to list <code class="language-plaintext highlighter-rouge">y: _</code> and <code class="language-plaintext highlighter-rouge">z: _</code>, particularly when we’re working with structs that have lots of fields in situations where only one or two fields are relevant.</p>

<p>The syntax <code class="language-plaintext highlighter-rouge">..</code> will expand to as many values as it needs to be. 
Listing 18-24 shows how to use <code class="language-plaintext highlighter-rouge">..</code> with a tuple.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Filename: src/main.rs</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>

    <span class="k">match</span> <span class="n">numbers</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="o">..</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Some numbers: {}, {}"</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-18-24-matching-only-the-first-and-last-values-in-a-tuple-and-ignoring-all-other-values">Listing 18-24: Matching only the first and last values in a tuple and ignoring all other values</h4>

<p>In this code, the first and last value are matched with <code class="language-plaintext highlighter-rouge">first</code> and <code class="language-plaintext highlighter-rouge">last</code>. 
The <code class="language-plaintext highlighter-rouge">..</code> will match and ignore everything in the middle.</p>

<p>However, using <code class="language-plaintext highlighter-rouge">..</code> must be unambiguous. 
If it is unclear which values are intended for matching and which should be ignored, Rust will give us an error. 
Listing 18-25 shows an example of using .. ambiguously, so it will not compile.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Filename: src/main.rs</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>

    <span class="k">match</span> <span class="n">numbers</span> <span class="p">{</span>
        <span class="p">(</span><span class="o">..</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="o">..</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Some numbers: {}"</span><span class="p">,</span> <span class="n">second</span><span class="p">)</span>
        <span class="p">},</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-18-25-an-attempt-to-use--in-an-ambiguous-way">Listing 18-25: An attempt to use .. in an ambiguous way</h4>

<p>When we compile this example, we get this error:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="n">patterns</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="c">///projects/patterns)</span>
<span class="n">error</span><span class="p">:</span> <span class="err">`</span><span class="o">..</span><span class="err">`</span> <span class="n">can</span> <span class="n">only</span> <span class="n">be</span> <span class="n">used</span> <span class="n">once</span> <span class="n">per</span> <span class="n">tuple</span> <span class="n">pattern</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span><span class="mi">22</span>
  <span class="p">|</span>
<span class="mi">5</span> <span class="p">|</span>         <span class="p">(</span><span class="o">..</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="o">..</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
  <span class="p">|</span>          <span class="o">--</span>          <span class="o">^^</span> <span class="n">can</span> <span class="n">only</span> <span class="n">be</span> <span class="n">used</span> <span class="n">once</span> <span class="n">per</span> <span class="n">tuple</span> <span class="n">pattern</span>
  <span class="p">|</span>          <span class="p">|</span>
  <span class="p">|</span>          <span class="n">previously</span> <span class="n">used</span> <span class="n">here</span>

<span class="n">error</span><span class="p">:</span> <span class="n">aborting</span> <span class="n">due</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">error</span>

<span class="n">error</span><span class="p">:</span> <span class="n">could</span> <span class="n">not</span> <span class="n">compile</span> <span class="err">`</span><span class="n">patterns</span><span class="err">`</span><span class="py">.

To</span> <span class="n">learn</span> <span class="n">more</span><span class="p">,</span> <span class="n">run</span> <span class="n">the</span> <span class="n">command</span> <span class="n">again</span> <span class="n">with</span> <span class="o">--</span><span class="n">verbose</span><span class="err">.</span>
</code></pre></div></div>
<p>It’s impossible for Rust to determine how many values in the tuple to ignore before matching a value with <code class="language-plaintext highlighter-rouge">second</code> and then how many further values to ignore thereafter. 
This code could mean that we want to ignore <code class="language-plaintext highlighter-rouge">2</code>, bind second to <code class="language-plaintext highlighter-rouge">4</code>, and then ignore <code class="language-plaintext highlighter-rouge">8</code>, <code class="language-plaintext highlighter-rouge">16</code>, and <code class="language-plaintext highlighter-rouge">32</code>; or that we want to ignore <code class="language-plaintext highlighter-rouge">2</code> and <code class="language-plaintext highlighter-rouge">4</code>, bind second to <code class="language-plaintext highlighter-rouge">8</code>, and then ignore <code class="language-plaintext highlighter-rouge">16</code> and <code class="language-plaintext highlighter-rouge">32</code>; and so forth. 
The variable name <code class="language-plaintext highlighter-rouge">second</code> doesn’t mean anything special to Rust, so we get a compiler error because using <code class="language-plaintext highlighter-rouge">..</code> in two places like this is ambiguous.</p>

<h3 id="extra-conditionals-with-match-guards">Extra Conditionals with Match Guards</h3>
<p>A <em>match guard</em> is an additional <code class="language-plaintext highlighter-rouge">if</code> condition specified after the pattern in a <code class="language-plaintext highlighter-rouge">match</code> arm that must also match, along with the pattern matching, for that arm to be chosen. 
Match guards are useful for expressing more complex ideas than a pattern alone allows.</p>

<p>The condition can use variables created in the pattern. 
Listing 18-26 shows a <code class="language-plaintext highlighter-rouge">match</code> where the first arm has the pattern <code class="language-plaintext highlighter-rouge">Some(x)</code> and also has a match guard of <code class="language-plaintext highlighter-rouge">if x &lt; 5</code>.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="n">num</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>

    <span class="k">match</span> <span class="n">num</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"less than five: {}"</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span>
        <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span>
        <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">(),</span>
    <span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-18-26-adding-a-match-guard-to-a-pattern">Listing 18-26: Adding a match guard to a pattern</h4>

<p>This example will print <code class="language-plaintext highlighter-rouge">less than five: 4</code>. 
When <code class="language-plaintext highlighter-rouge">num</code> is compared to the pattern in the first arm, it matches, because <code class="language-plaintext highlighter-rouge">Some(4)</code> matches <code class="language-plaintext highlighter-rouge">Some(x)</code>. 
Then the match guard checks whether the value in <code class="language-plaintext highlighter-rouge">x</code> is less than <code class="language-plaintext highlighter-rouge">5</code>, and because it is, the first arm is selected.</p>

<p>If <code class="language-plaintext highlighter-rouge">num</code> had been <code class="language-plaintext highlighter-rouge">Some(10)</code> instead, the match guard in the first arm would have been <strong>false</strong> because 10 is not less than 5. 
Rust would then go to the second arm, which would match because the second arm doesn’t have a match guard and therefore matches any <code class="language-plaintext highlighter-rouge">Some</code> variant.</p>

<p>There is no way to express the <code class="language-plaintext highlighter-rouge">if x &lt; 5</code> condition within a pattern, so the match guard gives us the ability to express this logic.</p>

<p>In Listing 18-11, we mentioned that we could use match guards to solve our pattern-shadowing problem. 
Recall that a new variable was created inside the pattern in the <code class="language-plaintext highlighter-rouge">match</code> expression instead of using the variable outside the <code class="language-plaintext highlighter-rouge">match</code>. 
That new variable meant we couldn’t test against the value of the outer variable. Listing 18-27 shows how we can use a match guard to fix this problem.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Filename: src/main.rs</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="k">match</span> <span class="n">x</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Got 50"</span><span class="p">),</span>
        <span class="nf">Some</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">y</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Matched, n = {}"</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span>
        <span class="mi">_</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Default case, x = {:?}"</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"at the end: x = {:?}, y = {}"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-18-27-using-a-match-guard-to-test-for-equality-with-an-outer-variable">Listing 18-27: Using a match guard to test for equality with an outer variable</h4>

<p>This code will now print <code class="language-plaintext highlighter-rouge">Default case, x = Some(5)</code>. 
The pattern in the second match arm doesn’t introduce a new variable <code class="language-plaintext highlighter-rouge">y</code> that would shadow the outer <code class="language-plaintext highlighter-rouge">y</code>, meaning we can use the outer <code class="language-plaintext highlighter-rouge">y</code> in the match guard. 
Instead of specifying the pattern as <code class="language-plaintext highlighter-rouge">Some(y)</code>, which would have shadowed the outer <code class="language-plaintext highlighter-rouge">y</code>, we specify <code class="language-plaintext highlighter-rouge">Some(n)</code>. 
This creates a new variable n that doesn’t shadow anything because there is no <code class="language-plaintext highlighter-rouge">n</code> variable outside the <code class="language-plaintext highlighter-rouge">match</code>.</p>

<p>The match guard <code class="language-plaintext highlighter-rouge">if n == y</code> is not a pattern and therefore doesn’t introduce new variables. 
This <code class="language-plaintext highlighter-rouge">y</code> is the outer <code class="language-plaintext highlighter-rouge">y</code> rather than a new shadowed <code class="language-plaintext highlighter-rouge">y</code>, and we can look for a value that has the same value as the outer <code class="language-plaintext highlighter-rouge">y</code> by comparing <code class="language-plaintext highlighter-rouge">n</code> to <code class="language-plaintext highlighter-rouge">y</code>.</p>

<p>You can also use the <em>or</em> operator <code class="language-plaintext highlighter-rouge">|</code> in a match guard to specify multiple patterns; 
the match guard condition will apply to all the patterns. 
Listing 18-28 shows the precedence of combining a match guard with a pattern that uses <code class="language-plaintext highlighter-rouge">|</code>. 
The important part of this example is that the <code class="language-plaintext highlighter-rouge">if y</code> match guard applies to <code class="language-plaintext highlighter-rouge">4</code>, <code class="language-plaintext highlighter-rouge">5</code>, and <code class="language-plaintext highlighter-rouge">6</code>, even though it might look like <code class="language-plaintext highlighter-rouge">if y</code> only applies to <code class="language-plaintext highlighter-rouge">6</code>.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

    <span class="k">match</span> <span class="n">x</span> <span class="p">{</span>
        <span class="mi">4</span> <span class="p">|</span> <span class="mi">5</span> <span class="p">|</span> <span class="mi">6</span> <span class="k">if</span> <span class="n">y</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"yes"</span><span class="p">),</span>
        <span class="mi">_</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"no"</span><span class="p">),</span>
    <span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-18-28-combining-multiple-patterns-with-a-match-guard">Listing 18-28: Combining multiple patterns with a match guard</h4>

<p>The match condition states that the arm only matches if the value of <code class="language-plaintext highlighter-rouge">x</code> is equal to <code class="language-plaintext highlighter-rouge">4</code>, <code class="language-plaintext highlighter-rouge">5</code>, or <code class="language-plaintext highlighter-rouge">6</code> <em>and</em> if <code class="language-plaintext highlighter-rouge">y</code> is <code class="language-plaintext highlighter-rouge">true</code>. 
When this code runs, the pattern of the first arm matches because <code class="language-plaintext highlighter-rouge">x</code> is <code class="language-plaintext highlighter-rouge">4</code>, but the match guard if <code class="language-plaintext highlighter-rouge">y</code> is <code class="language-plaintext highlighter-rouge">false</code>, so the first arm is not chosen. 
The code moves on to the second arm, which does match, and this program prints <code class="language-plaintext highlighter-rouge">no</code>. 
The reason is that the if condition applies to the whole pattern <code class="language-plaintext highlighter-rouge">4 | 5 | 6</code>, not only to the last value <code class="language-plaintext highlighter-rouge">6</code>. 
In other words, the precedence of a match guard in relation to a pattern behaves like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(4 | 5 | 6) if y =&gt; ...
</code></pre></div></div>
<p>rather than this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>4 | 5 | (6 if y) =&gt; ...
</code></pre></div></div>
<p>After running the code, the precedence behavior is evident: if the match guard were applied only to the final value in the list of values specified using the <code class="language-plaintext highlighter-rouge">|</code> operator, the arm would have matched and the program would have printed <code class="language-plaintext highlighter-rouge">yes</code>.</p>

<h3 id="-bindings">@ Bindings</h3>
<p>The <code class="language-plaintext highlighter-rouge">at</code> operator (<code class="language-plaintext highlighter-rouge">@</code>) lets us create a variable that holds a value at the same time we’re testing that value to see whether it matches a pattern. 
Listing 18-29 shows an example where we want to test that a <code class="language-plaintext highlighter-rouge">Message::Hello</code> <code class="language-plaintext highlighter-rouge">id</code> field is within the range <code class="language-plaintext highlighter-rouge">3..=7</code>. 
But we also want to bind the value to the variable <code class="language-plaintext highlighter-rouge">id_variable</code> so we can use it in the code associated with the arm. 
We could name this variable <code class="language-plaintext highlighter-rouge">id</code>, the same as the field, but for this example we’ll use a different name.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">enum</span> <span class="n">Message</span> <span class="p">{</span>
        <span class="n">Hello</span> <span class="p">{</span> <span class="n">id</span><span class="p">:</span> <span class="nb">i32</span> <span class="p">},</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">msg</span> <span class="o">=</span> <span class="nn">Message</span><span class="p">::</span><span class="n">Hello</span> <span class="p">{</span> <span class="n">id</span><span class="p">:</span> <span class="mi">5</span> <span class="p">};</span>

    <span class="k">match</span> <span class="n">msg</span> <span class="p">{</span>
        <span class="nn">Message</span><span class="p">::</span><span class="n">Hello</span> <span class="p">{</span>
            <span class="n">id</span><span class="p">:</span> <span class="n">id_variable</span> <span class="o">@</span> <span class="mi">3</span><span class="o">..=</span><span class="mi">7</span><span class="p">,</span>
        <span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Found an id in range: {}"</span><span class="p">,</span> <span class="n">id_variable</span><span class="p">),</span>
        <span class="nn">Message</span><span class="p">::</span><span class="n">Hello</span> <span class="p">{</span> <span class="n">id</span><span class="p">:</span> <span class="mi">10</span><span class="o">..=</span><span class="mi">12</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Found an id in another range"</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nn">Message</span><span class="p">::</span><span class="n">Hello</span> <span class="p">{</span> <span class="n">id</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Found some other id: {}"</span><span class="p">,</span> <span class="n">id</span><span class="p">),</span>
    <span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-18-29-using--to-bind-to-a-value-in-a-pattern-while-also-testing-it">Listing 18-29: Using @ to bind to a value in a pattern while also testing it</h4>

<p>This example will print <code class="language-plaintext highlighter-rouge">Found an id in range: 5</code>. 
By specifying <code class="language-plaintext highlighter-rouge">id_variable @</code> before the range <code class="language-plaintext highlighter-rouge">3..=7</code>, we’re capturing whatever value matched the range while also testing that the value matched the range pattern.</p>

<p>In the second arm, where we only have a range specified in the pattern, the code associated with the arm doesn’t have a variable that contains the actual value of the <code class="language-plaintext highlighter-rouge">id</code> field. 
The <code class="language-plaintext highlighter-rouge">id</code> field’s value could have been 10, 11, or 12, but the code that goes with that pattern doesn’t know which it is. 
The pattern code isn’t able to use the value from the <code class="language-plaintext highlighter-rouge">id</code> field, because we haven’t saved the <code class="language-plaintext highlighter-rouge">id</code> value in a variable.</p>

<p>In the last arm, where we’ve specified a variable without a range, we do have the value available to use in the arm’s code in a variable named <code class="language-plaintext highlighter-rouge">id</code>. 
The reason is that we’ve used the struct field shorthand syntax. But we haven’t applied any test to the value in the id field in this arm, as we did with the first two arms: any value would match this pattern.</p>

<p>Using <code class="language-plaintext highlighter-rouge">@</code> lets us test a value and save it in a variable within one pattern.</p>

<h2 id="summary">Summary</h2>
<p>Rust’s patterns are <strong>very useful</strong> in that they help distinguish between different kinds of data. 
When used in <code class="language-plaintext highlighter-rouge">match</code> expressions, Rust ensures your patterns cover every possible value, or your program won’t compile. 
Patterns in <code class="language-plaintext highlighter-rouge">let</code> statements and function parameters make those constructs more useful, enabling the destructuring of values into smaller parts at the same time as assigning to variables. 
We can create simple or complex patterns to suit our needs.</p>

<p>Next, for the penultimate chapter of the book, we’ll look at some advanced aspects of a variety of Rust’s features.</p>

        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/" class="page__taxonomy-item" rel="tag">_</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#if-let" class="page__taxonomy-item" rel="tag">if let</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#match-guards" class="page__taxonomy-item" rel="tag">match guards</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#match" class="page__taxonomy-item" rel="tag">match</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#pattern" class="page__taxonomy-item" rel="tag">pattern</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#while-if" class="page__taxonomy-item" rel="tag">while if</a>
    
    </span>
  </p>




  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/categories/#rust-language" class="page__taxonomy-item" rel="tag">RUST Language</a>
    
    </span>
  </p>


        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2020-12-14T00:00:00+00:00">December 14, 2020</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?text=RUST+%3A+18.+Patterns+and+Matching%20https%3A%2F%2Fjjungs-lee.github.io%2F%2Frust%2F18.Patterns-and-Matching" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fjjungs-lee.github.io%2F%2Frust%2F18.Patterns-and-Matching" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fjjungs-lee.github.io%2F%2Frust%2F18.Patterns-and-Matching" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/rust/17.Object-Oriented-Programming-Features-of-Rust" class="pagination--pager" title="RUST : 17. Object Oriented Programming Features of Rust
">Previous</a>
    
    
      <a href="/rust/19.Advanced-Features" class="pagination--pager" title="RUST : 19. Advanced Features
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/vs%20code/VSCODE-Dev-set(Settings-Sync)/" rel="permalink">Dev Setting - Settings Sync
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">I have a trouble cuz the development settings at home and at work are different.
It’s so inconvenient. So I’m trying to use syncing up settings(vscode plugin...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/github%20pages/Github-actions/" rel="permalink">Github Actions: Setting for CI server
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  2 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">In the past, When distributing the homepage was using CI called travis.
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/github/Testing-for-local-server" rel="permalink">Github Pages: Testing for local server
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  2 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">Before committing to github pages, you can upload your homepage locally through ruby and jekyll serve!
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/Algorithm/algorithm-Sort" rel="permalink">Algorithm - SORT
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">```cpp
#include 
</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
      
        
      
        
          <li><a href="https://github.com/jjungs-lee" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
      
        
      
        
      
        
          <li><a href="https://www.linkedin.com/in/jjungs-lee" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
    

    <li><a href="NONE"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2021 JJungs-lee. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script src="https://kit.fontawesome.com/4eee35f757.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>







  </body>
</html>
