<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.17.2 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html -->

<!----><title>Yes! I Take IT :)</title>
<meta name="description" content="A struct, or structure, is a custom data type that lets you name and package together multiple related values that make up a meaningful group.">


  <meta name="author" content="JJungs-lee">


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Yes! I Take IT">
<meta property="og:title" content="RUST : 5. Using structs to structure related data">
<meta property="og:url" content="https://jjungs-lee.github.io//rust/5.Using-Structs-to-Structure-Related-Data">


  <meta property="og:description" content="A struct, or structure, is a custom data type that lets you name and package together multiple related values that make up a meaningful group.">







  <meta property="article:published_time" content="2020-02-26T00:00:00+00:00">





  

  


<link rel="canonical" href="https://jjungs-lee.github.io//rust/5.Using-Structs-to-Structure-Related-Data">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "JJungs-lee",
      "url": "https://jjungs-lee.github.io//"
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="NONE" type="application/atom+xml" rel="alternate" title="Yes! I Take IT Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          <b>I.T.I</b> <small>by JHLee</small>
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/posts/" >Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/kernel/" >Kernel</a>
            </li><li class="masthead__menu-item">
              <a href="/swim/" >Swim</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="/assets/images/author_jhl.png" alt="JJungs-lee" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">JJungs-lee</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>Do Coding! Do Study!</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Somewhere</span>
        </li>
      

      
        
          
        
          
        
          
        
          
        
          
            <li><a href="https://github.com/jjungs-lee" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
          
        
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="RUST : 5. Using structs to structure related data">
    <meta itemprop="description" content="A struct, or structure, is a custom data type that lets you name and package together multiple related values that make up a meaningful group.">
    <meta itemprop="datePublished" content="2020-02-26T00:00:00+00:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">RUST : 5. Using structs to structure related data
</h1>
          
            <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  19 minute read

</p>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
        <p>A struct, or structure, is a custom data type that lets you name and package together multiple related values that make up a meaningful group.</p>

<h2 id="defining-and-instantiating-structs">Defining and Instantiating Structs</h2>
<p>Structs are similar to tuples, which were discussed in Chapter 3. Like tuples, the pieces of a struct can be different types. Unlike with tuples, you’ll name each piece of data so it’s clear what the values mean. As a result of these names, structs are more flexible than tuples. <br />
To define a struct, we enter the keyword struct and name the entire struct</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">User</span> <span class="p">{</span>
    <span class="n">username</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">email</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">sign_in_count</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="n">active</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-5-1-a-user-struct-definition">Listing 5-1: A User struct definition</h4>

<p>To use a struct after we’ve defined it, we create an <em>instance</em> of that struct by specifying concrete values for each of the fields. 
We create an instance by stating the name of the struct and then add curly brackets containing <code class="language-plaintext highlighter-rouge">key: value</code> pairs, where the keys are the names of the fields and the values are the data we want to store in those fields. <strong>We don’t have to specify the fields in the same order in which we declared them in the struct.</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">user1</span> <span class="o">=</span> <span class="n">User</span> <span class="p">{</span>
    <span class="n">email</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"someone@example.com"</span><span class="p">),</span>
    <span class="n">username</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"someusername123"</span><span class="p">),</span>
    <span class="n">active</span><span class="p">:</span> <span class="k">true</span><span class="p">,</span>
    <span class="n">sign_in_count</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>
<h4 id="listing-5-2-creating-an-instance-of-the-user-struct">Listing 5-2: Creating an instance of the User struct</h4>

<p>To get a specific value from a struct, we can use <code class="language-plaintext highlighter-rouge">dot(.)</code> notation. If we wanted just this user’s email address, we could use <code class="language-plaintext highlighter-rouge">user1.email</code> wherever we wanted to use this value. If the instance is mutable, we can change a value by using the <code class="language-plaintext highlighter-rouge">dot(.)</code> notation and assigning into a particular field. Listing 5-3 shows how to change the value in the <code class="language-plaintext highlighter-rouge">email</code> field of a mutable <code class="language-plaintext highlighter-rouge">User</code> instance.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">user1</span> <span class="o">=</span> <span class="n">User</span> <span class="p">{</span>
    <span class="n">email</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"someone@example.com"</span><span class="p">),</span>
    <span class="n">username</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"someusername123"</span><span class="p">),</span>
    <span class="n">active</span><span class="p">:</span> <span class="k">true</span><span class="p">,</span>
    <span class="n">sign_in_count</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">user1</span><span class="py">.email</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"anotheremail@example.com"</span><span class="p">);</span>
</code></pre></div></div>
<h4 id="listing-5-3-changing-the-value-in-the-email-field-of-a-user-instance">Listing 5-3: Changing the value in the email field of a User instance</h4>

<p>Listing 5-4 shows a build_user function that returns a User instance with the given email and username. The active field gets the value of true, and the sign_in_count gets a value of 1.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// JHS) maybe this function similar constructor in C++</span>
<span class="k">fn</span> <span class="nf">build_user</span><span class="p">(</span><span class="n">email</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">username</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">User</span> <span class="p">{</span>
    <span class="n">User</span> <span class="p">{</span>
        <span class="n">email</span><span class="p">:</span> <span class="n">email</span><span class="p">,</span>
        <span class="n">username</span><span class="p">:</span> <span class="n">username</span><span class="p">,</span>
        <span class="n">active</span><span class="p">:</span> <span class="k">true</span><span class="p">,</span>
        <span class="n">sign_in_count</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-5-4-a-build_user-function-that-takes-an-email-and-username-and-returns-a-user-instance">Listing 5-4: A build_user function that takes an email and username and returns a User instance</h4>

<h3 id="using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name">Using the Field Init Shorthand when Variables and Fields Have the Same Name</h3>
<p>Because the parameter names and the struct field names are exactly the same in Listing 5-4, we can use the field init <strong>shorthand syntax</strong> to rewrite <code class="language-plaintext highlighter-rouge">build_user</code> so that it behaves exactly the same but doesn’t have the repetition of email and username, as shown in Listing 5-5.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">build_user</span><span class="p">(</span><span class="n">email</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">username</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">User</span> <span class="p">{</span>
    <span class="n">User</span> <span class="p">{</span>
        <span class="n">email</span><span class="p">,</span>
        <span class="n">username</span><span class="p">,</span>
        <span class="n">active</span><span class="p">:</span> <span class="k">true</span><span class="p">,</span>
        <span class="n">sign_in_count</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-5-5-a-build_user-function-that-uses-field-init-shorthand-because-the-email-and-username-parameters-have-the-same-name-as-struct-fields">Listing 5-5: A build_user function that uses field init shorthand because the email and username parameters have the same name as struct fields</h4>

<h3 id="creating-instances-from-other-instances-with-struct-update-syntax">Creating Instances From Other Instances With Struct Update Syntax</h3>
<p>It’s often useful to create a new instance of a struct that uses most of an old instance’s values but changes some. You’ll do this using <code class="language-plaintext highlighter-rouge">struct update syntax</code>.
First, Listing 5-6 shows how we create a new User instance in user2 without the update syntax. We set new values for email and username but otherwise use the same values from user1 that we created in Listing 5-2.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">user2</span> <span class="o">=</span> <span class="n">User</span> <span class="p">{</span>
    <span class="n">email</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"another@example.com"</span><span class="p">),</span>
    <span class="n">username</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"anotherusername567"</span><span class="p">),</span>
    <span class="n">active</span><span class="p">:</span> <span class="n">user1</span><span class="py">.active</span><span class="p">,</span>
    <span class="n">sign_in_count</span><span class="p">:</span> <span class="n">user1</span><span class="py">.sign_in_count</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>
<h4 id="listing-5-6-creating-a-new-user-instance-using-some-of-the-values-from-user1">Listing 5-6: Creating a new User instance using some of the values from user1</h4>
<p>Using <code class="language-plaintext highlighter-rouge">struct update syntax</code>, we can achieve the same effect with <strong>less code</strong>, as shown in Listing 5-7. The syntax <code class="language-plaintext highlighter-rouge">..</code> specifies that the remaining fields not explicitly set should <strong>have the same value</strong> as the fields in the given instance. The code in Listing 5-7 also creates an instance in <code class="language-plaintext highlighter-rouge">user2</code> that has a different value for email and username but has the same values for the active and sign_in_count fields from <code class="language-plaintext highlighter-rouge">user1</code>.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">user2</span> <span class="o">=</span> <span class="n">User</span> <span class="p">{</span>
    <span class="n">email</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"another@example.com"</span><span class="p">),</span>
    <span class="n">username</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"anotherusername567"</span><span class="p">),</span>
    <span class="o">..</span><span class="n">user1</span>
<span class="p">};</span>
</code></pre></div></div>
<h4 id="listing-5-7-using-struct-update-syntax-to-set-new-email-and-username-values-for-a-user-instance-but-use-the-rest-of-the-values-from-the-fields-of-the-instance-in-the-user1-variable">Listing 5-7: Using struct update syntax to set new email and username values for a User instance but use the rest of the values from the fields of the instance in the user1 variable</h4>

<h3 id="using-tuple-structs-without-named-fields-to-create-different-types">Using Tuple Structs without Named Fields to Create Different Types</h3>
<p>You can also define structs that look similar to tuples, called <code class="language-plaintext highlighter-rouge">tuple structs</code>. Tuple structs have the <strong>added meaning the struct name provides</strong> but <strong>don’t have names associated with their fields</strong>; rather, they <strong>just have the types of the fields</strong>. Tuple structs are useful when you want to give the whole tuple a name and make the tuple be a different type from other tuples, and naming each field as in a regular struct would be verbose or redundant.</p>

<p>To define a tuple struct, start with the <code class="language-plaintext highlighter-rouge">struct</code> keyword and the struct name followed by the <code class="language-plaintext highlighter-rouge">types</code> in the tuple.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nf">Color</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">);</span>
<span class="k">struct</span> <span class="nf">Point</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">);</span>

<span class="k">let</span> <span class="n">black</span> <span class="o">=</span> <span class="nf">Color</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">let</span> <span class="n">origin</span> <span class="o">=</span> <span class="nf">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>
<p>Tuple struct instances behave like tuples: you can destructure them into their individual pieces, you can use a <code class="language-plaintext highlighter-rouge">.</code> followed by the index to access an individual value, and so on.</p>

<h3 id="unit-like-structs-without-any-fields">Unit-Like Structs Without Any Fields</h3>
<p>You can also define structs that don’t have any fields! These are called <code class="language-plaintext highlighter-rouge">unit-like structs</code> because they behave similarly to <code class="language-plaintext highlighter-rouge">()</code>, the unit type. Unit-like structs can be useful in situations in which you need to implement a trait on some type but don’t have any data that you want to store in the type itself. We’ll discuss traits in Chapter 10.</p>

<h3 id="ownership-of-struct-data">Ownership of Struct Data</h3>
<p class="notice--info">In the <code class="language-plaintext highlighter-rouge">User</code> struct definition in Listing 5-1, we used the owned <code class="language-plaintext highlighter-rouge">String</code> type rather than the <code class="language-plaintext highlighter-rouge">&amp;str</code> string slice type. This is a <strong>deliberate choice</strong> because we want instances of this struct to own all of its data and for that data to be valid for as long as the entire struct is valid.<br /><br />
It’s possible for structs to store references to data owned by something else, but to do so requires the use of <code class="language-plaintext highlighter-rouge">lifetimes</code>, a Rust feature that we’ll discuss in Chapter 10. Lifetimes ensure that the data referenced by a struct is valid for as long as the struct is. 
Let’s say you try to store a reference in a struct without specifying lifetimes, like this, which won’t work:<br /><br />
In Chapter 10, we’ll discuss how to fix these errors so you can store references in structs, but for now, we’ll fix errors like these using owned types like String instead of references like &amp;str.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// This code does not compile!</span>
<span class="k">struct</span> <span class="n">User</span> <span class="p">{</span>
    <span class="n">username</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
    <span class="n">email</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
    <span class="n">sign_in_count</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="n">active</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">user1</span> <span class="o">=</span> <span class="n">User</span> <span class="p">{</span>
        <span class="n">email</span><span class="p">:</span> <span class="s">"someone@example.com"</span><span class="p">,</span>
        <span class="n">username</span><span class="p">:</span> <span class="s">"someusername123"</span><span class="p">,</span>
        <span class="n">active</span><span class="p">:</span> <span class="k">true</span><span class="p">,</span>
        <span class="n">sign_in_count</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="c">// The compiler will complain that it needs lifetime specifiers:</span>
<span class="n">error</span><span class="p">[</span><span class="n">E0106</span><span class="p">]:</span> <span class="n">missing</span> <span class="n">lifetime</span> <span class="n">specifier</span>
<span class="o">-</span><span class="k">-&gt;</span>
  <span class="p">|</span>
<span class="mi">2</span> <span class="p">|</span>     <span class="n">username</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
  <span class="p">|</span>               <span class="o">^</span> <span class="n">expected</span> <span class="n">lifetime</span> <span class="n">parameter</span>

<span class="n">error</span><span class="p">[</span><span class="n">E0106</span><span class="p">]:</span> <span class="n">missing</span> <span class="n">lifetime</span> <span class="n">specifier</span>
<span class="o">-</span><span class="k">-&gt;</span>
  <span class="p">|</span>
<span class="mi">3</span> <span class="p">|</span>     <span class="n">email</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
  <span class="p">|</span>            <span class="o">^</span> <span class="n">expected</span> <span class="n">lifetime</span> <span class="n">parameter</span>
</code></pre></div></div>

<h2 id="an-example-program-using-structs">An Example Program Using Structs</h2>
<p>Let’s write a program that calculates the area of a rectangle. We’ll start with single variables, and then refactor the program until we’re using structs instead.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">length1</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">width1</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"The area of the rectangle is {} square pixels."</span><span class="p">,</span>
        <span class="nf">area</span><span class="p">(</span><span class="n">length1</span><span class="p">,</span> <span class="n">width1</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">area</span><span class="p">(</span><span class="n">length</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="n">length</span> <span class="o">*</span> <span class="n">width</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-5-8-calculating-the-area-of-a-rectangle-specified-by-separate-width-and-height-variables">Listing 5-8: Calculating the area of a rectangle specified by separate width and height variables</h4>
<p>The issue with this code is evident in the signature of area:</p>

<p>Even though Listing 5-8 works and figures out the area of the rectangle by calling the area function with each dimension, we can do better.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">area</span><span class="p">(</span><span class="n">width</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">area</code> function is supposed to calculate the area of one rectangle, but the function we wrote has two parameters. The parameters are related, but that’s not expressed anywhere in our program. It would be more readable and more manageable to group width and height together. We’ve already discussed one way we might do that in “The Tuple Type” section of Chapter 3: <strong>by using tuples.</strong></p>

<h3 id="refactoring-with-tuples">Refactoring with Tuples</h3>
<p>Listing 5-9 shows another version of our program that uses tuples.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">rect1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"The area of the rectangle is {} square pixels."</span><span class="p">,</span>
        <span class="nf">area</span><span class="p">(</span><span class="n">rect1</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">area</span><span class="p">(</span><span class="n">dimensions</span><span class="p">:</span> <span class="p">(</span><span class="nb">u32</span><span class="p">,</span> <span class="nb">u32</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="n">dimensions</span><span class="err">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">dimensions</span><span class="err">.</span><span class="mi">1</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-5-9-specifying-the-width-and-height-of-the-rectangle-with-a-tuple">Listing 5-9: Specifying the width and height of the rectangle with a tuple</h4>
<p>In one way, this program is better. Tuples let us add a bit of structure, and we’re now passing just one argument. But in another way, this version is <strong>less clear</strong>: tuples don’t name their elements, so our calculation has become more confusing because we have to index into the parts of the tuple. <br />
It doesn’t matter if we mix up width and height for the area calculation, but if we want to draw the rectangle on the screen, it would matter! We would have to keep in mind that width is the tuple index 0 and height is the tuple index 1. If someone else worked on this code, they would have to figure this out and keep it in mind as well. It would be easy to forget or mix up these values and cause errors, because we haven’t conveyed the meaning of our data in our code.</p>

<h3 id="refactoring-with-structs-adding-more-meaning">Refactoring with Structs: Adding More Meaning</h3>
<p>We use structs to add meaning by labeling the data. We can transform the tuple we’re using into a data type with a name for the whole as well as names for the parts, as shown in Listing 5-10.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Rectangle</span> <span class="p">{</span>
    <span class="n">width</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">height</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">rect1</span> <span class="o">=</span> <span class="n">Rectangle</span> <span class="p">{</span> <span class="n">width</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mi">50</span> <span class="p">};</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"The area of the rectangle is {} square pixels."</span><span class="p">,</span>
        <span class="nf">area</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rect1</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">area</span><span class="p">(</span><span class="n">rectangle</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Rectangle</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="n">rectangle</span><span class="py">.width</span> <span class="o">*</span> <span class="n">rectangle</span><span class="py">.height</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-5-10-defining-a-rectangle-struct">Listing 5-10: Defining a Rectangle struct</h4>
<p>Here we’ve defined a struct and named it Rectangle. Inside the curly brackets, we defined the fields as width and height, both of which have type u32. Then in main, we created a particular instance of Rectangle that has a width of 30 and a height of 50.</p>

<p>Our <code class="language-plaintext highlighter-rouge">area</code> function is now defined with one parameter, which we’ve named <code class="language-plaintext highlighter-rouge">rectangle</code>, whose type is an immutable borrow of a struct Rectangle instance. As mentioned in Chapter 4, we want to <strong>borrow the struct rather than take ownership of it</strong>. This way, main retains its ownership and can continue using rect1, which is the reason we use the &amp; in the function signature and where we call the function.</p>

<p>The area function accesses the width and height fields of the Rectangle instance. Our function signature for area now says exactly what we mean: calculate the area of Rectangle, using its width and height fields. This conveys that the width and height are related to each other, and it gives descriptive names to the values rather than using the tuple index values of 0 and 1. This is a win for clarity.</p>

<h3 id="adding-useful-functionality-with-derived-traits">Adding Useful Functionality with Derived Traits</h3>
<p>It’d be nice to be able to print an instance of Rectangle while we’re debugging our program and see the values for all its fields. Listing 5-11 tries using the println! macro as we have used in previous chapters. This won’t work, however.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Rectangle</span> <span class="p">{</span>
    <span class="n">length</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">width</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">rect1</span> <span class="o">=</span> <span class="n">Rectangle</span> <span class="p">{</span> <span class="n">length</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="mi">30</span> <span class="p">};</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"rect1 is {}"</span><span class="p">,</span> <span class="n">rect1</span><span class="p">);</span>

    <span class="c">// When we compile this code, we get an error with this core message:</span>
    <span class="c">// error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-5-11-attempting-to-print-a-rectangle-instance">Listing 5-11: Attempting to print a Rectangle instance</h4>

<p>The <code class="language-plaintext highlighter-rouge">println!</code> macro can do many kinds of formatting, and by default, the <code class="language-plaintext highlighter-rouge">curly brackets</code> tell <code class="language-plaintext highlighter-rouge">println!</code> to use formatting known as <code class="language-plaintext highlighter-rouge">Display</code>: output intended for direct end user consumption. The primitive types we’ve seen so far implement Display by default, because there’s only one way you’d want to show a 1 or any other primitive type to a user. <strong>But with structs, the way println! should format the output is less clear because there are more display possibilities</strong>: Do you want commas or not? Do you want to print the curly brackets? Should all the fields be shown? Due to this ambiguity, Rust doesn’t try to guess what we want, and structs don’t have a provided implementation of Display.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">=</span> <span class="n">help</span><span class="p">:</span> <span class="n">the</span> <span class="k">trait</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span><span class="err">`</span> <span class="n">is</span> <span class="n">not</span> <span class="n">implemented</span> <span class="k">for</span> <span class="err">`</span><span class="n">Rectangle</span><span class="err">`</span>
<span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">in</span> <span class="n">format</span> <span class="n">strings</span> <span class="n">you</span> <span class="n">may</span> <span class="n">be</span> <span class="n">able</span> <span class="n">to</span> <span class="k">use</span> <span class="err">`</span><span class="p">{:</span><span class="o">?</span><span class="p">}</span><span class="err">`</span> 
        <span class="p">(</span><span class="n">or</span> <span class="p">{:</span><span class="err">#</span><span class="o">?</span><span class="p">}</span> <span class="k">for</span> <span class="n">pretty</span><span class="o">-</span><span class="n">print</span><span class="p">)</span> <span class="n">instead</span>
</code></pre></div></div>
<p>Let’s try it! The <code class="language-plaintext highlighter-rouge">println!</code> macro call will now look like <code class="language-plaintext highlighter-rouge">println!("rect1 is {:?}", rect1);</code>. Putting the specifier <code class="language-plaintext highlighter-rouge">:?</code> inside the curly brackets tells println! we want to use an output format called <code class="language-plaintext highlighter-rouge">Debug</code>. The <strong>Debug trait</strong> enables us to print our struct in a way that is useful for developers so we can see its value while we’re debugging our code. <br />
Compile the code with this change. Drat! We still get an error:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">error</span><span class="p">[</span><span class="n">E0277</span><span class="p">]:</span> <span class="err">`</span><span class="n">Rectangle</span><span class="err">`</span> <span class="n">doesn</span><span class="nv">'t</span> <span class="n">implement</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="err">`</span>
</code></pre></div></div>
<p>But again, the compiler gives us a helpful note:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">=</span> <span class="n">help</span><span class="p">:</span> <span class="n">the</span> <span class="k">trait</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="err">`</span> <span class="n">is</span> <span class="n">not</span> <span class="n">implemented</span> <span class="k">for</span> <span class="err">`</span><span class="n">Rectangle</span><span class="err">`</span>
<span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">add</span> <span class="err">`</span><span class="nd">#[derive(Debug)]</span><span class="err">`</span> <span class="n">or</span> <span class="n">manually</span> <span class="n">implement</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="err">`</span>
</code></pre></div></div>
<p>Rust does include functionality to print out debugging information, but we <strong>have to explicitly opt in to make that functionality available for our struct</strong>. To do that, we add the annotation <code class="language-plaintext highlighter-rouge">#[derive(Debug)]</code> just before the struct definition, as shown in Listing 5-12.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Rectangle</span> <span class="p">{</span>
    <span class="n">width</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">height</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">rect1</span> <span class="o">=</span> <span class="n">Rectangle</span> <span class="p">{</span> <span class="n">width</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mi">50</span> <span class="p">};</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"rect1 is {:?}"</span><span class="p">,</span> <span class="n">rect1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-5-12-adding-the-annotation-to-derive-the-debug-trait-and-printing-the-rectangle-instance-using-debug-formatting">Listing 5-12: Adding the annotation to derive the Debug trait and printing the Rectangle instance using debug formatting</h4>
<p>Now when we run the program, we won’t get any errors, and we’ll see the following output:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rect1</span> <span class="n">is</span> <span class="n">Rectangle</span> <span class="p">{</span> <span class="n">width</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mi">50</span> <span class="p">}</span>
</code></pre></div></div>

<p>Nice! It’s not the prettiest output, but it shows the values of all the fields for this instance, which would definitely help during debugging. When we have larger structs, it’s useful to have output that’s a bit easier to read; in those cases, we can use <code class="language-plaintext highlighter-rouge">{:#?}</code>** instead of <code class="language-plaintext highlighter-rouge">{:?}</code> in the println! string. When we use the <code class="language-plaintext highlighter-rouge">{:#?}</code> style in the example, the output will look like this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rect1</span> <span class="n">is</span> <span class="n">Rectangle</span> <span class="p">{</span>
    <span class="n">width</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">height</span><span class="p">:</span> <span class="mi">50</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Rust has provided a number of traits for us to use with the <code class="language-plaintext highlighter-rouge">derive</code> annotation that can add useful behavior to our custom types. Those traits and their behaviors are listed in Appendix C. We’ll cover how to implement these traits with custom behavior as well as how to create your own traits in Chapter 10.</p>

<p>Our <code class="language-plaintext highlighter-rouge">area</code> function is very specific: it only computes the area of rectangles. It would be helpful to tie this behavior more closely to our <code class="language-plaintext highlighter-rouge">Rectangle</code> struct, <strong>because it won’t work with any other type</strong>. Let’s look at how we can continue to refactor this code by turning the <code class="language-plaintext highlighter-rouge">area</code> function into an <code class="language-plaintext highlighter-rouge">area</code> method defined on our <code class="language-plaintext highlighter-rouge">Rectangle</code> type.</p>

<h2 id="method-syntax">Method Syntax</h2>
<p><em>Methods</em> are similar to functions: they’re declared with the <code class="language-plaintext highlighter-rouge">fn</code> keyword and their name, they can have parameters and a return value, and they contain some code that is run when they’re called from somewhere else. <strong>However, methods are different from functions in that they’re defined within the context of a struct</strong> (or an enum or a trait object, which we cover in Chapters 6 and 17, respectively), and their first parameter is always <code class="language-plaintext highlighter-rouge">self</code>, which represents the <strong>instance of the struct the method is being called on</strong>.</p>

<h3 id="defining-methods">Defining Methods</h3>
<p>Let’s change the area function that has a Rectangle instance as a parameter and instead make an area method defined on the Rectangle struct, as shown in Listing 5-13.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Rectangle</span> <span class="p">{</span>
    <span class="n">width</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">height</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Rectangle</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">area</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.width</span> <span class="o">*</span> <span class="k">self</span><span class="py">.height</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">rect1</span> <span class="o">=</span> <span class="n">Rectangle</span> <span class="p">{</span> <span class="n">width</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mi">50</span> <span class="p">};</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"The area of the rectangle is {} square pixels."</span><span class="p">,</span>
        <span class="n">rect1</span><span class="nf">.area</span><span class="p">()</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-5-13-defining-an-area-method-on-the-rectangle-struct">Listing 5-13: Defining an area method on the Rectangle struct</h4>
<p>To define the function within the context of <code class="language-plaintext highlighter-rouge">Rectangle</code>, we start an <code class="language-plaintext highlighter-rouge">impl</code> (implementation) block. Then we move the <code class="language-plaintext highlighter-rouge">area</code> function within the <code class="language-plaintext highlighter-rouge">impl</code> curly brackets and change the first (and in this case, only) parameter to be <code class="language-plaintext highlighter-rouge">self</code> in the signature and everywhere within the body. In main, where we called the area function and passed <code class="language-plaintext highlighter-rouge">rect1</code> as an argument, we can instead use <strong>method syntax</strong> to call the <code class="language-plaintext highlighter-rouge">area</code> method on our <code class="language-plaintext highlighter-rouge">Rectangle instance</code>. The <strong>method syntax</strong> goes after an instance: we add a <code class="language-plaintext highlighter-rouge">dot(.)</code> followed by the <strong>method name, parentheses, and any arguments</strong>.</p>

<p>In the signature for <code class="language-plaintext highlighter-rouge">area</code>, we use <code class="language-plaintext highlighter-rouge">&amp;self</code> instead of <code class="language-plaintext highlighter-rouge">rectangle: &amp;Rectangle</code> because Rust knows <strong>the type of self is Rectangle due to this method’s being inside the impl Rectangle context</strong>. Note that we still need to use the <code class="language-plaintext highlighter-rouge">&amp;</code> before <code class="language-plaintext highlighter-rouge">self</code>, just as we did in <code class="language-plaintext highlighter-rouge">&amp;Rectangle</code>. Methods can take ownership of self, borrow self immutably as we’ve done here, or borrow self mutably, just as they can any other parameter.</p>

<p>We’ve chosen <code class="language-plaintext highlighter-rouge">&amp;self</code> here for the same reason we used <code class="language-plaintext highlighter-rouge">&amp;Rectangle</code> in the function version: we don’t want to take ownership, and we just want to read the data in the struct, not write to it. If we wanted to change the instance that we’ve called the method on as part of what the method does, we’d use <code class="language-plaintext highlighter-rouge">&amp;mut self</code> as the first parameter. Having a method that takes ownership of the instance by using just self as the first parameter is rare; this technique is usually <strong>used when the method transforms self into something else and you want to prevent the caller from using the original instance after the transformation</strong>.</p>

<p>The main benefit of using methods instead of functions, in addition to <strong>using method syntax and not having to repeat the type of self in every method’s signature, is for organization</strong>. We’ve put all the things we can do with an instance of a type in one impl block rather than making future users of our code search for capabilities of Rectangle in various places in the library we provide.</p>

<p class="notice--info"><strong>Where’s the -&gt; Operator?</strong><br /><br />
In C and C++, two different operators are used for calling methods: you use <code class="language-plaintext highlighter-rouge">.</code> if you’re calling a method on the object directly and <code class="language-plaintext highlighter-rouge">-&gt;</code> if you’re calling the method on a pointer to the object and need to dereference the pointer first. In other words, if object is a pointer, object-&gt;something() is similar to (*object).something().<br /><br />
Rust <strong>doesn’t have</strong> an equivalent to the <code class="language-plaintext highlighter-rouge">-&gt;</code> operator; instead, Rust has a feature called <code class="language-plaintext highlighter-rouge">automatic referencing and dereferencing</code>. Calling methods is one of the few places in Rust that has this behavior.<br /><br />
Here’s how it works: when you call a method with <code class="language-plaintext highlighter-rouge">object.something()</code>, Rust automatically adds in <code class="language-plaintext highlighter-rouge">&amp;</code>, <code class="language-plaintext highlighter-rouge">&amp;mut</code>, or <code class="language-plaintext highlighter-rouge">*</code> so object matches the signature of the method. In other words, the following are the same: <br />
<strong><code class="language-plaintext highlighter-rouge">p1.distance(&amp;p2);</code></strong><br />
<strong><code class="language-plaintext highlighter-rouge">(&amp;p1).distance(&amp;p2);</code></strong><br />
The first one looks much cleaner. This automatic referencing behavior works because methods have a clear receiver—the type of self. Given the receiver and name of a method, Rust can figure out definitively whether the method is reading (&amp;self), mutating (&amp;mut self), or consuming (self). The fact that Rust makes borrowing implicit for method receivers is a big part of making ownership ergonomic in practice.</p>

<h3 id="methods-with-more-parameters">Methods with More Parameters</h3>
<p>Let’s practice using methods by implementing a second method on the Rectangle struct. This time, we want an instance of Rectangle to take another instance of Rectangle and return true if the second Rectangle can fit completely within self; otherwise it should return false. That is, we want to be able to write the program shown in Listing 5-14, once we’ve defined the can_hold method.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">rect1</span> <span class="o">=</span> <span class="n">Rectangle</span> <span class="p">{</span> <span class="n">length</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="mi">30</span> <span class="p">};</span>
    <span class="k">let</span> <span class="n">rect2</span> <span class="o">=</span> <span class="n">Rectangle</span> <span class="p">{</span> <span class="n">length</span><span class="p">:</span> <span class="mi">40</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="mi">10</span> <span class="p">};</span>
    <span class="k">let</span> <span class="n">rect3</span> <span class="o">=</span> <span class="n">Rectangle</span> <span class="p">{</span> <span class="n">length</span><span class="p">:</span> <span class="mi">45</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="mi">60</span> <span class="p">};</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"Can rect1 hold rect2? {}"</span><span class="p">,</span> <span class="n">rect1</span><span class="nf">.can_hold</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rect2</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Can rect1 hold rect3? {}"</span><span class="p">,</span> <span class="n">rect1</span><span class="nf">.can_hold</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rect3</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-5-14-using-the-as-yet-unwritten-can_hold-method">Listing 5-14: Using the as-yet-unwritten can_hold method</h4>
<p>And the expected output would look like the following, because both dimensions of rect2 are smaller than the dimensions of rect1 but rect3 is wider than rect1:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Can</span> <span class="n">rect1</span> <span class="n">hold</span> <span class="n">rect2</span><span class="o">?</span> <span class="k">true</span>
<span class="n">Can</span> <span class="n">rect1</span> <span class="n">hold</span> <span class="n">rect3</span><span class="o">?</span> <span class="k">false</span>
</code></pre></div></div>
<p>We know we want to define a method, so it will be within the <code class="language-plaintext highlighter-rouge">impl Rectangle</code> block. The method name will be <code class="language-plaintext highlighter-rouge">can_hold</code>, and it will take an immutable borrow of another <code class="language-plaintext highlighter-rouge">Rectangle</code> as a parameter. We can tell what the type of the parameter will be by looking at the code that calls the method: <code class="language-plaintext highlighter-rouge">rect1.can_hold(&amp;rect2)</code> passes in <code class="language-plaintext highlighter-rouge">&amp;rect2</code>, which is an <strong>immutable borrow</strong> to rect2, an instance of Rectangle. This makes sense because we only need to read rect2 (rather than write, which would mean we’d need a mutable borrow), and we want main to retain ownership of rect2 so we can use it again after calling the can_hold method. The return value of can_hold will be a Boolean, and the implementation will check whether the width and height of self are both greater than the width and height of the other Rectangle, respectively. Let’s add the new can_hold method to the impl block from Listing 5-13, shown in Listing 5-15.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">Rectangle</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">area</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.width</span> <span class="o">*</span> <span class="k">self</span><span class="py">.height</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">can_hold</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Rectangle</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.width</span> <span class="o">&gt;</span> <span class="n">other</span><span class="py">.width</span> <span class="o">&amp;&amp;</span> <span class="k">self</span><span class="py">.height</span> <span class="o">&gt;</span> <span class="n">other</span><span class="py">.height</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-5-15-implementing-the-can_hold-method-on-rectangle-that-takes-another-rectangle-instance-as-a-parameter">Listing 5-15: Implementing the can_hold method on Rectangle that takes another Rectangle instance as a parameter</h4>

<h3 id="associated-functions">Associated Functions</h3>
<p>Another useful feature of <code class="language-plaintext highlighter-rouge">impl</code> blocks is that we’re allowed to define functions within <code class="language-plaintext highlighter-rouge">impl</code> blocks that <strong>don’t take self as a parameter</strong>. These are called <strong>associated functions</strong> because they’re associated with the struct. They’re still functions, not methods, because they don’t have an instance of the struct to work with. You’ve already used the String::from associated function.</p>

<p>Associated functions are often used for constructors that will return a new instance of the struct.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">Rectangle</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">square</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Rectangle</span> <span class="p">{</span>
        <span class="n">Rectangle</span> <span class="p">{</span> <span class="n">length</span><span class="p">:</span> <span class="n">size</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="n">size</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>To call this associated function, we use the <code class="language-plaintext highlighter-rouge">::</code> syntax with the struct name; <code class="language-plaintext highlighter-rouge">let sq = Rectangle::square(3);</code> is an example. This function is namespaced by the struct: the <code class="language-plaintext highlighter-rouge">::</code> syntax is used for both associated functions and namespaces created by modules. We’ll discuss modules in Chapter 7.</p>

<h3 id="multiple-impl-blocks">Multiple impl Blocks</h3>
<p>Each struct is <strong>allowed</strong> to have multiple <code class="language-plaintext highlighter-rouge">impl</code> blocks. For example, Listing 5-15 is equivalent to the code shown in Listing 5-16, which has each method in its own impl block.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">Rectangle</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">area</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.width</span> <span class="o">*</span> <span class="k">self</span><span class="py">.height</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Rectangle</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">can_hold</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Rectangle</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.width</span> <span class="o">&gt;</span> <span class="n">other</span><span class="py">.width</span> <span class="o">&amp;&amp;</span> <span class="k">self</span><span class="py">.height</span> <span class="o">&gt;</span> <span class="n">other</span><span class="py">.height</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-5-16-rewriting-listing-5-15-using-multiple-impl-blocks">Listing 5-16: Rewriting Listing 5-15 using multiple impl blocks</h4>
<p><strong>There’s no reason to separate these methods into multiple impl blocks here</strong>, but this is valid syntax. We’ll see a case in which multiple impl blocks are useful in Chapter 10, where we discuss generic types and traits.</p>

<h2 id="summary">Summary</h2>
<p>Structs let you <strong>create custom types that are meaningful for your domain</strong>. By using structs, you can keep associated pieces of data connected to each other and name each piece to make your code clear. Methods let you specify the behavior that instances of your structs have, and associated functions let you namespace functionality that is particular to your struct without having an instance available.</p>

<p>But structs aren’t the only way you can create custom types: let’s turn to Rust’s enum feature to add another tool to your toolbox.</p>

        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/#structure" class="page__taxonomy-item" rel="tag">Structure</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#struct" class="page__taxonomy-item" rel="tag">Struct</a>
    
    </span>
  </p>




  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/categories/#rust-language" class="page__taxonomy-item" rel="tag">RUST Language</a>
    
    </span>
  </p>


        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2020-02-26T00:00:00+00:00">February 26, 2020</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?text=RUST+%3A+5.+Using+structs+to+structure+related+data%20https%3A%2F%2Fjjungs-lee.github.io%2F%2Frust%2F5.Using-Structs-to-Structure-Related-Data" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fjjungs-lee.github.io%2F%2Frust%2F5.Using-Structs-to-Structure-Related-Data" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fjjungs-lee.github.io%2F%2Frust%2F5.Using-Structs-to-Structure-Related-Data" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/rust/4.Understanding-Ownership" class="pagination--pager" title="RUST : 4. Understanding Ownership
">Previous</a>
    
    
      <a href="/rust/6.Enums-and-Pattern-Matching" class="pagination--pager" title="RUST : 6. Enums and Pattern Matching
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/rust/How-to-null-check-in-rust" rel="permalink">RUST : How to check null value in rust
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">How to check null value in rust
A question arose When i linking C language with rust language. 
That’s how to check null value in rust? Rust has Option&lt;T&...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/rust/15.Smart-Pointers" rel="permalink">RUST : 15. Smart Pointers
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  69 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">Smart Pointers
A pointer is a general concept for a variable that contains an address in memory. 
This address refers to, or “points at,” some other data. 
T...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/rust/14.More-About-Cargo-and-Crates.io" rel="permalink">RUST : 14. More About Cargo and Crates.io
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  29 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">More About Cargo and Crates.io
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/rust/How-to-call-C-function-in-rust" rel="permalink">RUST : How To call RUST function from C
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  4 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">How to call RUST function from C
I make programs mainly using C or C++ language. Recently I’m studying Rust. So I wanna interact to C and Rust. 
I want to li...</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
      
        
      
        
          <li><a href="https://github.com/jjungs-lee" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
      
        
      
        
      
    

    <li><a href="NONE"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2020 JJungs-lee. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script src="https://kit.fontawesome.com/4eee35f757.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>







  </body>
</html>
