<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.17.2 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html -->

<!----><title>Yes! I Take IT :)</title>
<meta name="description" content="Advanced FeaturesBy now, you’ve learned the most commonly used parts of the Rust programming language. Before we do one more project in Chapter 20, we’ll look at a few aspects of the language you might run into every once in a while. You can use this chapter as a reference for when you encounter any unknowns when using Rust. The features you’ll learn to use in this chapter are useful in very specific situations. Although you might not reach for them often, we want to make sure you have a grasp of all the features Rust has to offer.">


  <meta name="author" content="JJungs-lee">


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Yes! I Take IT">
<meta property="og:title" content="RUST : 19. Advanced Features">
<meta property="og:url" content="https://jjungs-lee.github.io//rust/19.Advanced-Features">


  <meta property="og:description" content="Advanced FeaturesBy now, you’ve learned the most commonly used parts of the Rust programming language. Before we do one more project in Chapter 20, we’ll look at a few aspects of the language you might run into every once in a while. You can use this chapter as a reference for when you encounter any unknowns when using Rust. The features you’ll learn to use in this chapter are useful in very specific situations. Although you might not reach for them often, we want to make sure you have a grasp of all the features Rust has to offer.">







  <meta property="article:published_time" content="2020-12-27T00:00:00+00:00">





  

  


<link rel="canonical" href="https://jjungs-lee.github.io//rust/19.Advanced-Features">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "JJungs-lee",
      "url": "https://jjungs-lee.github.io//"
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="NONE" type="application/atom+xml" rel="alternate" title="Yes! I Take IT Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          <b>I.T.I</b> <small>by JHLee</small>
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/posts/" >Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/kernel/" >Kernel</a>
            </li><li class="masthead__menu-item">
              <a href="/swim/" >Swim</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="/assets/images/author_jhl.png" alt="JJungs-lee" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">JJungs-lee</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>Do Coding! Do Study!</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Somewhere</span>
        </li>
      

      
        
          
        
          
        
          
        
          
        
          
            <li><a href="https://github.com/jjungs-lee" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
          
        
          
        
          
            <li><a href="https://www.linkedin.com/in/jjungs-lee" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="RUST : 19. Advanced Features">
    <meta itemprop="description" content="Advanced FeaturesBy now, you’ve learned the most commonly used parts of the Rust programming language. Before we do one more project in Chapter 20, we’ll look at a few aspects of the language you might run into every once in a while. You can use this chapter as a reference for when you encounter any unknowns when using Rust. The features you’ll learn to use in this chapter are useful in very specific situations. Although you might not reach for them often, we want to make sure you have a grasp of all the features Rust has to offer.">
    <meta itemprop="datePublished" content="2020-12-27T00:00:00+00:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">RUST : 19. Advanced Features
</h1>
          
            <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  71 minute read

</p>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
        <h2 id="advanced-features">Advanced Features</h2>
<p>By now, you’ve learned the most commonly used parts of the Rust programming language. 
Before we do one more project in Chapter 20, we’ll look at a few aspects of the language you might run into every once in a while. 
You can use this chapter as a reference for when you encounter any unknowns when using Rust. 
The features you’ll learn to use in this chapter are useful in very specific situations. 
Although you might not reach for them often, we want to make sure you have a grasp of all the features Rust has to offer.</p>

<p>In this chapter, we’ll cover:</p>

<ul>
  <li>Unsafe Rust: how to opt out of some of Rust’s guarantees and take responsibility for manually upholding those guarantees</li>
  <li>Advanced traits: associated types, default type parameters, fully qualified syntax, supertraits, and the newtype pattern in relation to traits</li>
  <li>Advanced types: more about the newtype pattern, type aliases, the never type, and dynamically sized types</li>
  <li>Advanced functions and closures: function pointers and returning closures</li>
  <li>Macros: ways to define code that defines more code at compile time
It’s a panoply of Rust features with something for everyone! Let’s dive in!</li>
</ul>

<h2 id="unsafe-rust">Unsafe Rust</h2>
<p>All the code we’ve discussed so far has had Rust’s memory safety guarantees enforced at compile time. 
However, Rust has a second language hidden inside it that doesn’t enforce these memory safety guarantees: it’s called <strong>unsafe Rust</strong> and works just like regular Rust, but gives us extra superpowers.</p>

<p>Unsafe Rust exists because, by nature, static analysis is conservative. 
When the compiler tries to determine whether or not code upholds the guarantees, it’s better for it to reject some valid programs rather than accept some invalid programs. 
Although the code might be okay, as far as Rust is able to tell, it’s not! In these cases, you can use unsafe code to tell the compiler, “Trust me, I know what I’m doing.” The downside is that you use it at your own risk: if you use unsafe code incorrectly, problems due to memory unsafety, such as null pointer dereferencing, can occur.</p>

<p>Another reason Rust has an unsafe alter ego is that the underlying computer hardware is inherently unsafe. 
If Rust didn’t let you do unsafe operations, you couldn’t do certain tasks. 
Rust needs to allow you to do low-level systems programming, such as directly interacting with the operating system or even writing your own operating system. 
Working with low-level systems programming is one of the goals of the language. Let’s explore what we can do with unsafe Rust and how to do it.</p>

<h3 id="unsafe-superpowers">Unsafe Superpowers</h3>
<p>To switch to unsafe Rust, use the <code class="language-plaintext highlighter-rouge">unsafe</code> keyword and then start a new block that holds the unsafe code. You can take five actions in unsafe Rust, called <code class="language-plaintext highlighter-rouge">unsafe superpowers</code>, that you can’t in safe Rust. 
Those superpowers include the ability to:</p>

<ul>
  <li>Dereference a raw pointer</li>
  <li>Call an unsafe function or method</li>
  <li>Access or modify a mutable static variable</li>
  <li>Implement an unsafe trait</li>
  <li>Access fields of <code class="language-plaintext highlighter-rouge">union</code>s</li>
</ul>

<p>It’s important to understand that <code class="language-plaintext highlighter-rouge">unsafe</code> doesn’t turn off the borrow checker or disable any other of Rust’s safety checks: if you use a reference in unsafe code, it will still be checked. 
The <code class="language-plaintext highlighter-rouge">unsafe</code> keyword only gives you access to these five features that are then not checked by the compiler for memory safety. 
You’ll still get some degree of safety inside of an unsafe block.</p>

<p>In addition, <code class="language-plaintext highlighter-rouge">unsafe</code> does not mean the code inside the block is necessarily dangerous or that it will definitely have memory safety problems: the intent is that as the programmer, you’ll ensure the code inside an <code class="language-plaintext highlighter-rouge">unsafe</code> block will access memory in a valid way.</p>

<p>People are fallible, and mistakes will happen, but by requiring these five unsafe operations to be inside blocks annotated with <code class="language-plaintext highlighter-rouge">unsafe</code> you’ll know that any errors related to memory safety must be within an <code class="language-plaintext highlighter-rouge">unsafe</code> block. 
Keep <code class="language-plaintext highlighter-rouge">unsafe</code> blocks small; you’ll be thankful later when you investigate memory bugs.</p>

<p>To isolate unsafe code as much as possible, it’s best to enclose unsafe code within a safe abstraction and provide a safe API, which we’ll discuss later in the chapter when we examine unsafe functions and methods. 
Parts of the standard library are implemented as safe abstractions over unsafe code that has been audited. 
Wrapping unsafe code in a safe abstraction prevents uses of <code class="language-plaintext highlighter-rouge">unsafe</code> from leaking out into all the places that you or your users might want to use the functionality implemented with <code class="language-plaintext highlighter-rouge">unsafe</code> code, because using a safe abstraction is safe.</p>

<p>Let’s look at each of the five unsafe superpowers in turn. We’ll also look at some abstractions that provide a safe interface to unsafe code.</p>

<h3 id="dereferencing-a-raw-pointer">Dereferencing a Raw Pointer</h3>
<p>In Chapter 4, in the “Dangling References” section, we mentioned that the compiler ensures references are always valid. 
Unsafe Rust has two new types called raw pointers that are similar to references. As with references, <code class="language-plaintext highlighter-rouge">raw pointers</code> can be immutable or mutable and are written as <code class="language-plaintext highlighter-rouge">*const T</code> and <code class="language-plaintext highlighter-rouge">*mut T</code>, respectively. 
The asterisk isn’t the dereference operator; it’s part of the type name. 
In the context of raw pointers, <code class="language-plaintext highlighter-rouge">immutable</code> means that the pointer can’t be directly assigned to after being dereferenced.</p>

<p>Different from references and smart pointers, raw pointers:</p>

<ul>
  <li>Are allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location</li>
  <li>Aren’t guaranteed to point to valid memory</li>
  <li>Are allowed to be null</li>
  <li>Don’t implement any automatic cleanup</li>
</ul>

<p>By opting out of having Rust enforce these guarantees, you can give up guaranteed safety in exchange for greater performance or the ability to interface with another language or hardware where Rust’s guarantees don’t apply.</p>

<p>Listing 19-1 shows how to create an immutable and a mutable raw pointer from references.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="k">mut</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">r1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">num</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">i32</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">r2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">num</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">i32</span><span class="p">;</span>
</code></pre></div></div>
<h4 id="listing-19-1-creating-raw-pointers-from-references">Listing 19-1: Creating raw pointers from references</h4>

<p>Notice that we don’t include the <code class="language-plaintext highlighter-rouge">unsafe</code> keyword in this code. 
We can create raw pointers in safe code; we just can’t dereference raw pointers outside an unsafe block, as you’ll see in a bit.</p>

<p>We’ve created raw pointers by using <code class="language-plaintext highlighter-rouge">as</code> to cast an immutable and a mutable reference into their corresponding raw pointer types. Because we created them directly from references guaranteed to be valid, we know these particular raw pointers are valid, but we can’t make that assumption about just any raw pointer.</p>

<p>Next, we’ll create a raw pointer whose validity we can’t be so certain of. 
Listing 19-2 shows how to create a raw pointer to an arbitrary location in memory. 
Trying to use arbitrary memory is undefined: there might be data at that address or there might not, the compiler might optimize the code so there is no memory access, or the program might error with a segmentation fault. 
Usually, there is no good reason to write code like this, but it is possible.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="n">address</span> <span class="o">=</span> <span class="mi">0x012345usize</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">address</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">i32</span><span class="p">;</span>
</code></pre></div></div>
<h4 id="listing-19-2-creating-a-raw-pointer-to-an-arbitrary-memory-address">Listing 19-2: Creating a raw pointer to an arbitrary memory address</h4>

<p>Recall that we can create raw pointers in safe code, but we can’t <em>dereference</em> raw pointers and read the data being pointed to. 
In Listing 19-3, we use the dereference operator <code class="language-plaintext highlighter-rouge">*</code> on a raw pointer that requires an <code class="language-plaintext highlighter-rouge">unsafe</code> block.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="k">mut</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">r1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">num</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">i32</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">r2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">num</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">i32</span><span class="p">;</span>

    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"r1 is: {}"</span><span class="p">,</span> <span class="o">*</span><span class="n">r1</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"r2 is: {}"</span><span class="p">,</span> <span class="o">*</span><span class="n">r2</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-3-dereferencing-raw-pointers-within-an-unsafe-block">Listing 19-3: Dereferencing raw pointers within an unsafe block</h4>

<p>Creating a pointer does no harm; it’s only when we try to access the value that it points at that we might end up dealing with an invalid value.</p>

<p>Note also that in Listing 19-1 and 19-3, we created <code class="language-plaintext highlighter-rouge">*const i32</code> and <code class="language-plaintext highlighter-rouge">*mut i32</code> raw pointers that both pointed to the same memory location, where <code class="language-plaintext highlighter-rouge">num</code> is stored. 
If we instead tried to create an immutable and a mutable reference to <code class="language-plaintext highlighter-rouge">num</code>, the code would not have compiled because Rust’s ownership rules don’t allow a mutable reference at the same time as any immutable references. 
With raw pointers, we can create a mutable pointer and an immutable pointer to the same location and change data through the mutable pointer, potentially creating a data race. Be careful!</p>

<p>With all of these dangers, why would you ever use raw pointers? One major use case is when interfacing with C code, as you’ll see in the next section, “Calling an Unsafe Function or Method.” 
Another case is when building up safe abstractions that the borrow checker doesn’t understand. 
We’ll introduce unsafe functions and then look at an example of a safe abstraction that uses unsafe code.</p>

<h3 id="calling-an-unsafe-function-or-method">Calling an Unsafe Function or Method</h3>
<p>The second type of operation that requires an unsafe block is calls to unsafe functions. 
Unsafe functions and methods look exactly like regular functions and methods, but they have an extra <code class="language-plaintext highlighter-rouge">unsafe</code> before the rest of the definition. 
The <code class="language-plaintext highlighter-rouge">unsafe</code> keyword in this context indicates the function has requirements we need to uphold when we call this function, because Rust can’t guarantee we’ve met these requirements. 
By calling an unsafe function within an <code class="language-plaintext highlighter-rouge">unsafe</code> block, we’re saying that we’ve read this function’s documentation and take responsibility for upholding the function’s contracts.</p>

<p>Here is an unsafe function named <code class="language-plaintext highlighter-rouge">dangerous</code> that doesn’t do anything in its body:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">dangerous</span><span class="p">()</span> <span class="p">{}</span>

    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="nf">dangerous</span><span class="p">();</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>We must call the <code class="language-plaintext highlighter-rouge">dangerous</code> function within a separate <code class="language-plaintext highlighter-rouge">unsafe</code> block. If we try to call <code class="language-plaintext highlighter-rouge">dangerous</code> without the <code class="language-plaintext highlighter-rouge">unsafe</code> block, we’ll get an error:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="k">unsafe</span><span class="o">-</span><span class="n">example</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/unsafe-example)</span>
<span class="n">error</span><span class="p">[</span><span class="n">E0133</span><span class="p">]:</span> <span class="n">call</span> <span class="n">to</span> <span class="k">unsafe</span> <span class="n">function</span> <span class="n">is</span> <span class="k">unsafe</span> <span class="n">and</span> <span class="n">requires</span> <span class="k">unsafe</span> <span class="n">function</span> <span class="n">or</span> <span class="n">block</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span>
  <span class="p">|</span>
<span class="mi">4</span> <span class="p">|</span>     <span class="nf">dangerous</span><span class="p">();</span>
  <span class="p">|</span>     <span class="o">^^^^^^^^^^^</span> <span class="n">call</span> <span class="n">to</span> <span class="k">unsafe</span> <span class="n">function</span>
  <span class="p">|</span>
  <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">consult</span> <span class="n">the</span> <span class="n">function</span><span class="nv">'s</span> <span class="n">documentation</span> <span class="k">for</span> <span class="n">information</span> <span class="n">on</span> <span class="n">how</span> <span class="n">to</span> <span class="n">avoid</span> <span class="n">undefined</span> <span class="n">behavior</span>

<span class="n">error</span><span class="p">:</span> <span class="n">aborting</span> <span class="n">due</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">error</span>

<span class="n">For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">about</span> <span class="n">this</span> <span class="n">error</span><span class="p">,</span> <span class="k">try</span> <span class="err">`</span><span class="n">rustc</span> <span class="o">--</span><span class="n">explain</span> <span class="n">E0133</span><span class="err">`</span><span class="py">.
error</span><span class="p">:</span> <span class="n">could</span> <span class="n">not</span> <span class="n">compile</span> <span class="err">`</span><span class="k">unsafe</span><span class="o">-</span><span class="n">example</span><span class="err">`</span><span class="py">.

To</span> <span class="n">learn</span> <span class="n">more</span><span class="p">,</span> <span class="n">run</span> <span class="n">the</span> <span class="n">command</span> <span class="n">again</span> <span class="n">with</span> <span class="o">--</span><span class="n">verbose</span><span class="err">.</span>
</code></pre></div></div>
<p>By inserting the <code class="language-plaintext highlighter-rouge">unsafe</code> block around our call to <code class="language-plaintext highlighter-rouge">dangerous</code>, we’re asserting to Rust that we’ve read the function’s documentation, we understand how to use it properly, and we’ve verified that we’re fulfilling the contract of the function.</p>

<p>Bodies of unsafe functions are effectively <code class="language-plaintext highlighter-rouge">unsafe</code> blocks, so to perform other unsafe operations within an unsafe function, we don’t need to add another <code class="language-plaintext highlighter-rouge">unsafe</code> block.</p>

<h3 id="creating-a-safe-abstraction-over-unsafe-code">Creating a Safe Abstraction over Unsafe Code</h3>
<p>Just because a function contains unsafe code doesn’t mean we need to mark the entire function as unsafe. 
In fact, wrapping unsafe code in a safe function is a common abstraction. 
As an example, let’s study a function from the standard library, <code class="language-plaintext highlighter-rouge">split_at_mut</code>, that requires some unsafe code and explore how we might implement it. 
This safe method is defined on mutable slices: it takes one slice and makes it two by splitting the slice at the index given as an argument. Listing 19-4 shows how to use <code class="language-plaintext highlighter-rouge">split_at_mut</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="k">mut</span> <span class="n">v</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">];</span>

    <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">v</span><span class="p">[</span><span class="o">..</span><span class="p">];</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">r</span><span class="nf">.split_at_mut</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]);</span>
</code></pre></div></div>
<h4 id="listing-19-4-using-the-safe-split_at_mut-function">Listing 19-4: Using the safe split_at_mut function</h4>

<p>We can’t implement this function using only safe Rust. An attempt might look something like Listing 19-5, which won’t compile. 
For simplicity, we’ll implement <code class="language-plaintext highlighter-rouge">split_at_mut</code> as a function rather than a method and only for slices of <code class="language-plaintext highlighter-rouge">i32</code> values rather than for a generic type T.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">split_at_mut</span><span class="p">(</span><span class="n">slice</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">i32</span><span class="p">],</span> <span class="n">mid</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">i32</span><span class="p">],</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">i32</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">slice</span><span class="nf">.len</span><span class="p">();</span>

    <span class="nd">assert!</span><span class="p">(</span><span class="n">mid</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">);</span>

    <span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">slice</span><span class="p">[</span><span class="o">..</span><span class="n">mid</span><span class="p">],</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">slice</span><span class="p">[</span><span class="n">mid</span><span class="o">..</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-5-an-attempted-implementation-of-split_at_mut-using-only-safe-rust">Listing 19-5: An attempted implementation of split_at_mut using only safe Rust</h4>

<p>This function first gets the total length of the slice. 
Then it asserts that the index given as a parameter is within the slice by checking whether it’s less than or equal to the length. 
The assertion means that if we pass an index that is greater than the length to split the slice at, the function will panic before it attempts to use that index.</p>

<p>Then we return two mutable slices in a tuple: one from the start of the original slice to the <code class="language-plaintext highlighter-rouge">mid</code> index and another from <code class="language-plaintext highlighter-rouge">mid</code> to the end of the slice.</p>

<p>When we try to compile the code in Listing 19-5, we’ll get an error.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="k">unsafe</span><span class="o">-</span><span class="n">example</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/unsafe-example)</span>
<span class="n">error</span><span class="p">[</span><span class="n">E0499</span><span class="p">]:</span> <span class="n">cannot</span> <span class="n">borrow</span> <span class="err">`</span><span class="o">*</span><span class="n">slice</span><span class="err">`</span> <span class="k">as</span> <span class="n">mutable</span> <span class="n">more</span> <span class="n">than</span> <span class="n">once</span> <span class="n">at</span> <span class="n">a</span> <span class="n">time</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">6</span><span class="p">:</span><span class="mi">30</span>
  <span class="p">|</span>
<span class="mi">1</span> <span class="p">|</span> <span class="k">fn</span> <span class="nf">split_at_mut</span><span class="p">(</span><span class="n">slice</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">i32</span><span class="p">],</span> <span class="n">mid</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">i32</span><span class="p">],</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">i32</span><span class="p">])</span> <span class="p">{</span>
  <span class="p">|</span>                        <span class="o">-</span> <span class="k">let</span><span class="nv">'s</span> <span class="n">call</span> <span class="n">the</span> <span class="n">lifetime</span> <span class="n">of</span> <span class="n">this</span> <span class="n">reference</span> <span class="err">`'</span><span class="mi">1</span><span class="err">`</span>
<span class="o">...</span>
<span class="mi">6</span> <span class="p">|</span>     <span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">slice</span><span class="p">[</span><span class="o">..</span><span class="n">mid</span><span class="p">],</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">slice</span><span class="p">[</span><span class="n">mid</span><span class="o">..</span><span class="p">])</span>
  <span class="p">|</span>     <span class="o">-------------------------^^^^^--------</span>
  <span class="p">|</span>     <span class="p">|</span>     <span class="p">|</span>                  <span class="p">|</span>
  <span class="p">|</span>     <span class="p">|</span>     <span class="p">|</span>                  <span class="n">second</span> <span class="n">mutable</span> <span class="n">borrow</span> <span class="n">occurs</span> <span class="n">here</span>
  <span class="p">|</span>     <span class="p">|</span>     <span class="n">first</span> <span class="n">mutable</span> <span class="n">borrow</span> <span class="n">occurs</span> <span class="n">here</span>
  <span class="p">|</span>     <span class="n">returning</span> <span class="n">this</span> <span class="n">value</span> <span class="n">requires</span> <span class="n">that</span> <span class="err">`</span><span class="o">*</span><span class="n">slice</span><span class="err">`</span> <span class="n">is</span> <span class="n">borrowed</span> <span class="k">for</span> <span class="err">`'</span><span class="mi">1</span><span class="err">`</span>

<span class="n">error</span><span class="p">:</span> <span class="n">aborting</span> <span class="n">due</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">error</span>

<span class="n">For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">about</span> <span class="n">this</span> <span class="n">error</span><span class="p">,</span> <span class="k">try</span> <span class="err">`</span><span class="n">rustc</span> <span class="o">--</span><span class="n">explain</span> <span class="n">E0499</span><span class="err">`</span><span class="py">.
error</span><span class="p">:</span> <span class="n">could</span> <span class="n">not</span> <span class="n">compile</span> <span class="err">`</span><span class="k">unsafe</span><span class="o">-</span><span class="n">example</span><span class="err">`</span><span class="py">.

To</span> <span class="n">learn</span> <span class="n">more</span><span class="p">,</span> <span class="n">run</span> <span class="n">the</span> <span class="n">command</span> <span class="n">again</span> <span class="n">with</span> <span class="o">--</span><span class="n">verbose</span><span class="err">.</span>
</code></pre></div></div>
<p>Rust’s borrow checker can’t understand that we’re borrowing different parts of the slice; it only knows that we’re borrowing from the same slice twice. 
Borrowing different parts of a slice is fundamentally okay because the two slices aren’t overlapping, but Rust isn’t smart enough to know this. 
When we know code is okay, but Rust doesn’t, it’s time to reach for unsafe code.</p>

<p>Listing 19-6 shows how to use an <code class="language-plaintext highlighter-rouge">unsafe</code> block, a raw pointer, and some calls to unsafe functions to make the implementation of <code class="language-plaintext highlighter-rouge">split_at_mut</code> work.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">slice</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">split_at_mut</span><span class="p">(</span><span class="n">slice</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">i32</span><span class="p">],</span> <span class="n">mid</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">i32</span><span class="p">],</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">i32</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">slice</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">slice</span><span class="nf">.as_mut_ptr</span><span class="p">();</span>

    <span class="nd">assert!</span><span class="p">(</span><span class="n">mid</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">);</span>

    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="p">(</span>
            <span class="nn">slice</span><span class="p">::</span><span class="nf">from_raw_parts_mut</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">mid</span><span class="p">),</span>
            <span class="nn">slice</span><span class="p">::</span><span class="nf">from_raw_parts_mut</span><span class="p">(</span><span class="n">ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">mid</span><span class="p">),</span> <span class="n">len</span> <span class="o">-</span> <span class="n">mid</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-6-using-unsafe-code-in-the-implementation-of-the-split_at_mut-function">Listing 19-6: Using unsafe code in the implementation of the split_at_mut function</h4>

<p>Recall from “The Slice Type” section in Chapter 4 that slices are a pointer to some data and the length of the slice. 
We use the <code class="language-plaintext highlighter-rouge">len</code> method to get the length of a slice and the <code class="language-plaintext highlighter-rouge">as_mut_ptr</code> method to access the raw pointer of a slice. 
In this case, because we have a mutable slice to <code class="language-plaintext highlighter-rouge">i32</code> values, <code class="language-plaintext highlighter-rouge">as_mut_ptr</code> returns a raw pointer with the type <code class="language-plaintext highlighter-rouge">*mut i32</code>, which we’ve stored in the variable <code class="language-plaintext highlighter-rouge">ptr</code>.</p>

<p>We keep the assertion that the <code class="language-plaintext highlighter-rouge">mid</code> index is within the slice. 
Then we get to the unsafe code: the <code class="language-plaintext highlighter-rouge">slice::from_raw_parts_mut</code> function takes a raw pointer and a length, and it creates a slice. 
We use this function to create a slice that starts from <code class="language-plaintext highlighter-rouge">ptr</code> and is <code class="language-plaintext highlighter-rouge">mid</code> items long. 
Then we call the <code class="language-plaintext highlighter-rouge">add</code> method on <code class="language-plaintext highlighter-rouge">ptr</code> with mid as an argument to get a raw pointer that starts at <code class="language-plaintext highlighter-rouge">mid</code>, and we create a slice using that pointer and the remaining number of items after mid as the length.</p>

<p>The function <code class="language-plaintext highlighter-rouge">slice::from_raw_parts_mut</code> is unsafe because it takes a raw pointer and must trust that this pointer is valid. 
The <code class="language-plaintext highlighter-rouge">add</code> method on raw pointers is also unsafe, because it must trust that the offset location is also a valid pointer. 
Therefore, we had to put an <code class="language-plaintext highlighter-rouge">unsafe</code> block around our calls to <code class="language-plaintext highlighter-rouge">slice::from_raw_parts_mut</code> and <code class="language-plaintext highlighter-rouge">add</code> so we could call them. 
By looking at the code and by adding the assertion that <code class="language-plaintext highlighter-rouge">mid</code> must be less than or equal to <code class="language-plaintext highlighter-rouge">len</code>, we can tell that all the raw pointers used within the <code class="language-plaintext highlighter-rouge">unsafe</code> block will be valid pointers to data within the slice. This is an acceptable and appropriate use of <code class="language-plaintext highlighter-rouge">unsafe</code>.</p>

<p>Note that we don’t need to mark the resulting <code class="language-plaintext highlighter-rouge">split_at_mut</code> function as <code class="language-plaintext highlighter-rouge">unsafe</code>, and we can call this function from safe Rust. 
We’ve created a safe abstraction to the unsafe code with an implementation of the function that uses <code class="language-plaintext highlighter-rouge">unsafe</code> code in a safe way, because it creates only valid pointers from the data this function has access to.</p>

<p>In contrast, the use of <code class="language-plaintext highlighter-rouge">slice::from_raw_parts_mut</code> in Listing 19-7 would likely crash when the slice is used. This code takes an arbitrary memory location and creates a slice 10,000 items long.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">slice</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">address</span> <span class="o">=</span> <span class="mi">0x01234usize</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">address</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">i32</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">slice</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">i32</span><span class="p">]</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">slice</span><span class="p">::</span><span class="nf">from_raw_parts_mut</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span> <span class="p">};</span>
</code></pre></div></div>
<h4 id="listing-19-7-creating-a-slice-from-an-arbitrary-memory-location">Listing 19-7: Creating a slice from an arbitrary memory location</h4>

<p>We don’t own the memory at this arbitrary location, and there is no guarantee that the slice this code creates contains valid <code class="language-plaintext highlighter-rouge">i32</code> values. 
Attempting to use <code class="language-plaintext highlighter-rouge">slice</code> as though it’s a valid slice results in undefined behavior.</p>

<h3 id="using-extern-functions-to-call-external-code">Using extern Functions to Call External Code</h3>
<p>Sometimes, your Rust code might need to interact with code written in another language. 
For this, Rust has a keyword, <code class="language-plaintext highlighter-rouge">extern</code>, that facilitates the creation and use of a <strong>Foreign Function Interface</strong> (FFI). 
An FFI is a way for a programming language to define functions and enable a different (foreign) programming language to call those functions.</p>

<p>Listing 19-8 demonstrates how to set up an integration with the <code class="language-plaintext highlighter-rouge">abs</code> function from the C standard library. 
Functions declared within <code class="language-plaintext highlighter-rouge">extern</code> blocks are always unsafe to call from Rust code. 
The reason is that other languages don’t enforce Rust’s rules and guarantees, and Rust can’t check them, so responsibility falls on the programmer to ensure safety.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">abs</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Absolute value of -3 according to C: {}"</span><span class="p">,</span> <span class="nf">abs</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-8-declaring-and-calling-an-extern-function-defined-in-another-language">Listing 19-8: Declaring and calling an extern function defined in another language</h4>

<p>Within the <code class="language-plaintext highlighter-rouge">extern "C"</code> block, we list the names and signatures of external functions from another language we want to call. 
The <code class="language-plaintext highlighter-rouge">"C"</code> part defines which <em>application binary interface</em> (ABI) the external function uses: the ABI defines how to call the function at the assembly level. 
The <code class="language-plaintext highlighter-rouge">"C"</code> ABI is the most common and follows the C programming language’s ABI.</p>

<blockquote>
  <p><strong>Calling Rust Functions from Other Languages</strong><br />
We can also use <code class="language-plaintext highlighter-rouge">extern</code> to create an interface that allows other languages to call Rust functions. 
Instead of an <code class="language-plaintext highlighter-rouge">extern</code> block, we add the <code class="language-plaintext highlighter-rouge">extern</code> keyword and specify the ABI to use just before the <code class="language-plaintext highlighter-rouge">fn</code> keyword. 
We also need to add a <code class="language-plaintext highlighter-rouge">#[no_mangle]</code> annotation to tell the Rust compiler not to mangle the name of this function. 
<strong>Mangling</strong> is when a compiler changes the name we’ve given a function to a different name that contains more information for other parts of the compilation process to consume but is less human readable. 
Every programming language compiler mangles names slightly differently, so for a Rust function to be nameable by other languages, we must disable the Rust compiler’s name mangling.<br />
In the following example, we make the <code class="language-plaintext highlighter-rouge">call_from_c</code> function accessible from C code, after it’s compiled to a shared library and linked from C:</p>
  <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="nd">#[no_mangle]</span>
   <span class="k">pub</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">call_from_c</span><span class="p">()</span> <span class="p">{</span>
       <span class="nd">println!</span><span class="p">(</span><span class="s">"Just called a Rust function from C!"</span><span class="p">);</span>
   <span class="p">}</span>
</code></pre></div>  </div>
  <p>This usage of <code class="language-plaintext highlighter-rouge">extern</code> does not require <code class="language-plaintext highlighter-rouge">unsafe</code>.</p>
</blockquote>

<h3 id="accessing-or-modifying-a-mutable-static-variable">Accessing or Modifying a Mutable Static Variable</h3>
<p>Until now, we’ve not talked about <code class="language-plaintext highlighter-rouge">global variables</code>, which Rust does support but can be problematic with Rust’s ownership rules. If two threads are accessing the same mutable global variable, it can cause a data race.</p>

<p>In Rust, global variables are called <code class="language-plaintext highlighter-rouge">static</code> variables. 
Listing 19-9 shows an example declaration and use of a static variable with a string slice as a value.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">static</span> <span class="n">HELLO_WORLD</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">"Hello, world!"</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"name is: {}"</span><span class="p">,</span> <span class="n">HELLO_WORLD</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-9-defining-and-using-an-immutable-static-variable">Listing 19-9: Defining and using an immutable static variable</h4>

<p>Static variables are similar to constants, which we discussed in the “Differences Between Variables and Constants” section in Chapter 3. 
The names of static variables are in <code class="language-plaintext highlighter-rouge">SCREAMING_SNAKE_CASE</code> by convention, and we must annotate the variable’s type, which is <code class="language-plaintext highlighter-rouge">&amp;'static str</code> in this example. 
Static variables can only store references with the <code class="language-plaintext highlighter-rouge">'static</code> lifetime, which means the Rust compiler can figure out the lifetime; we don’t need to annotate it explicitly. Accessing an immutable static variable is safe.</p>

<p>Constants and immutable static variables might seem similar, but a subtle difference is that values in a static variable have a fixed address in memory. 
Using the value will always access the same data. Constants, on the other hand, are allowed to duplicate their data whenever they’re used.</p>

<p>Another difference between constants and static variables is that static variables can be mutable. 
Accessing and modifying mutable static variables is <em>unsafe</em>. 
Listing 19-10 shows how to declare, access, and modify a mutable static variable named <code class="language-plaintext highlighter-rouge">COUNTER</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">static</span> <span class="k">mut</span> <span class="n">COUNTER</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">add_to_count</span><span class="p">(</span><span class="n">inc</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="n">COUNTER</span> <span class="o">+=</span> <span class="n">inc</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">add_to_count</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"COUNTER: {}"</span><span class="p">,</span> <span class="n">COUNTER</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-10-reading-from-or-writing-to-a-mutable-static-variable-is-unsafe">Listing 19-10: Reading from or writing to a mutable static variable is unsafe</h4>

<p>As with regular variables, we specify mutability using the <code class="language-plaintext highlighter-rouge">mut</code> keyword. 
Any code that reads or writes from <code class="language-plaintext highlighter-rouge">COUNTER</code> must be within an <code class="language-plaintext highlighter-rouge">unsafe</code> block. 
This code compiles and prints <code class="language-plaintext highlighter-rouge">COUNTER: 3</code> as we would expect because it’s single threaded. 
Having multiple threads access <code class="language-plaintext highlighter-rouge">COUNTER</code> would likely result in data races.</p>

<p>With mutable data that is globally accessible, it’s difficult to ensure there are no data races, which is why Rust considers mutable static variables to be unsafe. 
Where possible, it’s preferable to use the concurrency techniques and thread-safe smart pointers we discussed in Chapter 16 so the compiler checks that data accessed from different threads is done safely.</p>

<h3 id="implementing-an-unsafe-trait">Implementing an Unsafe Trait</h3>
<p>The final action that works only with <code class="language-plaintext highlighter-rouge">unsafe</code> is implementing an unsafe trait. 
A trait is unsafe when at least one of its methods has some invariant that the compiler can’t verify. 
We can declare that a trait is <code class="language-plaintext highlighter-rouge">unsafe</code> by adding the <code class="language-plaintext highlighter-rouge">unsafe</code> keyword before <code class="language-plaintext highlighter-rouge">trait</code> and marking the implementation of the trait as <code class="language-plaintext highlighter-rouge">unsafe</code> too, as shown in Listing 19-11.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">unsafe</span> <span class="k">trait</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="c1">// methods go here</span>
<span class="p">}</span>

<span class="k">unsafe</span> <span class="k">impl</span> <span class="n">Foo</span> <span class="k">for</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="c1">// method implementations go here</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{}</span>
</code></pre></div></div>
<h4 id="listing-19-11-defining-and-implementing-an-unsafe-trait">Listing 19-11: Defining and implementing an unsafe trait</h4>

<p>By using <code class="language-plaintext highlighter-rouge">unsafe impl</code>, we’re promising that we’ll uphold the invariants that the compiler can’t verify.</p>

<p>As an example, recall the <code class="language-plaintext highlighter-rouge">Sync</code> and <code class="language-plaintext highlighter-rouge">Send</code> marker traits we discussed in the “Extensible Concurrency with the <code class="language-plaintext highlighter-rouge">Sync</code> and <code class="language-plaintext highlighter-rouge">Send</code> Traits” section in Chapter 16: the compiler implements these traits automatically if our types are composed entirely of <code class="language-plaintext highlighter-rouge">Send</code> and <code class="language-plaintext highlighter-rouge">Sync</code> types. 
If we implement a type that contains a type that is not <code class="language-plaintext highlighter-rouge">Send</code> or <code class="language-plaintext highlighter-rouge">Sync</code>, such as raw pointers, and we want to mark that type as <code class="language-plaintext highlighter-rouge">Send</code> or <code class="language-plaintext highlighter-rouge">Sync</code>, we must use <code class="language-plaintext highlighter-rouge">unsafe</code>. 
Rust can’t verify that our type upholds the guarantees that it can be safely sent across threads or accessed from multiple threads; therefore, we need to do those checks manually and indicate as such with <code class="language-plaintext highlighter-rouge">unsafe</code>.</p>

<h3 id="accessing-fields-of-a-union">Accessing Fields of a Union</h3>
<p>A <code class="language-plaintext highlighter-rouge">union</code> is similar to a <code class="language-plaintext highlighter-rouge">struct</code>, but only one declared field is used in a particular instance at one time. 
Unions are primarily used to interface with unions in C code. 
Accessing union fields is unsafe because Rust can’t guarantee the type of the data currently being stored in the union instance. 
You can learn more about unions in <a href="https://doc.rust-lang.org/reference/items/unions.html">the reference</a>.</p>

<h3 id="when-to-use-unsafe-code">When to Use Unsafe Code</h3>
<p>Using <code class="language-plaintext highlighter-rouge">unsafe</code> to take one of the five actions (superpowers) just discussed isn’t wrong or even frowned upon. 
But it is trickier to get <code class="language-plaintext highlighter-rouge">unsafe</code> code correct because the compiler can’t help uphold memory safety. 
When you have a reason to use <code class="language-plaintext highlighter-rouge">unsafe</code> code, you can do so, and having the explicit <code class="language-plaintext highlighter-rouge">unsafe</code> annotation makes it easier to track down the source of problems when they occur.</p>

<h2 id="advanced-traits">Advanced Traits</h2>
<p>We first covered traits in the “Traits: Defining Shared Behavior” section of Chapter 10, but as with lifetimes, we didn’t discuss the more advanced details. 
Now that you know more about Rust, we can get into the nitty-gritty.</p>

<h3 id="specifying-placeholder-types-in-trait-definitions-with-associated-types">Specifying Placeholder Types in Trait Definitions with Associated Types</h3>
<p><em>Associated types</em> connect a type placeholder with a trait such that the trait method definitions can use these placeholder types in their signatures. 
The implementor of a trait will specify the concrete type to be used in this type’s place for the particular implementation. 
That way, we can define a trait that uses some types without needing to know exactly what those types are until the trait is implemented.</p>

<p>We’ve described most of the advanced features in this chapter as being rarely needed. 
Associated types are somewhere in the middle: they’re used more rarely than features explained in the rest of the book but more commonly than many of the other features discussed in this chapter.</p>

<p>One example of a trait with an associated type is the <code class="language-plaintext highlighter-rouge">Iterator</code> trait that the standard library provides. 
The associated type is named <code class="language-plaintext highlighter-rouge">Item</code> and stands in for the type of the values the type implementing the <code class="language-plaintext highlighter-rouge">Iterator</code> trait is iterating over. 
In “The <code class="language-plaintext highlighter-rouge">Iterator</code> Trait and the <code class="language-plaintext highlighter-rouge">next</code> Method” section of Chapter 13, we mentioned that the definition of the <code class="language-plaintext highlighter-rouge">Iterator</code> trait is as shown in Listing 19-12.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="nb">Iterator</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-12-the-definition-of-the-iterator-trait-that-has-an-associated-type-item">Listing 19-12: The definition of the Iterator trait that has an associated type Item</h4>

<p>The type <code class="language-plaintext highlighter-rouge">Item</code> is a placeholder type, and the <code class="language-plaintext highlighter-rouge">next</code> method’s definition shows that it will return values of type <code class="language-plaintext highlighter-rouge">Option&lt;Self::Item&gt;</code>. 
Implementors of the <code class="language-plaintext highlighter-rouge">Iterator</code> trait will specify the concrete type for <code class="language-plaintext highlighter-rouge">Item</code>, and the <code class="language-plaintext highlighter-rouge">next</code> method will return an <code class="language-plaintext highlighter-rouge">Option</code> containing a value of that concrete type.</p>

<p>Associated types might seem like a similar concept to generics, in that the latter allow us to define a function without specifying what types it can handle. 
So why use associated types?</p>

<p>Let’s examine the difference between the two concepts with an example from Chapter 13 that implements the <code class="language-plaintext highlighter-rouge">Iterator</code> trait on the <code class="language-plaintext highlighter-rouge">Counter</code> struct. 
In Listing 13-21, we specified that the <code class="language-plaintext highlighter-rouge">Item</code> type was <code class="language-plaintext highlighter-rouge">u32</code>:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>

<span class="k">impl</span> <span class="nb">Iterator</span> <span class="k">for</span> <span class="n">Counter</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="nb">u32</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// --snip--</span>
</code></pre></div></div>

<p>This syntax seems comparable to that of generics. So why not just define the <code class="language-plaintext highlighter-rouge">Iterator</code> trait with generics, as shown in Listing 19-13?</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-13-a-hypothetical-definition-of-the-iterator-trait-using-generics">Listing 19-13: A hypothetical definition of the Iterator trait using generics</h4>

<p>The difference is that when using generics, as in Listing 19-13, we must annotate the types in each implementation; because we can also implement <code class="language-plaintext highlighter-rouge">Iterator&lt;String&gt; for Counter</code> or any other type, we could have multiple implementations of <code class="language-plaintext highlighter-rouge">Iterator</code> for <code class="language-plaintext highlighter-rouge">Counter</code>. 
In other words, when a trait has a generic parameter, it can be implemented for a type multiple times, changing the concrete types of the generic type parameters each time. When we use the <code class="language-plaintext highlighter-rouge">next</code> method on <code class="language-plaintext highlighter-rouge">Counter</code>, we would have to provide type annotations to indicate which implementation of <code class="language-plaintext highlighter-rouge">Iterator</code> we want to use.</p>

<p>With associated types, we don’t need to annotate types because we can’t implement a trait on a type multiple times. 
In Listing 19-12 with the definition that uses associated types, we can only choose what the type of <code class="language-plaintext highlighter-rouge">Item</code> will be once, because there can only be one <code class="language-plaintext highlighter-rouge">impl Iterator for Counter</code>. 
We don’t have to specify that we want an iterator of <code class="language-plaintext highlighter-rouge">u32</code> values everywhere that we call <code class="language-plaintext highlighter-rouge">next</code> on <code class="language-plaintext highlighter-rouge">Counter</code>.</p>

<h3 id="default-generic-type-parameters-and-operator-overloading">Default Generic Type Parameters and Operator Overloading</h3>
<p>When we use generic type parameters, we can specify a default concrete type for the generic type. 
This eliminates the need for implementors of the trait to specify a concrete type if the default type works. 
The syntax for specifying a default type for a generic type is <code class="language-plaintext highlighter-rouge">&lt;PlaceholderType=ConcreteType&gt;</code> when declaring the generic type.</p>

<p>A great example of a situation where this technique is useful is with operator overloading. 
<em>Operator overloading</em> is customizing the behavior of an operator (such as <code class="language-plaintext highlighter-rouge">+</code>) in particular situations.</p>

<p>Rust doesn’t allow you to create your own operators or overload arbitrary operators. 
But you can overload the operations and corresponding traits listed in <code class="language-plaintext highlighter-rouge">std::ops</code> by implementing the traits associated with the operator. 
For example, in Listing 19-14 we overload the <code class="language-plaintext highlighter-rouge">+</code> operator to add two <code class="language-plaintext highlighter-rouge">Point</code> instances together. 
We do this by implementing the <code class="language-plaintext highlighter-rouge">Add</code> trait on a <code class="language-plaintext highlighter-rouge">Point</code> struct:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ops</span><span class="p">::</span><span class="nb">Add</span><span class="p">;</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq)]</span>
<span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Add</span> <span class="k">for</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">Point</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Point</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Point</span> <span class="p">{</span>
        <span class="n">Point</span> <span class="p">{</span>
            <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span> <span class="o">+</span> <span class="n">other</span><span class="py">.x</span><span class="p">,</span>
            <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span> <span class="o">+</span> <span class="n">other</span><span class="py">.y</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">assert_eq!</span><span class="p">(</span>
        <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">0</span> <span class="p">}</span> <span class="o">+</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">3</span> <span class="p">},</span>
        <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">3</span> <span class="p">}</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-14-implementing-the-add-trait-to-overload-the--operator-for-point-instances">Listing 19-14: Implementing the Add trait to overload the + operator for Point instances</h4>

<p>The <code class="language-plaintext highlighter-rouge">add</code> method adds the <code class="language-plaintext highlighter-rouge">x</code> values of two <code class="language-plaintext highlighter-rouge">Point</code> instances and the <code class="language-plaintext highlighter-rouge">y</code> values of two <code class="language-plaintext highlighter-rouge">Point</code> instances to create a new <code class="language-plaintext highlighter-rouge">Point</code>. 
The <code class="language-plaintext highlighter-rouge">Add</code> trait has an associated type named <code class="language-plaintext highlighter-rouge">Output</code> that determines the type returned from the <code class="language-plaintext highlighter-rouge">add</code> method.</p>

<p>The default generic type in this code is within the <code class="language-plaintext highlighter-rouge">Add</code> trait. Here is its definition:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nb">Add</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">=</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">Rhs</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This code should look generally familiar: a trait with one method and an associated type. 
The new part is <code class="language-plaintext highlighter-rouge">Rhs=Self</code>: this syntax is c<em>alled default type parameters</em>. 
The <code class="language-plaintext highlighter-rouge">Rhs</code> generic type parameter (short for “right hand side”) defines the type of the <code class="language-plaintext highlighter-rouge">rhs</code> parameter in the <code class="language-plaintext highlighter-rouge">add</code> method. 
If we don’t specify a concrete type for <code class="language-plaintext highlighter-rouge">Rhs</code> when we implement the <code class="language-plaintext highlighter-rouge">Add</code> trait, the type of <code class="language-plaintext highlighter-rouge">Rhs</code> will default to <code class="language-plaintext highlighter-rouge">Self</code>, which will be the type we’re implementing <code class="language-plaintext highlighter-rouge">Add</code> on.</p>

<p>When we implemented <code class="language-plaintext highlighter-rouge">Add</code> for <code class="language-plaintext highlighter-rouge">Point</code>, we used the default for <code class="language-plaintext highlighter-rouge">Rhs</code> because we wanted to add two <code class="language-plaintext highlighter-rouge">Point</code> instances. 
Let’s look at an example of implementing the <code class="language-plaintext highlighter-rouge">Add</code> trait where we want to customize the <code class="language-plaintext highlighter-rouge">Rhs</code> type rather than using the default.</p>

<p>We have two structs, <code class="language-plaintext highlighter-rouge">Millimeters</code> and <code class="language-plaintext highlighter-rouge">Meters</code>, holding values in different units. 
We want to add values in millimeters to values in meters and have the implementation of <code class="language-plaintext highlighter-rouge">Add</code> do the conversion correctly. 
We can implement <code class="language-plaintext highlighter-rouge">Add</code> for <code class="language-plaintext highlighter-rouge">Millimeters</code> with <code class="language-plaintext highlighter-rouge">Meters</code> as the <code class="language-plaintext highlighter-rouge">Rhs</code>, as shown in Listing 19-15.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ops</span><span class="p">::</span><span class="nb">Add</span><span class="p">;</span>

<span class="k">struct</span> <span class="nf">Millimeters</span><span class="p">(</span><span class="nb">u32</span><span class="p">);</span>
<span class="k">struct</span> <span class="nf">Meters</span><span class="p">(</span><span class="nb">u32</span><span class="p">);</span>

<span class="k">impl</span> <span class="nb">Add</span><span class="o">&lt;</span><span class="n">Meters</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Millimeters</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">Millimeters</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Meters</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Millimeters</span> <span class="p">{</span>
        <span class="nf">Millimeters</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span> <span class="o">+</span> <span class="p">(</span><span class="n">other</span><span class="na">.0</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-15-implementing-the-add-trait-on-millimeters-to-add-millimeters-to-meters">Listing 19-15: Implementing the Add trait on Millimeters to add Millimeters to Meters</h4>

<p>To add <code class="language-plaintext highlighter-rouge">Millimeters</code> and <code class="language-plaintext highlighter-rouge">Meters</code>, we specify <code class="language-plaintext highlighter-rouge">impl Add&lt;Meters&gt;</code> to set the value of the <code class="language-plaintext highlighter-rouge">Rhs</code> type parameter instead of using the default of <code class="language-plaintext highlighter-rouge">Self</code>.</p>

<p>You’ll use default type parameters in two main ways:</p>

<ul>
  <li>To extend a type without breaking existing code</li>
  <li>To allow customization in specific cases most users won’t need</li>
</ul>

<p>The standard library’s <code class="language-plaintext highlighter-rouge">Add</code> trait is an example of the second purpose: usually, you’ll add two like types, but the <code class="language-plaintext highlighter-rouge">Add</code> trait provides the ability to customize beyond that. 
Using a default type parameter in the <code class="language-plaintext highlighter-rouge">Add</code> trait definition means you don’t have to specify the extra parameter most of the time. In other words, a bit of implementation boilerplate isn’t needed, making it easier to use the trait.</p>

<p>The first purpose is similar to the second but in reverse: if you want to add a type parameter to an existing trait, you can give it a default to allow extension of the functionality of the trait without breaking the existing implementation code.</p>

<h3 id="fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name</h3>
<p>Nothing in Rust prevents a trait from having a method with the same name as another trait’s method, nor does Rust prevent you from implementing both traits on one type. It’s also possible to implement a method directly on the type with the same name as methods from traits.</p>

<p>When calling methods with the same name, you’ll need to tell Rust which one you want to use. 
Consider the code in Listing 19-16 where we’ve defined two traits, <code class="language-plaintext highlighter-rouge">Pilot</code> and <code class="language-plaintext highlighter-rouge">Wizard</code>, that both have a method called <code class="language-plaintext highlighter-rouge">fly</code>. 
We then implement both traits on a type <code class="language-plaintext highlighter-rouge">Human</code> that already has a method named <code class="language-plaintext highlighter-rouge">fly</code> implemented on it. 
Each <code class="language-plaintext highlighter-rouge">fly</code> method does something different.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">trait</span> <span class="n">Pilot</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">Wizard</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Human</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">Pilot</span> <span class="k">for</span> <span class="n">Human</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"This is your captain speaking."</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Wizard</span> <span class="k">for</span> <span class="n">Human</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Up!"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Human</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"*waving arms furiously*"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-16-two-traits-are-defined-to-have-a-fly-method-and-are-implemented-on-the-human-type-and-a-fly-method-is-implemented-on-human-directly">Listing 19-16: Two traits are defined to have a fly method and are implemented on the Human type, and a fly method is implemented on Human directly</h4>

<p>When we call <code class="language-plaintext highlighter-rouge">fly</code> on an instance of <code class="language-plaintext highlighter-rouge">Human</code>, the compiler defaults to calling the method that is directly implemented on the type, as shown in Listing 19-17.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">person</span> <span class="o">=</span> <span class="n">Human</span><span class="p">;</span>
    <span class="n">person</span><span class="nf">.fly</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-17-calling-fly-on-an-instance-of-human">Listing 19-17: Calling fly on an instance of Human</h4>

<p>Running this code will print <code class="language-plaintext highlighter-rouge">*waving arms furiously*</code>, showing that Rust called the <code class="language-plaintext highlighter-rouge">fly</code> method implemented on <code class="language-plaintext highlighter-rouge">Human</code> directly.</p>

<p>To call the <code class="language-plaintext highlighter-rouge">fly</code> methods from either the <code class="language-plaintext highlighter-rouge">Pilot</code> trait or the <code class="language-plaintext highlighter-rouge">Wizard</code> trait, we need to use more explicit syntax to specify which <code class="language-plaintext highlighter-rouge">fly</code> method we mean. Listing 19-18 demonstrates this syntax.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">person</span> <span class="o">=</span> <span class="n">Human</span><span class="p">;</span>
    <span class="nn">Pilot</span><span class="p">::</span><span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="n">person</span><span class="p">);</span>
    <span class="nn">Wizard</span><span class="p">::</span><span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="n">person</span><span class="p">);</span>
    <span class="n">person</span><span class="nf">.fly</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-18-specifying-which-traits-fly-method-we-want-to-call">Listing 19-18: Specifying which trait’s fly method we want to call</h4>

<p>Specifying the trait name before the method name clarifies to Rust which implementation of <code class="language-plaintext highlighter-rouge">fly</code> we want to call. 
We could also write <code class="language-plaintext highlighter-rouge">Human::fly(&amp;person)</code>, which is equivalent to the <code class="language-plaintext highlighter-rouge">person.fly()</code> that we used in Listing 19-18, but this is a bit longer to write if we don’t need to disambiguate.</p>

<p>Running this code prints the following:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="n">traits</span><span class="o">-</span><span class="n">example</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/traits-example)</span>
    <span class="n">Finished</span> <span class="n">dev</span> <span class="p">[</span><span class="n">unoptimized</span> <span class="o">+</span> <span class="n">debuginfo</span><span class="p">]</span> <span class="nf">target</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">in</span> <span class="mf">0.46</span><span class="n">s</span>
     <span class="n">Running</span> <span class="err">`</span><span class="n">target</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">traits</span><span class="o">-</span><span class="n">example</span><span class="err">`</span>
<span class="n">This</span> <span class="n">is</span> <span class="n">your</span> <span class="n">captain</span> <span class="n">speaking</span><span class="py">.
Up</span><span class="o">!</span>
<span class="o">*</span><span class="n">waving</span> <span class="n">arms</span> <span class="n">furiously</span><span class="o">*</span>
</code></pre></div></div>
<p>Because the <code class="language-plaintext highlighter-rouge">fly</code> method takes a <code class="language-plaintext highlighter-rouge">self</code> parameter, if we had two <em>types</em> that both implement one trait, Rust could figure out which implementation of a trait to use based on the type of <code class="language-plaintext highlighter-rouge">self</code>.</p>

<p>However, associated functions that are part of traits don’t have a <code class="language-plaintext highlighter-rouge">self</code> parameter. 
When two types in the same scope implement that trait, Rust can’t figure out which type you mean unless you use <em>fully qualified syntax</em>. 
For example, the <code class="language-plaintext highlighter-rouge">Animal</code> trait in Listing 19-19 has the associated function <code class="language-plaintext highlighter-rouge">baby_name</code>, 
the implementation of <code class="language-plaintext highlighter-rouge">Animal</code> for the struct <code class="language-plaintext highlighter-rouge">Dog</code>, and the associated function <code class="language-plaintext highlighter-rouge">baby_name</code> defined on <code class="language-plaintext highlighter-rouge">Dog</code> directly.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">trait</span> <span class="n">Animal</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">baby_name</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Dog</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">Dog</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">baby_name</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Spot"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Animal</span> <span class="k">for</span> <span class="n">Dog</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">baby_name</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"puppy"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"A baby dog is called a {}"</span><span class="p">,</span> <span class="nn">Dog</span><span class="p">::</span><span class="nf">baby_name</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-19-a-trait-with-an-associated-function-and-a-type-with-an-associated-function-of-the-same-name-that-also-implements-the-trait">Listing 19-19: A trait with an associated function and a type with an associated function of the same name that also implements the trait</h4>

<p>This code is for an animal shelter that wants to name all puppies Spot, which is implemented in the <code class="language-plaintext highlighter-rouge">baby_name</code> associated function that is defined on <code class="language-plaintext highlighter-rouge">Dog</code>. 
The <code class="language-plaintext highlighter-rouge">Dog</code> type also implements the trait <code class="language-plaintext highlighter-rouge">Animal</code>, which describes characteristics that all animals have. 
Baby dogs are called puppies, and that is expressed in the implementation of the <code class="language-plaintext highlighter-rouge">Animal</code> trait on <code class="language-plaintext highlighter-rouge">Dog</code> in the <code class="language-plaintext highlighter-rouge">baby_name</code> function associated with the <code class="language-plaintext highlighter-rouge">Animal</code> trait.</p>

<p>In <code class="language-plaintext highlighter-rouge">main</code>, we call the <code class="language-plaintext highlighter-rouge">Dog::baby_name</code> function, which calls the associated function defined on <code class="language-plaintext highlighter-rouge">Dog</code> directly. 
This code prints the following:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="n">traits</span><span class="o">-</span><span class="n">example</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/traits-example)</span>
    <span class="n">Finished</span> <span class="n">dev</span> <span class="p">[</span><span class="n">unoptimized</span> <span class="o">+</span> <span class="n">debuginfo</span><span class="p">]</span> <span class="nf">target</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">in</span> <span class="mf">0.54</span><span class="n">s</span>
     <span class="n">Running</span> <span class="err">`</span><span class="n">target</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">traits</span><span class="o">-</span><span class="n">example</span><span class="err">`</span>
<span class="n">A</span> <span class="n">baby</span> <span class="n">dog</span> <span class="n">is</span> <span class="n">called</span> <span class="n">a</span> <span class="n">Spot</span>
</code></pre></div></div>
<p>This output isn’t what we wanted. 
We want to call the <code class="language-plaintext highlighter-rouge">baby_name</code> function that is part of the <code class="language-plaintext highlighter-rouge">Animal</code> trait that we implemented on <code class="language-plaintext highlighter-rouge">Dog</code> so the code prints <code class="language-plaintext highlighter-rouge">A baby dog is called a puppy</code>. 
The technique of specifying the trait name that we used in Listing 19-18 doesn’t help here; if we change <code class="language-plaintext highlighter-rouge">main</code> to the code in Listing 19-20, we’ll get a compilation error.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"A baby dog is called a {}"</span><span class="p">,</span> <span class="nn">Animal</span><span class="p">::</span><span class="nf">baby_name</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-20-attempting-to-call-the-baby_name-function-from-the-animal-trait-but-rust-doesnt-know-which-implementation-to-use">Listing 19-20: Attempting to call the baby_name function from the Animal trait, but Rust doesn’t know which implementation to use</h4>

<p>Because <code class="language-plaintext highlighter-rouge">Animal::baby_name</code> is an associated function rather than a method, and thus doesn’t have a <code class="language-plaintext highlighter-rouge">self</code> parameter, Rust can’t figure out which implementation of <code class="language-plaintext highlighter-rouge">Animal::baby_name</code> we want. 
We’ll get this compiler error:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="n">traits</span><span class="o">-</span><span class="n">example</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/traits-example)</span>
<span class="n">error</span><span class="p">[</span><span class="n">E0283</span><span class="p">]:</span> <span class="k">type</span> <span class="n">annotations</span> <span class="n">needed</span>
  <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">20</span><span class="p">:</span><span class="mi">43</span>
   <span class="p">|</span>
<span class="mi">2</span>  <span class="p">|</span>     <span class="k">fn</span> <span class="nf">baby_name</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span>
   <span class="p">|</span>     <span class="o">-------------------------</span> <span class="n">required</span> <span class="n">by</span> <span class="err">`</span><span class="nn">Animal</span><span class="p">::</span><span class="n">baby_name</span><span class="err">`</span>
<span class="o">...</span>
<span class="mi">20</span> <span class="p">|</span>     <span class="nd">println!</span><span class="p">(</span><span class="s">"A baby dog is called a {}"</span><span class="p">,</span> <span class="nn">Animal</span><span class="p">::</span><span class="nf">baby_name</span><span class="p">());</span>
   <span class="p">|</span>                                           <span class="o">^^^^^^^^^^^^^^^^^</span> <span class="n">cannot</span> <span class="n">infer</span> <span class="k">type</span>
   <span class="p">|</span>
   <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">cannot</span> <span class="n">resolve</span> <span class="err">`</span><span class="n">_</span><span class="p">:</span> <span class="n">Animal</span><span class="err">`</span>

<span class="n">error</span><span class="p">:</span> <span class="n">aborting</span> <span class="n">due</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">error</span>

<span class="n">For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">about</span> <span class="n">this</span> <span class="n">error</span><span class="p">,</span> <span class="k">try</span> <span class="err">`</span><span class="n">rustc</span> <span class="o">--</span><span class="n">explain</span> <span class="n">E0283</span><span class="err">`</span><span class="py">.
error</span><span class="p">:</span> <span class="n">could</span> <span class="n">not</span> <span class="n">compile</span> <span class="err">`</span><span class="n">traits</span><span class="o">-</span><span class="n">example</span><span class="err">`</span><span class="py">.

To</span> <span class="n">learn</span> <span class="n">more</span><span class="p">,</span> <span class="n">run</span> <span class="n">the</span> <span class="n">command</span> <span class="n">again</span> <span class="n">with</span> <span class="o">--</span><span class="n">verbose</span><span class="err">.</span>
</code></pre></div></div>
<p>To disambiguate and tell Rust that we want to use the implementation of <code class="language-plaintext highlighter-rouge">Animal</code> for <code class="language-plaintext highlighter-rouge">Dog</code>, we need to use fully qualified syntax. Listing 19-21 demonstrates how to use fully qualified syntax.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"A baby dog is called a {}"</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">Dog</span> <span class="k">as</span> <span class="n">Animal</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">baby_name</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-21-using-fully-qualified-syntax-to-specify-that-we-want-to-call-the-baby_name-function-from-the-animal-trait-as-implemented-on-dog">Listing 19-21: Using fully qualified syntax to specify that we want to call the baby_name function from the Animal trait as implemented on Dog</h4>

<p>We’re providing Rust with a type annotation within the angle brackets, which indicates we want to call the <code class="language-plaintext highlighter-rouge">baby_name</code> method from the <code class="language-plaintext highlighter-rouge">Animal</code> trait as implemented on <code class="language-plaintext highlighter-rouge">Dog</code> by saying that we want to treat the <code class="language-plaintext highlighter-rouge">Dog</code> type as an Animal for this function call. 
This code will now print what we want:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="n">traits</span><span class="o">-</span><span class="n">example</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/traits-example)</span>
    <span class="n">Finished</span> <span class="n">dev</span> <span class="p">[</span><span class="n">unoptimized</span> <span class="o">+</span> <span class="n">debuginfo</span><span class="p">]</span> <span class="nf">target</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">in</span> <span class="mf">0.48</span><span class="n">s</span>
     <span class="n">Running</span> <span class="err">`</span><span class="n">target</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">traits</span><span class="o">-</span><span class="n">example</span><span class="err">`</span>
<span class="n">A</span> <span class="n">baby</span> <span class="n">dog</span> <span class="n">is</span> <span class="n">called</span> <span class="n">a</span> <span class="n">puppy</span>
</code></pre></div></div>
<p>In general, fully qualified syntax is defined as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);
</code></pre></div></div>

<p>For associated functions, there would not be a <code class="language-plaintext highlighter-rouge">receiver</code>: there would only be the list of other arguments. You could use fully qualified syntax everywhere that you call functions or methods. However, you’re allowed to omit any part of this syntax that Rust can figure out from other information in the program. You only need to use this more verbose syntax in cases where there are multiple implementations that use the same name and Rust needs help to identify which implementation you want to call.</p>

<h3 id="using-supertraits-to-require-one-traits-functionality-within-another-trait">Using Supertraits to Require One Trait’s Functionality Within Another Trait</h3>
<p>Sometimes, you might need one trait to use another trait’s functionality. 
In this case, you need to rely on the dependent trait also being implemented. 
The trait you rely on is a <em>supertrait</em> of the trait you’re implementing.</p>

<p>For example, let’s say we want to make an <code class="language-plaintext highlighter-rouge">OutlinePrint</code> trait with an <code class="language-plaintext highlighter-rouge">outline_print</code> method that will print a value framed in asterisks. 
That is, given a <code class="language-plaintext highlighter-rouge">Point</code> struct that implements <code class="language-plaintext highlighter-rouge">Display</code> to result in <code class="language-plaintext highlighter-rouge">(x, y)</code>, when we call <code class="language-plaintext highlighter-rouge">outline_print</code> on a <code class="language-plaintext highlighter-rouge">Point</code> instance that has <code class="language-plaintext highlighter-rouge">1</code> for <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">3</code> for <code class="language-plaintext highlighter-rouge">y</code>, it should print the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>**********
*        *
* (1, 3) *
*        *
**********
</code></pre></div></div>

<p>In the implementation of <code class="language-plaintext highlighter-rouge">outline_print</code>, we want to use the <code class="language-plaintext highlighter-rouge">Display</code> trait’s functionality. 
Therefore, we need to specify that the <code class="language-plaintext highlighter-rouge">OutlinePrint</code> trait will work only for types that also implement <code class="language-plaintext highlighter-rouge">Display</code> and provide the functionality that <code class="language-plaintext highlighter-rouge">OutlinePrint</code> needs. 
We can do that in the trait definition by specifying <code class="language-plaintext highlighter-rouge">OutlinePrint: Display</code>. 
This technique is similar to adding a trait bound to the trait. 
Listing 19-22 shows an implementation of the <code class="language-plaintext highlighter-rouge">OutlinePrint</code> trait.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fmt</span><span class="p">;</span>

<span class="k">trait</span> <span class="n">OutlinePrint</span><span class="p">:</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">outline_print</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.to_string</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">output</span><span class="nf">.len</span><span class="p">();</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"*"</span><span class="nf">.repeat</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">4</span><span class="p">));</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"*{}*"</span><span class="p">,</span> <span class="s">" "</span><span class="nf">.repeat</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">));</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"* {} *"</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"*{}*"</span><span class="p">,</span> <span class="s">" "</span><span class="nf">.repeat</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">));</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"*"</span><span class="nf">.repeat</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">4</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-22-implementing-the-outlineprint-trait-that-requires-the-functionality-from-display">Listing 19-22: Implementing the OutlinePrint trait that requires the functionality from Display</h4>
<p>Because we’ve specified that <code class="language-plaintext highlighter-rouge">OutlinePrint</code> requires the <code class="language-plaintext highlighter-rouge">Display</code> trait, we can use the <code class="language-plaintext highlighter-rouge">to_string</code> function that is automatically implemented for any type that implements <code class="language-plaintext highlighter-rouge">Display</code>. 
If we tried to use <code class="language-plaintext highlighter-rouge">to_string</code> without adding a colon and specifying the <code class="language-plaintext highlighter-rouge">Display</code> trait after the trait name, we’d get an error saying that no method named <code class="language-plaintext highlighter-rouge">to_string</code> was found for the type <code class="language-plaintext highlighter-rouge">&amp;Self</code> in the current scope.</p>

<p>Let’s see what happens when we try to implement <code class="language-plaintext highlighter-rouge">OutlinePrint</code> on a type that doesn’t implement <code class="language-plaintext highlighter-rouge">Display</code>, such as the <code class="language-plaintext highlighter-rouge">Point</code> struct:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">OutlinePrint</span> <span class="k">for</span> <span class="n">Point</span> <span class="p">{}</span>
</code></pre></div></div>
<p>We get an error saying that <code class="language-plaintext highlighter-rouge">Display</code> is required but not implemented:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">run</span>
   <span class="n">Compiling</span> <span class="n">traits</span><span class="o">-</span><span class="n">example</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/traits-example)</span>
<span class="n">error</span><span class="p">[</span><span class="n">E0277</span><span class="p">]:</span> <span class="err">`</span><span class="n">Point</span><span class="err">`</span> <span class="n">doesn</span><span class="nv">'t</span> <span class="n">implement</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span><span class="err">`</span>
  <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">20</span><span class="p">:</span><span class="mi">6</span>
   <span class="p">|</span>
<span class="mi">20</span> <span class="p">|</span> <span class="k">impl</span> <span class="n">OutlinePrint</span> <span class="k">for</span> <span class="n">Point</span> <span class="p">{}</span>
   <span class="p">|</span>      <span class="o">^^^^^^^^^^^^</span> <span class="err">`</span><span class="n">Point</span><span class="err">`</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">formatted</span> <span class="n">with</span> <span class="n">the</span> <span class="n">default</span> <span class="n">formatter</span>
   <span class="p">|</span>
   <span class="o">=</span> <span class="n">help</span><span class="p">:</span> <span class="n">the</span> <span class="k">trait</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span><span class="err">`</span> <span class="n">is</span> <span class="n">not</span> <span class="n">implemented</span> <span class="k">for</span> <span class="err">`</span><span class="n">Point</span><span class="err">`</span>
   <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="k">in</span> <span class="n">format</span> <span class="n">strings</span> <span class="n">you</span> <span class="n">may</span> <span class="n">be</span> <span class="n">able</span> <span class="n">to</span> <span class="k">use</span> <span class="err">`</span><span class="p">{:</span><span class="o">?</span><span class="p">}</span><span class="err">`</span> <span class="p">(</span><span class="n">or</span> <span class="p">{:</span><span class="err">#</span><span class="o">?</span><span class="p">}</span> <span class="k">for</span> <span class="n">pretty</span><span class="o">-</span><span class="n">print</span><span class="p">)</span> <span class="n">instead</span>

<span class="n">error</span><span class="p">:</span> <span class="n">aborting</span> <span class="n">due</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">error</span>

<span class="n">For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">about</span> <span class="n">this</span> <span class="n">error</span><span class="p">,</span> <span class="k">try</span> <span class="err">`</span><span class="n">rustc</span> <span class="o">--</span><span class="n">explain</span> <span class="n">E0277</span><span class="err">`</span><span class="py">.
error</span><span class="p">:</span> <span class="n">could</span> <span class="n">not</span> <span class="n">compile</span> <span class="err">`</span><span class="n">traits</span><span class="o">-</span><span class="n">example</span><span class="err">`</span><span class="py">.

To</span> <span class="n">learn</span> <span class="n">more</span><span class="p">,</span> <span class="n">run</span> <span class="n">the</span> <span class="n">command</span> <span class="n">again</span> <span class="n">with</span> <span class="o">--</span><span class="n">verbose</span><span class="err">.</span>
</code></pre></div></div>
<p>To fix this, we implement <code class="language-plaintext highlighter-rouge">Display</code> on <code class="language-plaintext highlighter-rouge">Point</code> and satisfy the constraint that <code class="language-plaintext highlighter-rouge">OutlinePrint</code> requires, like so:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fmt</span><span class="p">;</span>

<span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="k">for</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"({}, {})"</span><span class="p">,</span> <span class="k">self</span><span class="py">.x</span><span class="p">,</span> <span class="k">self</span><span class="py">.y</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then implementing the <code class="language-plaintext highlighter-rouge">OutlinePrint</code> trait on <code class="language-plaintext highlighter-rouge">Point</code> will compile successfully, and we can call <code class="language-plaintext highlighter-rouge">outline_print</code> on a <code class="language-plaintext highlighter-rouge">Point</code> instance to display it within an outline of asterisks.</p>

<h3 id="using-the-newtype-pattern-to-implement-external-traits-on-external-types">Using the Newtype Pattern to Implement External Traits on External Types</h3>
<p>In Chapter 10 in the “Implementing a Trait on a Type” section, we mentioned the orphan rule that states we’re allowed to implement a trait on a type as long as either the trait or the type are local to our crate. 
It’s possible to get around this restriction using the <em>newtype pattern</em>, which involves creating a new type in a tuple struct. 
(We covered tuple structs in the “Using Tuple Structs without Named Fields to Create Different Types” section of Chapter 5.) 
The tuple struct will have one field and be a thin wrapper around the type we want to implement a trait for. 
Then the wrapper type is local to our crate, and we can implement the trait on the wrapper. 
<em>Newtype</em> is a term that originates from the Haskell programming language. 
There is no runtime performance penalty for using this pattern, and the wrapper type is elided at compile time.</p>

<p>As an example, let’s say we want to implement <code class="language-plaintext highlighter-rouge">Display</code> on <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code>, which the orphan rule prevents us from doing directly because the <code class="language-plaintext highlighter-rouge">Display</code> trait and the <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code> type are defined outside our crate. 
We can make a <code class="language-plaintext highlighter-rouge">Wrapper</code> struct that holds an instance of <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code>; then we can implement <code class="language-plaintext highlighter-rouge">Display</code> on <code class="language-plaintext highlighter-rouge">Wrapper</code> and use the <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code> value, as shown in Listing 19-23.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fmt</span><span class="p">;</span>

<span class="k">struct</span> <span class="nf">Wrapper</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">);</span>

<span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="k">for</span> <span class="n">Wrapper</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"[{}]"</span><span class="p">,</span> <span class="k">self</span><span class="na">.0</span><span class="nf">.join</span><span class="p">(</span><span class="s">", "</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">w</span> <span class="o">=</span> <span class="nf">Wrapper</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">),</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"world"</span><span class="p">)]);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"w = {}"</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-23-creating-a-wrapper-type-around-vec-to-implement-display">Listing 19-23: Creating a Wrapper type around Vec<String> to implement Display</String></h4>

<p>The implementation of <code class="language-plaintext highlighter-rouge">Display</code> uses <code class="language-plaintext highlighter-rouge">self.0</code> to access the inner <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code>, because <code class="language-plaintext highlighter-rouge">Wrapper</code> is a tuple struct and <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code> is the item at index 0 in the tuple. 
Then we can use the functionality of the <code class="language-plaintext highlighter-rouge">Display</code> type on <code class="language-plaintext highlighter-rouge">Wrapper</code>.</p>

<p>The downside of using this technique is that <code class="language-plaintext highlighter-rouge">Wrapper</code> is a new type, so it doesn’t have the methods of the value it’s holding. 
We would have to implement all the methods of <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code> directly on <code class="language-plaintext highlighter-rouge">Wrapper</code> such that the methods delegate to <code class="language-plaintext highlighter-rouge">self.0</code>, which would allow us to treat <code class="language-plaintext highlighter-rouge">Wrapper</code> exactly like a <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code>. 
If we wanted the new type to have every method the inner type has, implementing the <code class="language-plaintext highlighter-rouge">Deref</code> trait (discussed in Chapter 15 in the “Treating Smart Pointers Like Regular References with the Deref Trait” section) on the <code class="language-plaintext highlighter-rouge">Wrapper</code> to return the inner type would be a solution. 
If we don’t want the <code class="language-plaintext highlighter-rouge">Wrapper</code> type to have all the methods of the inner type—for example, to restrict the <code class="language-plaintext highlighter-rouge">Wrapper</code> type’s behavior—we would have to implement just the methods we do want manually.</p>

<p>Now you know how the newtype pattern is used in relation to traits; it’s also a useful pattern even when traits are not involved. Let’s switch focus and look at some advanced ways to interact with Rust’s type system.</p>

<h2 id="advanced-types">Advanced Types</h2>
<p>The Rust type system has some features that we’ve mentioned in this book but haven’t yet discussed. 
We’ll start by discussing newtypes in general as we examine why newtypes are useful as types. 
Then we’ll move on to type aliases, a feature similar to newtypes but with slightly different semantics. 
We’ll also discuss the <code class="language-plaintext highlighter-rouge">!</code> type and dynamically sized types.</p>

<p class="notice--info"><strong>Note</strong>: The next section assumes you’ve read the earlier section “Using the Newtype Pattern to Implement External Traits on External Types.”</p>

<h3 id="using-the-newtype-pattern-for-type-safety-and-abstraction">Using the Newtype Pattern for Type Safety and Abstraction</h3>
<p>The newtype pattern is useful for tasks beyond those we’ve discussed so far, including statically enforcing that values are never confused and indicating the units of a value. 
You saw an example of using newtypes to indicate units in Listing 19-15: recall that the <code class="language-plaintext highlighter-rouge">Millimeters</code> and <code class="language-plaintext highlighter-rouge">Meters</code> structs wrapped <code class="language-plaintext highlighter-rouge">u32</code> values in a newtype. 
If we wrote a function with a parameter of type <code class="language-plaintext highlighter-rouge">Millimeters</code>, we couldn’t compile a program that accidentally tried to call that function with a value of type <code class="language-plaintext highlighter-rouge">Meters</code> or a plain <code class="language-plaintext highlighter-rouge">u32</code>.</p>

<p>Another use of the newtype pattern is in abstracting away some implementation details of a type: the new type can expose a public API that is different from the API of the private inner type if we used the new type directly to restrict the available functionality, for example.</p>

<p>Newtypes can also hide internal implementation. 
For example, we could provide a <code class="language-plaintext highlighter-rouge">People</code> type to wrap a <code class="language-plaintext highlighter-rouge">HashMap&lt;i32, String&gt;</code> that stores a person’s ID associated with their name. 
Code using <code class="language-plaintext highlighter-rouge">People</code> would only interact with the public API we provide, such as a method to add a name string to the <code class="language-plaintext highlighter-rouge">People</code> collection; that code wouldn’t need to know that we assign an <code class="language-plaintext highlighter-rouge">i32</code> ID to names internally. 
The newtype pattern is a lightweight way to achieve encapsulation to hide implementation details, which we discussed in the “Encapsulation that Hides Implementation Details” section of Chapter 17.</p>

<h3 id="creating-type-synonyms-with-type-aliases">Creating Type Synonyms with Type Aliases</h3>
<p>Along with the newtype pattern, Rust provides the ability to declare a <em>type alias</em> to give an existing type another name. 
For this we use the <code class="language-plaintext highlighter-rouge">type</code> keyword. 
For example, we can create the alias <code class="language-plaintext highlighter-rouge">Kilometers</code> to <code class="language-plaintext highlighter-rouge">i32</code> like so:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">type</span> <span class="n">Kilometers</span> <span class="o">=</span> <span class="nb">i32</span><span class="p">;</span>
</code></pre></div></div>

<p>Now, the alias <code class="language-plaintext highlighter-rouge">Kilometers</code> is a <strong>synonym</strong> for <code class="language-plaintext highlighter-rouge">i32</code>; unlike the <code class="language-plaintext highlighter-rouge">Millimeters</code> and <code class="language-plaintext highlighter-rouge">Meters</code> types we created in Listing 19-15, <code class="language-plaintext highlighter-rouge">Kilometers</code> is not a separate, new type. 
Values that have the type <code class="language-plaintext highlighter-rouge">Kilometers</code> will be treated the same as values of type <code class="language-plaintext highlighter-rouge">i32</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">type</span> <span class="n">Kilometers</span> <span class="o">=</span> <span class="nb">i32</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">y</span><span class="p">:</span> <span class="n">Kilometers</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"x + y = {}"</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">);</span>
</code></pre></div></div>
<p>Because <code class="language-plaintext highlighter-rouge">Kilometers</code> and <code class="language-plaintext highlighter-rouge">i32</code> are the same type, we can add values of both types and we can pass <code class="language-plaintext highlighter-rouge">Kilometers</code> values to functions that take i32 parameters. 
However, using this method, we don’t get the type checking benefits that we get from the newtype pattern discussed earlier.</p>

<p>The main use case for type synonyms is to reduce repetition. For example, we might have a lengthy type like this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nf">Fn</span><span class="p">()</span> <span class="o">+</span> <span class="nb">Send</span> <span class="o">+</span> <span class="k">'static</span><span class="o">&gt;</span>
</code></pre></div></div>
<p>Writing this lengthy type in function signatures and as type annotations all over the code can be tiresome and error prone. 
Imagine having a project full of code like that in Listing 19-24.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="n">f</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nf">Fn</span><span class="p">()</span> <span class="o">+</span> <span class="nb">Send</span> <span class="o">+</span> <span class="k">'static</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(||</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"hi"</span><span class="p">));</span>

    <span class="k">fn</span> <span class="nf">takes_long_type</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nf">Fn</span><span class="p">()</span> <span class="o">+</span> <span class="nb">Send</span> <span class="o">+</span> <span class="k">'static</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// --snip--</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">returns_long_type</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nf">Fn</span><span class="p">()</span> <span class="o">+</span> <span class="nb">Send</span> <span class="o">+</span> <span class="k">'static</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// --snip--</span>
    <span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-24-using-a-long-type-in-many-places">Listing 19-24: Using a long type in many places</h4>

<p>A type alias makes this code more manageable by reducing the repetition. In Listing 19-25, we’ve introduced an alias named <code class="language-plaintext highlighter-rouge">Thunk</code> for the verbose type and can replace all uses of the type with the shorter alias <code class="language-plaintext highlighter-rouge">Thunk</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">type</span> <span class="n">Thunk</span> <span class="o">=</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nf">Fn</span><span class="p">()</span> <span class="o">+</span> <span class="nb">Send</span> <span class="o">+</span> <span class="k">'static</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">f</span><span class="p">:</span> <span class="n">Thunk</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(||</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"hi"</span><span class="p">));</span>

    <span class="k">fn</span> <span class="nf">takes_long_type</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Thunk</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// --snip--</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">returns_long_type</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Thunk</span> <span class="p">{</span>
        <span class="c1">// --snip--</span>
    <span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-25-introducing-a-type-alias-thunk-to-reduce-repetition">Listing 19-25: Introducing a type alias Thunk to reduce repetition</h4>
<p>This code is much easier to read and write! Choosing a meaningful name for a type alias can help communicate your intent as well (<em>thunk</em> is a word for code to be evaluated at a later time, so it’s an appropriate name for a closure that gets stored).</p>

<p>Type aliases are also commonly used with the <code class="language-plaintext highlighter-rouge">Result&lt;T, E&gt;</code> type for reducing repetition. 
Consider the <code class="language-plaintext highlighter-rouge">std::io</code> module in the standard library. 
I/O operations often return a <code class="language-plaintext highlighter-rouge">Result&lt;T, E&gt;</code> to handle situations when operations fail to work. 
This library has a <code class="language-plaintext highlighter-rouge">std::io::Error</code> struct that represents all possible I/O errors. 
Many of the functions in <code class="language-plaintext highlighter-rouge">std::io</code> will be returning <code class="language-plaintext highlighter-rouge">Result&lt;T, E&gt;</code> where the <code class="language-plaintext highlighter-rouge">E</code> is <code class="language-plaintext highlighter-rouge">std::io::Error</code>, such as these functions in the Write trait:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fmt</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Error</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">trait</span> <span class="n">Write</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">flush</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">write_all</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">write_fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">fmt</span><span class="p">:</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Arguments</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">Result&lt;..., Error&gt;</code> is repeated a lot. As such, <code class="language-plaintext highlighter-rouge">std::io</code> has this type of alias declaration:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">result</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div>
<p>Because this declaration is in the <code class="language-plaintext highlighter-rouge">std::io</code> module, we can use the fully qualified alias <code class="language-plaintext highlighter-rouge">std::io::Result&lt;T&gt;</code>—that is, a <code class="language-plaintext highlighter-rouge">Result&lt;T, E&gt;</code> with the E filled in as <code class="language-plaintext highlighter-rouge">std::io::Error</code>. 
The Write trait function signatures end up looking like this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">Write</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">flush</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">write_all</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">write_fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">fmt</span><span class="p">:</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Arguments</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The type alias helps in two ways: it makes code easier to write <em>and</em> it gives us a consistent interface across all of <code class="language-plaintext highlighter-rouge">std::io</code>. 
Because it’s an alias, it’s just another <code class="language-plaintext highlighter-rouge">Result&lt;T, E&gt;</code>, which means we can use any methods that work on <code class="language-plaintext highlighter-rouge">Result&lt;T, E&gt;</code> with it, as well as special syntax like the <code class="language-plaintext highlighter-rouge">?</code> operator.</p>

<h3 id="the-never-type-that-never-returns">The Never Type that Never Returns</h3>
<p>Rust has a special type named <code class="language-plaintext highlighter-rouge">!</code> that’s known in type theory lingo as the <strong>empty</strong> type because it has no values. 
We prefer to call it the <em>never type</em> because it stands in the place of the return type when a function will never return. Here is an example:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">bar</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">!</span> <span class="p">{</span>
    <span class="c1">// --snip--</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This code is read as “the function <code class="language-plaintext highlighter-rouge">bar</code> returns never.” Functions that return never are called <em>diverging functions</em>. 
We can’t create values of the type <code class="language-plaintext highlighter-rouge">!</code> so <code class="language-plaintext highlighter-rouge">bar</code> can never possibly return.</p>

<p>But what use is a type you can never create values for? Recall the code from Listing 2-5; we’ve reproduced part of it here in Listing 19-26.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">let</span> <span class="n">guess</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="k">match</span> <span class="n">guess</span><span class="nf">.trim</span><span class="p">()</span><span class="nf">.parse</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">num</span><span class="p">,</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">continue</span><span class="p">,</span>
        <span class="p">};</span>
</code></pre></div></div>
<h4 id="listing-19-26-a-match-with-an-arm-that-ends-in-continue">Listing 19-26: A match with an arm that ends in continue</h4>

<p>At the time, we skipped over some details in this code. 
In Chapter 6 in “The <code class="language-plaintext highlighter-rouge">match</code> Control Flow Operator” section, we discussed that <code class="language-plaintext highlighter-rouge">match</code> arms must all return the same type. 
So, for example, the following code doesn’t work:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="n">guess</span> <span class="o">=</span> <span class="k">match</span> <span class="n">guess</span><span class="nf">.trim</span><span class="p">()</span><span class="nf">.parse</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="mi">5</span><span class="p">,</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="s">"hello"</span><span class="p">,</span>
    <span class="p">};</span>
</code></pre></div></div>
<p>The type of <code class="language-plaintext highlighter-rouge">guess</code> in this code would have to be an integer <em>and</em> a string, and Rust requires that <code class="language-plaintext highlighter-rouge">guess</code> have only one type. 
So what does <code class="language-plaintext highlighter-rouge">continue</code> return? How were we allowed to return a <code class="language-plaintext highlighter-rouge">u32</code> from one arm and have another arm that ends with <code class="language-plaintext highlighter-rouge">continue</code> in Listing 19-26?</p>

<p>As you might have guessed, <code class="language-plaintext highlighter-rouge">continue</code> has a <code class="language-plaintext highlighter-rouge">!</code> value. 
That is, when Rust computes the type of <code class="language-plaintext highlighter-rouge">guess</code>, it looks at both match arms, the former with a value of <code class="language-plaintext highlighter-rouge">u32</code> and the latter with a <code class="language-plaintext highlighter-rouge">!</code> value. 
Because <code class="language-plaintext highlighter-rouge">!</code> can never have a value, Rust decides that the type of <code class="language-plaintext highlighter-rouge">guess</code> is <code class="language-plaintext highlighter-rouge">u32</code>.</p>

<p>The formal way of describing this behavior is that expressions of type <code class="language-plaintext highlighter-rouge">!</code> can be coerced into any other type. 
We’re allowed to end this <code class="language-plaintext highlighter-rouge">match</code> arm with <code class="language-plaintext highlighter-rouge">continue</code> because <code class="language-plaintext highlighter-rouge">continue</code> doesn’t return a value; instead, it moves control back to the top of the loop, so in the <code class="language-plaintext highlighter-rouge">Err</code> case, we never assign a value to <code class="language-plaintext highlighter-rouge">guess</code>.</p>

<p>The never type is useful with the <code class="language-plaintext highlighter-rouge">panic!</code> macro as well. 
Remember the <code class="language-plaintext highlighter-rouge">unwrap</code> function that we call on <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code> values to produce a value or panic? Here is its definition:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">unwrap</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">val</span><span class="p">,</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"called `Option::unwrap()` on a `None` value"</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>In this code, the same thing happens as in the <code class="language-plaintext highlighter-rouge">match</code> in Listing 19-26: Rust sees that <code class="language-plaintext highlighter-rouge">val</code> has the type <code class="language-plaintext highlighter-rouge">T</code> and <code class="language-plaintext highlighter-rouge">panic!</code> has the type <code class="language-plaintext highlighter-rouge">!</code>, so the result of the overall <code class="language-plaintext highlighter-rouge">match</code> expression is <code class="language-plaintext highlighter-rouge">T</code>. 
This code works because <code class="language-plaintext highlighter-rouge">panic!</code> doesn’t produce a value; it ends the program. 
In the <code class="language-plaintext highlighter-rouge">None</code> case, we won’t be returning a value from <code class="language-plaintext highlighter-rouge">unwrap</code>, so this code is valid.</p>

<p>One final expression that has the type <code class="language-plaintext highlighter-rouge">!</code> is a <code class="language-plaintext highlighter-rouge">loop</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nd">print!</span><span class="p">(</span><span class="s">"forever "</span><span class="p">);</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nd">print!</span><span class="p">(</span><span class="s">"and ever "</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>Here, the loop never ends, so <code class="language-plaintext highlighter-rouge">!</code> is the value of the expression. 
However, this wouldn’t be true if we included a <code class="language-plaintext highlighter-rouge">break</code>, because the loop would terminate when it got to the <code class="language-plaintext highlighter-rouge">break</code>.</p>

<h3 id="dynamically-sized-types-and-the-sized-trait">Dynamically Sized Types and the Sized Trait</h3>
<p>Due to Rust’s need to know certain details, such as how much space to allocate for a value of a particular type, there is a corner of its type system that can be confusing: the concept of <em>dynamically sized types</em>. 
Sometimes referred to as DSTs or <em>unsized types</em>, these types let us write code using values whose size we can know only at runtime.</p>

<p>Let’s dig into the details of a dynamically sized type called <code class="language-plaintext highlighter-rouge">str</code>, which we’ve been using throughout the book. 
That’s right, not <code class="language-plaintext highlighter-rouge">&amp;str</code>, but <code class="language-plaintext highlighter-rouge">str</code> on its own, is a DST. 
We can’t know how long the string is until runtime, meaning we can’t create a variable of type <code class="language-plaintext highlighter-rouge">str</code>, nor can we take an argument of type <code class="language-plaintext highlighter-rouge">str</code>. 
Consider the following code, which does not work:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="n">s1</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"Hello there!"</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">s2</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"How's it going?"</span><span class="p">;</span>
</code></pre></div></div>
<p>Rust needs to know how much memory to allocate for any value of a particular type, and all values of a type must use the same amount of memory. 
If Rust allowed us to write this code, these two <code class="language-plaintext highlighter-rouge">str</code> values would need to take up the same amount of space. 
But they have different lengths: <code class="language-plaintext highlighter-rouge">s1</code> needs 12 bytes of storage and <code class="language-plaintext highlighter-rouge">s2</code> needs 15. 
This is why it’s not possible to create a variable holding a dynamically sized type.</p>

<p>So what do we do? In this case, you already know the answer: we make the types of <code class="language-plaintext highlighter-rouge">s1</code> and <code class="language-plaintext highlighter-rouge">s2</code> a <code class="language-plaintext highlighter-rouge">&amp;str</code> rather than a <code class="language-plaintext highlighter-rouge">str</code>. 
Recall that in the “String Slices” section of Chapter 4, we said the slice data structure stores the starting position and the length of the slice.</p>

<p>So although a <code class="language-plaintext highlighter-rouge">&amp;T</code> is a single value that stores the memory address of where the <code class="language-plaintext highlighter-rouge">T</code> is located, a <code class="language-plaintext highlighter-rouge">&amp;str</code> is <em>two</em> values: the address of the <code class="language-plaintext highlighter-rouge">str</code> and its length. 
As such, we can know the size of a <code class="language-plaintext highlighter-rouge">&amp;str</code> value at compile time: it’s twice the length of a <code class="language-plaintext highlighter-rouge">usize</code>. 
That is, we always know the size of a <code class="language-plaintext highlighter-rouge">&amp;str</code>, no matter how long the string it refers to is. 
In general, this is the way in which dynamically sized types are used in Rust: they have an extra bit of metadata that stores the size of the dynamic information. 
The golden rule of dynamically sized types is that we must always put values of dynamically sized types behind a pointer of some kind.</p>

<p>We can combine <code class="language-plaintext highlighter-rouge">str</code> with all kinds of pointers: for example, <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code> or <code class="language-plaintext highlighter-rouge">Rc&lt;str&gt;</code>. 
In fact, you’ve seen this before but with a different dynamically sized type: traits. 
Every trait is a dynamically sized type we can refer to by using the name of the trait. 
In Chapter 17 in the “Using Trait Objects That Allow for Values of Different Types” section, we mentioned that to use traits as trait objects, we must put them behind a pointer, such as <code class="language-plaintext highlighter-rouge">&amp;dyn Trait</code> or <code class="language-plaintext highlighter-rouge">Box&lt;dyn Trait&gt;</code> (<code class="language-plaintext highlighter-rouge">Rc&lt;dyn Trait&gt;</code> would work too).</p>

<p>To work with DSTs, Rust has a particular trait called the <code class="language-plaintext highlighter-rouge">Sized</code> trait to determine whether or not a type’s size is known at compile time. 
This trait is automatically implemented for everything whose size is known at compile time. 
In addition, Rust implicitly adds a bound on <code class="language-plaintext highlighter-rouge">Sized</code> to every generic function. 
That is, a generic function definition like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">generic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// --snip--</span>
<span class="p">}</span>
</code></pre></div></div>

<p>is actually treated as though we had written this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">generic</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// --snip--</span>
<span class="p">}</span>
</code></pre></div></div>
<p>By default, generic functions will work only on types that have a known size at compile time. 
However, you can use the following special syntax to relax this restriction:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">generic</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// --snip--</span>
<span class="p">}</span>
</code></pre></div></div>
<p>A trait bound on <code class="language-plaintext highlighter-rouge">?Sized</code> is the opposite of a trait bound on <code class="language-plaintext highlighter-rouge">Sized</code>: we would read this as “<code class="language-plaintext highlighter-rouge">T</code> may or may not be <code class="language-plaintext highlighter-rouge">Sized</code>.” This syntax is only available for <code class="language-plaintext highlighter-rouge">Sized</code>, not any other traits.</p>

<p>Also note that we switched the type of the <code class="language-plaintext highlighter-rouge">t</code> parameter from <code class="language-plaintext highlighter-rouge">T</code> to <code class="language-plaintext highlighter-rouge">&amp;T</code>. 
Because the type might not be Size<code class="language-plaintext highlighter-rouge">d</code>, we need to use it behind some kind of pointer. In this case, we’ve chosen a reference.</p>

<p>Next, we’ll talk about functions and closures!</p>

<h2 id="advanced-functions-and-closures">Advanced Functions and Closures</h2>
<p>Next, we’ll explore some advanced features related to functions and closures, which include function pointers and returning closures.</p>

<h3 id="function-pointers">Function Pointers</h3>
<p>We’ve talked about how to pass closures to functions; you can also pass regular functions to functions! 
This technique is useful when you want to pass a function you’ve already defined rather than defining a new closure. 
Doing this with function pointers will allow you to use functions as arguments to other functions. 
Functions coerce to the type <code class="language-plaintext highlighter-rouge">fn</code> (with a lowercase f), not to be confused with the <code class="language-plaintext highlighter-rouge">Fn</code> closure trait. 
The <code class="language-plaintext highlighter-rouge">fn</code> type is called a function pointer. The syntax for specifying that a parameter is a function pointer is similar to that of closures, as shown in Listing 19-27.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">fn</span> <span class="nf">add_one</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">do_twice</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">arg</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">answer</span> <span class="o">=</span> <span class="nf">do_twice</span><span class="p">(</span><span class="n">add_one</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"The answer is: {}"</span><span class="p">,</span> <span class="n">answer</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-27-using-the-fn-type-to-accept-a-function-pointer-as-an-argument">Listing 19-27: Using the fn type to accept a function pointer as an argument</h4>

<p>This code prints <code class="language-plaintext highlighter-rouge">The answer is: 12</code>. 
We specify that the parameter <code class="language-plaintext highlighter-rouge">f</code> in <code class="language-plaintext highlighter-rouge">do_twice</code> is an <code class="language-plaintext highlighter-rouge">fn</code> that takes one parameter of type <code class="language-plaintext highlighter-rouge">i32</code> and returns an <code class="language-plaintext highlighter-rouge">i32</code>. 
We can then call <code class="language-plaintext highlighter-rouge">f</code> in the body of <code class="language-plaintext highlighter-rouge">do_twice</code>. 
In <code class="language-plaintext highlighter-rouge">main</code>, we can pass the function name <code class="language-plaintext highlighter-rouge">add_one</code> as the first argument to <code class="language-plaintext highlighter-rouge">do_twice</code>.</p>

<p>Unlike closures, <code class="language-plaintext highlighter-rouge">fn</code> is a type rather than a trait, so we specify <code class="language-plaintext highlighter-rouge">fn</code> as the parameter type directly rather than declaring a generic type parameter with one of the <code class="language-plaintext highlighter-rouge">Fn</code> traits as a trait bound.</p>

<p>Function pointers implement all three of the closure traits (<code class="language-plaintext highlighter-rouge">Fn</code>, <code class="language-plaintext highlighter-rouge">FnMut</code>, and <code class="language-plaintext highlighter-rouge">FnOnce</code>), so you can always pass a function pointer as an argument for a function that expects a closure. 
It’s best to write functions using a generic type and one of the closure traits so your functions can accept either functions or closures.</p>

<p>An example of where you would want to only accept <code class="language-plaintext highlighter-rouge">fn</code> and not closures is when interfacing with external code that doesn’t have closures: C functions can accept functions as arguments, but C doesn’t have closures.</p>

<p>As an example of where you could use either a closure defined inline or a named function, let’s look at a use of <code class="language-plaintext highlighter-rouge">map</code>. 
To use the <code class="language-plaintext highlighter-rouge">map</code> function to turn a vector of numbers into a vector of strings, we could use a closure, like this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="n">list_of_numbers</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
    <span class="k">let</span> <span class="n">list_of_strings</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="o">=</span>
        <span class="n">list_of_numbers</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">i</span><span class="p">|</span> <span class="n">i</span><span class="nf">.to_string</span><span class="p">())</span><span class="nf">.collect</span><span class="p">();</span>
</code></pre></div></div>
<p>Or we could name a function as the argument to <code class="language-plaintext highlighter-rouge">map</code> instead of the closure, like this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="n">list_of_numbers</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
    <span class="k">let</span> <span class="n">list_of_strings</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="o">=</span>
        <span class="n">list_of_numbers</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(</span><span class="nn">ToString</span><span class="p">::</span><span class="n">to_string</span><span class="p">)</span><span class="nf">.collect</span><span class="p">();</span>
</code></pre></div></div>

<p>Note that we must use the fully qualified syntax that we talked about earlier in the “Advanced Traits” section because there are multiple functions available named <code class="language-plaintext highlighter-rouge">to_string</code>. 
Here, we’re using the <code class="language-plaintext highlighter-rouge">to_string</code> function defined in the <code class="language-plaintext highlighter-rouge">ToString</code> trait, which the standard library has implemented for any type that implements <code class="language-plaintext highlighter-rouge">Display</code>.</p>

<p>We have another useful pattern that exploits an implementation detail of tuple structs and tuple-struct enum variants. 
These types use <code class="language-plaintext highlighter-rouge">()</code> as initializer syntax, which looks like a function call. 
The initializers are actually implemented as functions returning an instance that’s constructed from their arguments. 
We can use these initializer functions as function pointers that implement the closure traits, which means we can specify the initializer functions as arguments for methods that take closures, like so:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">enum</span> <span class="n">Status</span> <span class="p">{</span>
        <span class="nf">Value</span><span class="p">(</span><span class="nb">u32</span><span class="p">),</span>
        <span class="n">Stop</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">list_of_statuses</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Status</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0u32</span><span class="o">..</span><span class="mi">20</span><span class="p">)</span><span class="nf">.map</span><span class="p">(</span><span class="nn">Status</span><span class="p">::</span><span class="n">Value</span><span class="p">)</span><span class="nf">.collect</span><span class="p">();</span>
</code></pre></div></div>
<p>Here we create <code class="language-plaintext highlighter-rouge">Status::Value</code> instances using each <code class="language-plaintext highlighter-rouge">u32</code> value in the range that <code class="language-plaintext highlighter-rouge">map</code> is called on by using the initializer function of <code class="language-plaintext highlighter-rouge">Status::Value</code>. 
Some people prefer this style, and some people prefer to use closures. 
They compile to the same code, so use whichever style is clearer to you.</p>

<h3 id="returning-closures">Returning Closures</h3>
<p>Closures are represented by traits, which means you can’t return closures directly. 
In most cases where you might want to return a trait, you can instead use the concrete type that implements the trait as the return value of the function. 
But you can’t do that with closures because they don’t have a concrete type that is returnable; you’re not allowed to use the function pointer <code class="language-plaintext highlighter-rouge">fn</code> as a return type, for example.</p>

<p>The following code tries to return a closure directly, but it won’t compile:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">returns_closure</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">dyn</span> <span class="nf">Fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The compiler error is as follows:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cargo</span> <span class="n">build</span>
   <span class="n">Compiling</span> <span class="n">functions</span><span class="o">-</span><span class="n">example</span> <span class="n">v0</span><span class="na">.1.0</span> <span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="cd">///projects/functions-example)</span>
<span class="n">error</span><span class="p">[</span><span class="n">E0277</span><span class="p">]:</span> <span class="n">the</span> <span class="n">size</span> <span class="k">for</span> <span class="n">values</span> <span class="n">of</span> <span class="k">type</span> <span class="err">`</span><span class="p">(</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ops</span><span class="p">::</span><span class="nf">Fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="o">+</span> <span class="k">'static</span><span class="p">)</span><span class="err">`</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">known</span> <span class="n">at</span> <span class="n">compilation</span> <span class="n">time</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">lib</span><span class="py">.rs</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="mi">25</span>
  <span class="p">|</span>
<span class="mi">1</span> <span class="p">|</span> <span class="k">fn</span> <span class="nf">returns_closure</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">dyn</span> <span class="nf">Fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="p">|</span>                         <span class="o">^^^^^^^^^^^^^^^^^^</span> <span class="n">doesn</span><span class="nv">'t</span> <span class="n">have</span> <span class="n">a</span> <span class="n">size</span> <span class="n">known</span> <span class="n">at</span> <span class="n">compile</span><span class="o">-</span><span class="n">time</span>
  <span class="p">|</span>
  <span class="o">=</span> <span class="n">help</span><span class="p">:</span> <span class="n">the</span> <span class="k">trait</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">marker</span><span class="p">::</span><span class="nb">Sized</span><span class="err">`</span> <span class="n">is</span> <span class="n">not</span> <span class="n">implemented</span> <span class="k">for</span> <span class="err">`</span><span class="p">(</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ops</span><span class="p">::</span><span class="nf">Fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="o">+</span> <span class="k">'static</span><span class="p">)</span><span class="err">`</span>
  <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">to</span> <span class="n">learn</span> <span class="n">more</span><span class="p">,</span> <span class="n">visit</span> <span class="o">&lt;</span><span class="n">https</span><span class="p">:</span><span class="c1">//doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait&gt;</span>
  <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">the</span> <span class="k">return</span> <span class="k">type</span> <span class="n">of</span> <span class="n">a</span> <span class="n">function</span> <span class="n">must</span> <span class="n">have</span> <span class="n">a</span> <span class="n">statically</span> <span class="n">known</span> <span class="n">size</span>

<span class="n">error</span><span class="p">[</span><span class="n">E0308</span><span class="p">]:</span> <span class="n">mismatched</span> <span class="n">types</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">lib</span><span class="py">.rs</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span>
  <span class="p">|</span>
<span class="mi">1</span> <span class="p">|</span> <span class="k">fn</span> <span class="nf">returns_closure</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">dyn</span> <span class="nf">Fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="p">|</span>                         <span class="o">------------------</span> <span class="n">expected</span> <span class="err">`</span><span class="p">(</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ops</span><span class="p">::</span><span class="nf">Fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="o">+</span> <span class="k">'static</span><span class="p">)</span><span class="err">`</span> <span class="n">because</span> <span class="n">of</span> <span class="k">return</span> <span class="k">type</span>
<span class="mi">2</span> <span class="p">|</span>     <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="p">|</span>     <span class="o">^^^^^^^^^</span> <span class="n">expected</span> <span class="k">trait</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">ops</span><span class="p">::</span><span class="nb">Fn</span><span class="err">`</span><span class="p">,</span> <span class="n">found</span> <span class="n">closure</span>
  <span class="p">|</span>
  <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">expected</span> <span class="k">trait</span> <span class="n">object</span> <span class="err">`</span><span class="p">(</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ops</span><span class="p">::</span><span class="nf">Fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="o">+</span> <span class="k">'static</span><span class="p">)</span><span class="err">`</span>
                  <span class="n">found</span> <span class="n">closure</span> <span class="err">`</span><span class="p">[</span><span class="n">closure</span><span class="o">@</span><span class="n">src</span><span class="o">/</span><span class="n">lib</span><span class="py">.rs</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span> <span class="mi">2</span><span class="p">:</span><span class="mi">14</span><span class="p">]</span><span class="err">`</span>

<span class="n">error</span><span class="p">:</span> <span class="n">aborting</span> <span class="n">due</span> <span class="n">to</span> <span class="mi">2</span> <span class="n">previous</span> <span class="n">errors</span>

<span class="nb">Some</span> <span class="n">errors</span> <span class="n">have</span> <span class="n">detailed</span> <span class="n">explanations</span><span class="p">:</span> <span class="n">E0277</span><span class="p">,</span> <span class="n">E0308</span><span class="py">.
For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">about</span> <span class="n">an</span> <span class="n">error</span><span class="p">,</span> <span class="k">try</span> <span class="err">`</span><span class="n">rustc</span> <span class="o">--</span><span class="n">explain</span> <span class="n">E0277</span><span class="err">`</span><span class="py">.
error</span><span class="p">:</span> <span class="n">could</span> <span class="n">not</span> <span class="n">compile</span> <span class="err">`</span><span class="n">functions</span><span class="o">-</span><span class="n">example</span><span class="err">`</span><span class="py">.

To</span> <span class="n">learn</span> <span class="n">more</span><span class="p">,</span> <span class="n">run</span> <span class="n">the</span> <span class="n">command</span> <span class="n">again</span> <span class="n">with</span> <span class="o">--</span><span class="n">verbose</span><span class="err">.</span>
</code></pre></div></div>
<p>The error references the <code class="language-plaintext highlighter-rouge">Sized</code> trait again! Rust doesn’t know how much space it will need to store the closure. We saw a solution to this problem earlier. 
We can use a trait object:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">returns_closure</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nf">Fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This code will compile just fine. For more about trait objects, refer to the section “Using Trait Objects That Allow for Values of Different Types” in Chapter 17.</p>

<p>Next, let’s look at macros!</p>

<h2 id="macros">Macros</h2>
<p>We’ve used macros like <code class="language-plaintext highlighter-rouge">println!</code> throughout this book, but we haven’t fully explored what a macro is and how it works. 
The term <em>macro</em> refers to a family of features in Rust: <em>declarative</em> macros with <code class="language-plaintext highlighter-rouge">macro_rules!</code> and three kinds of <em>procedural</em> macros:</p>

<ul>
  <li>Custom #[derive] macros that specify code added with the derive attribute used on structs and enums</li>
  <li>Attribute-like macros that define custom attributes usable on any item</li>
  <li>Function-like macros that look like function calls but operate on the tokens specified as their argument</li>
</ul>

<p>We’ll talk about each of these in turn, but first, let’s look at why we even need macros when we already have functions.</p>

<h3 id="the-difference-between-macros-and-functions">The Difference Between Macros and Functions</h3>
<p>Fundamentally, macros are a way of writing code that writes other code, which is known as <em>metaprogramming</em>. 
In Appendix C, we discuss the <code class="language-plaintext highlighter-rouge">derive</code> attribute, which generates an implementation of various traits for you. We’ve also used the <code class="language-plaintext highlighter-rouge">println!</code> and <code class="language-plaintext highlighter-rouge">vec!</code> macros throughout the book. 
All of these macros <em>expand</em> to produce more code than the code you’ve written manually.</p>

<p>Metaprogramming is useful for reducing the amount of code you have to write and maintain, which is also one of the roles of functions. 
However, macros have some additional powers that functions don’t.</p>

<p>A function signature must declare the number and type of parameters the function has. 
Macros, on the other hand, can take a variable number of parameters: we can call <code class="language-plaintext highlighter-rouge">println!("hello")</code> with one argument or <code class="language-plaintext highlighter-rouge">println!("hello {}", name)</code> with two arguments. 
Also, macros are expanded before the compiler interprets the meaning of the code, so a macro can, for example, implement a trait on a given type. 
A function can’t, because it gets called at runtime and a trait needs to be implemented at compile time.</p>

<p>The downside to implementing a macro instead of a function is that macro definitions are more complex than function definitions because you’re writing Rust code that writes Rust code. 
Due to this indirection, macro definitions are generally more difficult to read, understand, and maintain than function definitions.</p>

<p>Another important difference between macros and functions is that you must define macros or bring them into scope <em>before</em> you call them in a file, as opposed to functions you can define anywhere and call anywhere.</p>

<h3 id="declarative-macros-with-macro_rules-for-general-metaprogramming">Declarative Macros with macro_rules! for General Metaprogramming</h3>
<p>The most widely used form of macros in Rust is <em>declarative</em> macros. 
These are also sometimes referred to as “macros by example,” “<code class="language-plaintext highlighter-rouge">macro_rules!</code> macros,” or just plain “macros.” 
At their core, declarative macros allow you to write something similar to a Rust <code class="language-plaintext highlighter-rouge">match</code> expression. 
As discussed in Chapter 6, <code class="language-plaintext highlighter-rouge">match</code> expressions are control structures that take an expression, compare the resulting value of the expression to patterns, and then run the code associated with the matching pattern. 
Macros also compare a value to patterns that are associated with particular code: in this situation, the value is the literal Rust source code passed to the macro; the patterns are compared with the structure of that source code; and the code associated with each pattern, when matched, replaces the code passed to the macro. 
This all happens during compilation.</p>

<p>To define a macro, you use the <code class="language-plaintext highlighter-rouge">macro_rules!</code> construct. 
Let’s explore how to use <code class="language-plaintext highlighter-rouge">macro_rules!</code> by looking at how the <code class="language-plaintext highlighter-rouge">vec!</code> macro is defined. 
Chapter 8 covered how we can use the <code class="language-plaintext highlighter-rouge">vec!</code> macro to create a new vector with particular values. 
For example, the following macro creates a new vector containing three integers:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">v</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
</code></pre></div></div>
<p>We could also use the <code class="language-plaintext highlighter-rouge">vec!</code> macro to make a vector of two integers or a vector of five string slices. 
We wouldn’t be able to use a function to do the same because we wouldn’t know the number or type of values up front.</p>

<p>Listing 19-28 shows a slightly simplified definition of the <code class="language-plaintext highlighter-rouge">vec!</code> macro.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>

<span class="nd">#[macro_export]</span>
<span class="nd">macro_rules!</span> <span class="n">vec</span> <span class="p">{</span>
    <span class="p">(</span> <span class="nv">$</span><span class="p">(</span> <span class="nv">$x:expr</span> <span class="p">),</span><span class="o">*</span> <span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">temp_vec</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="nv">$</span><span class="p">(</span>
                <span class="n">temp_vec</span><span class="nf">.push</span><span class="p">(</span><span class="nv">$x</span><span class="p">);</span>
            <span class="p">)</span><span class="o">*</span>
            <span class="n">temp_vec</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-28-a-simplified-version-of-the-vec-macro-definition">Listing 19-28: A simplified version of the vec! macro definition</h4>

<p class="notice--info">Note: The actual definition of the <code class="language-plaintext highlighter-rouge">vec!</code> macro in the standard library includes code to preallocate the correct amount of memory up front. That code is an optimization that we don’t include here to make the example simpler.</p>

<p>The <code class="language-plaintext highlighter-rouge">#[macro_export]</code> annotation indicates that this macro should be made available whenever the crate in which the macro is defined is brought into scope. 
Without this annotation, the macro can’t be brought into scope.</p>

<p>We then start the macro definition with <code class="language-plaintext highlighter-rouge">macro_rules!</code> and the name of the macro we’re defining <em>without</em> the exclamation mark. 
The name, in this case <code class="language-plaintext highlighter-rouge">vec</code>, is followed by curly brackets denoting the body of the macro definition.</p>

<p>The structure in the <code class="language-plaintext highlighter-rouge">vec!</code> body is similar to the structure of a <code class="language-plaintext highlighter-rouge">match</code> expression. 
Here we have one arm with the pattern <code class="language-plaintext highlighter-rouge">( $( $x:expr ),* )</code>, followed by <code class="language-plaintext highlighter-rouge">=&gt;</code> and the block of code associated with this pattern. 
If the pattern matches, the associated block of code will be emitted. 
Given that this is the only pattern in this macro, there is only one valid way to match; any other pattern will result in an error. 
More complex macros will have more than one arm.</p>

<p>Valid pattern syntax in macro definitions is different than the pattern syntax covered in Chapter 18 because macro patterns are matched against Rust code structure rather than values. 
Let’s walk through what the pattern pieces in Listing 19-28 mean; for the full macro pattern syntax, see <a href="https://doc.rust-lang.org/reference/macros-by-example.html">the reference</a>.</p>

<p>First, a set of parentheses encompasses the whole pattern. 
A dollar sign (<code class="language-plaintext highlighter-rouge">$</code>) is next, followed by a set of parentheses that captures values that match the pattern within the parentheses for use in the replacement code. 
Within <code class="language-plaintext highlighter-rouge">$()</code> is <code class="language-plaintext highlighter-rouge">$x:expr</code>, which matches any Rust expression and gives the expression the name <code class="language-plaintext highlighter-rouge">$x</code>.</p>

<p>The comma following <code class="language-plaintext highlighter-rouge">$()</code> indicates that a literal comma separator character could optionally appear after the code that matches the code in <code class="language-plaintext highlighter-rouge">$()</code>. 
The <code class="language-plaintext highlighter-rouge">*</code> specifies that the pattern matches zero or more of whatever precedes the <code class="language-plaintext highlighter-rouge">*</code>.</p>

<p>When we call this macro with <code class="language-plaintext highlighter-rouge">vec![1, 2, 3]</code>;, the <code class="language-plaintext highlighter-rouge">$x</code> pattern matches three times with the three expressions <code class="language-plaintext highlighter-rouge">1</code>, <code class="language-plaintext highlighter-rouge">2</code>, and <code class="language-plaintext highlighter-rouge">3</code>.</p>

<p>Now let’s look at the pattern in the body of the code associated with this arm: <code class="language-plaintext highlighter-rouge">temp_vec.push()</code> within <code class="language-plaintext highlighter-rouge">$()*</code> is generated for each part that matches <code class="language-plaintext highlighter-rouge">$()</code> in the pattern zero or more times depending on how many times the pattern matches. 
The <code class="language-plaintext highlighter-rouge">$x</code> is replaced with each expression matched. When we call this macro with <code class="language-plaintext highlighter-rouge">vec![1, 2, 3];</code>, the code generated that replaces this macro call will be the following:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">temp_vec</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="n">temp_vec</span><span class="nf">.push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">temp_vec</span><span class="nf">.push</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">temp_vec</span><span class="nf">.push</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">temp_vec</span>
<span class="p">}</span>
</code></pre></div></div>
<p>We’ve defined a macro that can take any number of arguments of any type and can generate code to create a vector containing the specified elements.</p>

<p>There are some strange edge cases with <code class="language-plaintext highlighter-rouge">macro_rules!</code>. 
In the future, Rust will have a second kind of declarative macro that will work in a similar fashion but fix some of these edge cases. 
After that update, <code class="language-plaintext highlighter-rouge">macro_rules!</code> will be effectively deprecated. 
With this in mind, as well as the fact that most Rust programmers will use macros more than write macros, we won’t discuss <code class="language-plaintext highlighter-rouge">macro_rules!</code> any further. 
To learn more about how to write macros, consult the online documentation or other resources, such as “The Little Book of Rust Macros”.</p>

<h3 id="procedural-macros-for-generating-code-from-attributes">Procedural Macros for Generating Code from Attributes</h3>
<p>The second form of macros is <em>procedural macros</em>, which act more like functions (and are a type of procedure). 
Procedural macros accept some code as an input, operate on that code, and produce some code as an output rather than matching against patterns and replacing the code with other code as declarative macros do.</p>

<p>The three kinds of procedural macros (custom derive, attribute-like, and function-like) all work in a similar fashion.</p>

<p>When creating procedural macros, the definitions must reside in their own crate with a special crate type. 
This is for complex technical reasons that we hope to eliminate in the future. 
Using procedural macros looks like the code in Listing 19-29, where <code class="language-plaintext highlighter-rouge">some_attribute</code> is a placeholder for using a specific macro.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>

<span class="k">use</span> <span class="n">proc_macro</span><span class="p">;</span>

<span class="nd">#[some_attribute]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">some_name</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-29-an-example-of-using-a-procedural-macro">Listing 19-29: An example of using a procedural macro</h4>
<p>The function that defines a procedural macro takes a <code class="language-plaintext highlighter-rouge">TokenStream</code> as an input and produces a <code class="language-plaintext highlighter-rouge">TokenStream</code> as an output. 
The <code class="language-plaintext highlighter-rouge">TokenStream</code> type is defined by the <code class="language-plaintext highlighter-rouge">proc_macro</code> crate that is included with Rust and represents a sequence of tokens. 
This is the core of the macro: the source code that the macro is operating on makes up the input <code class="language-plaintext highlighter-rouge">TokenStream</code>, and the code the macro produces is the output <code class="language-plaintext highlighter-rouge">TokenStream</code>. 
The function also has an attribute attached to it that specifies which kind of procedural macro we’re creating. 
We can have multiple kinds of procedural macros in the same crate.</p>

<p>Let’s look at the different kinds of procedural macros. We’ll start with a custom derive macro and then explain the small dissimilarities that make the other forms different.</p>

<h3 id="how-to-write-a-custom-derive-macro">How to Write a Custom derive Macro</h3>
<p>Let’s create a crate named <code class="language-plaintext highlighter-rouge">hello_macro</code> that defines a trait named <code class="language-plaintext highlighter-rouge">HelloMacro</code> with one associated function named <code class="language-plaintext highlighter-rouge">hello_macro</code>. 
Rather than making our crate users implement the <code class="language-plaintext highlighter-rouge">HelloMacro</code> trait for each of their types, we’ll provide a procedural macro so users can annotate their type with <code class="language-plaintext highlighter-rouge">#[derive(HelloMacro)]</code> to get a default implementation of the <code class="language-plaintext highlighter-rouge">hello_macro</code> function. 
The default implementation will print <code class="language-plaintext highlighter-rouge">Hello, Macro! My name is TypeName!</code> where <code class="language-plaintext highlighter-rouge">TypeName</code> is the name of the type on which this trait has been defined. 
In other words, we’ll write a crate that enables another programmer to write code like Listing 19-30 using our crate.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/main.rs</span>

<span class="k">use</span> <span class="nn">hello_macro</span><span class="p">::</span><span class="n">HelloMacro</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">hello_macro_derive</span><span class="p">::</span><span class="n">HelloMacro</span><span class="p">;</span>

<span class="nd">#[derive(HelloMacro)]</span>
<span class="k">struct</span> <span class="n">Pancakes</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nn">Pancakes</span><span class="p">::</span><span class="nf">hello_macro</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-30-the-code-a-user-of-our-crate-will-be-able-to-write-when-using-our-procedural-macro">Listing 19-30: The code a user of our crate will be able to write when using our procedural macro</h4>

<p>This code will print <code class="language-plaintext highlighter-rouge">Hello, Macro! My name is Pancakes!</code> when we’re done. 
The first step is to make a new library crate, like this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cargo new hello_macro --lib
</code></pre></div></div>
<p>Next, we’ll define the <code class="language-plaintext highlighter-rouge">HelloMacro</code> trait and its associated function:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: src/lib.rs</span>

<span class="k">pub</span> <span class="k">trait</span> <span class="n">HelloMacro</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">hello_macro</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>
<p>We have a trait and its function. At this point, our crate user could implement the trait to achieve the desired functionality, like so:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">hello_macro</span><span class="p">::</span><span class="n">HelloMacro</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Pancakes</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">HelloMacro</span> <span class="k">for</span> <span class="n">Pancakes</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">hello_macro</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello, Macro! My name is Pancakes!"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nn">Pancakes</span><span class="p">::</span><span class="nf">hello_macro</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>
<p>However, they would need to write the implementation block for each type they wanted to use with <code class="language-plaintext highlighter-rouge">hello_macro</code>; we want to spare them from having to do this work.</p>

<p>Additionally, we can’t yet provide the <code class="language-plaintext highlighter-rouge">hello_macro</code> function with default implementation that will print the name of the type the trait is implemented on: Rust doesn’t have reflection capabilities, so it can’t look up the type’s name at runtime. 
We need a macro to generate code at compile time.</p>

<p>The next step is to define the procedural macro. At the time of this writing, procedural macros need to be in their own crate. 
Eventually, this restriction might be lifted. 
The convention for structuring crates and macro crates is as follows: for a crate named <code class="language-plaintext highlighter-rouge">foo</code>, a custom derive procedural macro crate is called <code class="language-plaintext highlighter-rouge">foo_derive</code>. 
Let’s start a new crate called <code class="language-plaintext highlighter-rouge">hello_macro_derive</code> inside our <code class="language-plaintext highlighter-rouge">hello_macro</code> project:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cargo new hello_macro_derive --lib
</code></pre></div></div>

<p>Our two crates are tightly related, so we create the procedural macro crate within the directory of our <code class="language-plaintext highlighter-rouge">hello_macro</code> crate. 
If we change the trait definition in <code class="language-plaintext highlighter-rouge">hello_macro</code>, we’ll have to change the implementation of the procedural macro in <code class="language-plaintext highlighter-rouge">hello_macro_derive</code> as well. 
The two crates will need to be published separately, and programmers using these crates will need to add both as dependencies and bring them both into scope. 
We could instead have the <code class="language-plaintext highlighter-rouge">hello_macro</code> crate use <code class="language-plaintext highlighter-rouge">hello_macro_derive</code> as a dependency and re-export the procedural macro code. 
However, the way we’ve structured the project makes it possible for programmers to use <code class="language-plaintext highlighter-rouge">hello_macro</code> even if they don’t want the <code class="language-plaintext highlighter-rouge">derive</code> functionality.</p>

<p>We need to declare the <code class="language-plaintext highlighter-rouge">hello_macro_derive</code> crate as a procedural macro crate. 
We’ll also need functionality from the <code class="language-plaintext highlighter-rouge">syn</code> and <code class="language-plaintext highlighter-rouge">quote</code> crates, as you’ll see in a moment, so we need to add them as dependencies. Add the following to the <em>Cargo.toml</em> file for <code class="language-plaintext highlighter-rouge">hello_macro_derive</code>:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: hello_macro_derive/Cargo.toml</span>

<span class="p">[</span><span class="n">lib</span><span class="p">]</span>
<span class="n">proc</span><span class="o">-</span><span class="k">macro</span> <span class="o">=</span> <span class="k">true</span>

<span class="p">[</span><span class="n">dependencies</span><span class="p">]</span>
<span class="n">syn</span> <span class="o">=</span> <span class="s">"1.0"</span>
<span class="n">quote</span> <span class="o">=</span> <span class="s">"1.0"</span>
</code></pre></div></div>
<p>To start defining the procedural macro, place the code in Listing 19-31 into your <em>src/lib.rs</em> file for the <code class="language-plaintext highlighter-rouge">hello_macro_derive</code> crate. 
Note that this code won’t compile until we add a definition for the <code class="language-plaintext highlighter-rouge">impl_hello_macro</code> function.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: hello_macro_derive/src/lib.rs</span>

<span class="k">extern</span> <span class="k">crate</span> <span class="n">proc_macro</span><span class="p">;</span>

<span class="k">use</span> <span class="nn">proc_macro</span><span class="p">::</span><span class="n">TokenStream</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">quote</span><span class="p">::</span><span class="n">quote</span><span class="p">;</span>
<span class="k">use</span> <span class="n">syn</span><span class="p">;</span>

<span class="nd">#[proc_macro_derive(HelloMacro)]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">hello_macro_derive</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
    <span class="c1">// Construct a representation of Rust code as a syntax tree</span>
    <span class="c1">// that we can manipulate</span>
    <span class="k">let</span> <span class="n">ast</span> <span class="o">=</span> <span class="nn">syn</span><span class="p">::</span><span class="nf">parse</span><span class="p">(</span><span class="n">input</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="c1">// Build the trait implementation</span>
    <span class="nf">impl_hello_macro</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ast</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-31-code-that-most-procedural-macro-crates-will-require-in-order-to-process-rust-code">Listing 19-31: Code that most procedural macro crates will require in order to process Rust code</h4>

<p>Notice that we’ve split the code into the <code class="language-plaintext highlighter-rouge">hello_macro_derive</code> function, which is responsible for parsing the <code class="language-plaintext highlighter-rouge">TokenStream</code>, and the <code class="language-plaintext highlighter-rouge">impl_hello_macro</code> function, which is responsible for transforming the syntax tree: this makes writing a procedural macro more convenient. The code in the outer function (<code class="language-plaintext highlighter-rouge">hello_macro_derive</code> in this case) will be the same for almost every procedural macro crate you see or create. 
The code you specify in the body of the inner function (<code class="language-plaintext highlighter-rouge">impl_hello_macro</code> in this case) will be different depending on your procedural macro’s purpose.</p>

<p>We’ve introduced three new crates: <code class="language-plaintext highlighter-rouge">proc_macro</code>, <code class="language-plaintext highlighter-rouge">syn</code>, and <code class="language-plaintext highlighter-rouge">quote</code>. 
The <code class="language-plaintext highlighter-rouge">proc_macro</code> crate comes with Rust, so we didn’t need to add that to the dependencies in <em>Cargo.toml</em>. 
The <code class="language-plaintext highlighter-rouge">proc_macro</code> crate is the compiler’s API that allows us to read and manipulate Rust code from our code.</p>

<p>The <code class="language-plaintext highlighter-rouge">syn</code> crate parses Rust code from a string into a data structure that we can perform operations on. 
The <code class="language-plaintext highlighter-rouge">quote</code> crate turns <code class="language-plaintext highlighter-rouge">syn</code> data structures back into Rust code. These crates make it much simpler to parse any sort of Rust code we might want to handle: writing a full parser for Rust code is no simple task.</p>

<p>The <code class="language-plaintext highlighter-rouge">hello_macro_derive</code> function will be called when a user of our library specifies <code class="language-plaintext highlighter-rouge">#[derive(HelloMacro)]</code> on a type. 
This is possible because we’ve annotated the <code class="language-plaintext highlighter-rouge">hello_macro_derive</code> function here with <code class="language-plaintext highlighter-rouge">proc_macro_derive</code> and specified the name, <code class="language-plaintext highlighter-rouge">HelloMacro</code>, which matches our trait name; this is the convention most procedural macros follow.</p>

<p>The <code class="language-plaintext highlighter-rouge">hello_macro_derive</code> function first converts the <code class="language-plaintext highlighter-rouge">input</code> from a <code class="language-plaintext highlighter-rouge">TokenStream</code> to a data structure that we can then interpret and perform operations on. 
This is where <code class="language-plaintext highlighter-rouge">syn</code> comes into play. 
The <code class="language-plaintext highlighter-rouge">parse</code> function in <code class="language-plaintext highlighter-rouge">syn</code> takes a TokenStream and returns a <code class="language-plaintext highlighter-rouge">DeriveInput</code> struct representing the parsed Rust code. 
Listing 19-32 shows the relevant parts of the <code class="language-plaintext highlighter-rouge">DeriveInput</code> struct we get from parsing the <code class="language-plaintext highlighter-rouge">struct Pancakes;</code> string:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DeriveInput</span> <span class="p">{</span>
    <span class="c1">// --snip--</span>

    <span class="n">ident</span><span class="p">:</span> <span class="n">Ident</span> <span class="p">{</span>
        <span class="n">ident</span><span class="p">:</span> <span class="s">"Pancakes"</span><span class="p">,</span>
        <span class="n">span</span><span class="p">:</span> <span class="err">#</span><span class="mi">0</span> <span class="nf">bytes</span><span class="p">(</span><span class="mi">95</span><span class="o">..</span><span class="mi">103</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="n">data</span><span class="p">:</span> <span class="nf">Struct</span><span class="p">(</span>
        <span class="n">DataStruct</span> <span class="p">{</span>
            <span class="n">struct_token</span><span class="p">:</span> <span class="n">Struct</span><span class="p">,</span>
            <span class="n">fields</span><span class="p">:</span> <span class="n">Unit</span><span class="p">,</span>
            <span class="n">semi_token</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span>
                <span class="n">Semi</span>
            <span class="p">)</span>
        <span class="p">}</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Listing 19-32: The DeriveInput instance we get when parsing the code that has the macro’s attribute in Listing 19-30</p>

<p>The fields of this struct show that the Rust code we’ve parsed is a unit struct with the <code class="language-plaintext highlighter-rouge">ident</code> (identifier, meaning the name) of <code class="language-plaintext highlighter-rouge">Pancakes</code>. 
There are more fields on this struct for describing all sorts of Rust code; check the <code class="language-plaintext highlighter-rouge">syn</code> documentation for <code class="language-plaintext highlighter-rouge">DeriveInput</code> for more information.</p>

<p>Soon we’ll define the <code class="language-plaintext highlighter-rouge">impl_hello_macro</code> function, which is where we’ll build the new Rust code we want to include. 
But before we do, note that the output for our derive macro is also a <code class="language-plaintext highlighter-rouge">TokenStream</code>. 
The returned <code class="language-plaintext highlighter-rouge">TokenStream</code> is added to the code that our crate users write, so when they compile their crate, they’ll get the extra functionality that we provide in the modified <code class="language-plaintext highlighter-rouge">TokenStream</code>.</p>

<p>You might have noticed that we’re calling <code class="language-plaintext highlighter-rouge">unwrap</code> to cause the <code class="language-plaintext highlighter-rouge">hello_macro_derive</code> function to panic if the call to the <code class="language-plaintext highlighter-rouge">syn::parse</code> function fails here. 
It’s necessary for our procedural macro to panic on errors because <code class="language-plaintext highlighter-rouge">proc_macro_derive</code> functions must return <code class="language-plaintext highlighter-rouge">TokenStream</code> rather than <code class="language-plaintext highlighter-rouge">Result</code> to conform to the procedural macro API. 
We’ve simplified this example by using <code class="language-plaintext highlighter-rouge">unwrap</code>; in production code, you should provide more specific error messages about what went wrong by using <code class="language-plaintext highlighter-rouge">panic!</code> or <code class="language-plaintext highlighter-rouge">expect</code>.</p>

<p>Now that we have the code to turn the annotated Rust code from a <code class="language-plaintext highlighter-rouge">TokenStream</code> into a <code class="language-plaintext highlighter-rouge">DeriveInput</code> instance, let’s generate the code that implements the <code class="language-plaintext highlighter-rouge">HelloMacro</code> trait on the annotated type, as shown in Listing 19-33.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filename: hello_macro_derive/src/lib.rs</span>

<span class="k">fn</span> <span class="nf">impl_hello_macro</span><span class="p">(</span><span class="n">ast</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">syn</span><span class="p">::</span><span class="n">DeriveInput</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">name</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ast</span><span class="py">.ident</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">gen</span> <span class="o">=</span> <span class="nd">quote!</span> <span class="p">{</span>
        <span class="k">impl</span> <span class="n">HelloMacro</span> <span class="k">for</span> #<span class="n">name</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">hello_macro</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello, Macro! My name is {}!"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span>#<span class="n">name</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="n">gen</span><span class="nf">.into</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-19-33-implementing-the-hellomacro-trait-using-the-parsed-rust-code">Listing 19-33: Implementing the HelloMacro trait using the parsed Rust code</h4>

<p>We get an <code class="language-plaintext highlighter-rouge">Ident</code> struct instance containing the name (identifier) of the annotated type using <code class="language-plaintext highlighter-rouge">ast.ident</code>. 
The struct in Listing 19-32 shows that when we run the <code class="language-plaintext highlighter-rouge">impl_hello_macro</code> function on the code in Listing 19-30, the <code class="language-plaintext highlighter-rouge">ident</code> we get will have the <code class="language-plaintext highlighter-rouge">ident</code> field with a value of <code class="language-plaintext highlighter-rouge">"Pancakes"</code>. 
Thus, the <code class="language-plaintext highlighter-rouge">name</code> variable in Listing 19-33 will contain an <code class="language-plaintext highlighter-rouge">Ident</code> struct instance that, when printed, will be the string <code class="language-plaintext highlighter-rouge">"Pancakes"</code>, the name of the struct in Listing 19-30.</p>

<p>The <code class="language-plaintext highlighter-rouge">quote!</code> macro lets us define the Rust code that we want to return. 
The compiler expects something different to the direct result of the <code class="language-plaintext highlighter-rouge">quote!</code> macro’s execution, so we need to convert it to a <code class="language-plaintext highlighter-rouge">TokenStream</code>. 
We do this by calling the <code class="language-plaintext highlighter-rouge">into</code> method, which consumes this intermediate representation and returns a value of the required <code class="language-plaintext highlighter-rouge">TokenStream</code> type.</p>

<p>The <code class="language-plaintext highlighter-rouge">quote!</code> macro also provides some very cool templating mechanics: we can enter <code class="language-plaintext highlighter-rouge">#name</code>, and <code class="language-plaintext highlighter-rouge">quote!</code> will replace it with the value in the variable name. 
You can even do some repetition similar to the way regular macros work. 
Check out <a href="https://docs.rs/quote/1.0.8/quote/">the <code class="language-plaintext highlighter-rouge">quote</code> crate’s docs</a> for a thorough introduction.</p>

<p>We want our procedural macro to generate an implementation of our <code class="language-plaintext highlighter-rouge">HelloMacro</code> trait for the type the user annotated, which we can get by using <code class="language-plaintext highlighter-rouge">#name</code>. 
The trait implementation has one function, <code class="language-plaintext highlighter-rouge">hello_macro</code>, whose body contains the functionality we want to provide: printing <code class="language-plaintext highlighter-rouge">Hello, Macro! My name</code> is and then the name of the annotated type.</p>

<p>The <code class="language-plaintext highlighter-rouge">stringify!</code> macro used here is built into Rust. 
It takes a Rust expression, such as <code class="language-plaintext highlighter-rouge">1 + 2</code>, and at compile time turns the expression into a string literal, such as <code class="language-plaintext highlighter-rouge">"1 + 2"</code>. 
This is different than <code class="language-plaintext highlighter-rouge">format!</code> or <code class="language-plaintext highlighter-rouge">println!</code>, macros which evaluate the expression and then turn the result into a <code class="language-plaintext highlighter-rouge">String</code>. 
There is a possibility that the <code class="language-plaintext highlighter-rouge">#name</code> input might be an expression to print literally, so we use <code class="language-plaintext highlighter-rouge">stringify!</code>. 
Using <code class="language-plaintext highlighter-rouge">stringify!</code> also saves an allocation by converting <code class="language-plaintext highlighter-rouge">#name</code> to a string literal at compile time.</p>

<p>At this point, <code class="language-plaintext highlighter-rouge">cargo build</code> should complete successfully in both <code class="language-plaintext highlighter-rouge">hello_macro</code> and <code class="language-plaintext highlighter-rouge">hello_macro_derive</code>. 
Let’s hook up these crates to the code in Listing 19-30 to see the procedural macro in action! Create a new binary project in your <em>projects</em> directory using cargo new pancakes. 
We need to add <code class="language-plaintext highlighter-rouge">hello_macro</code> and <code class="language-plaintext highlighter-rouge">hello_macro_derive</code> as dependencies in the <code class="language-plaintext highlighter-rouge">pancakes</code> crate’s <em>Cargo.toml</em>. 
If you’re publishing your versions of <code class="language-plaintext highlighter-rouge">hello_macro</code> and <code class="language-plaintext highlighter-rouge">hello_macro_derive</code> to <a href="https://crates.io/">crates.io</a>, they would be regular dependencies; if not, you can specify them as <code class="language-plaintext highlighter-rouge">path</code> dependencies as follows:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">dependencies</span><span class="p">]</span>
<span class="n">hello_macro</span> <span class="o">=</span> <span class="p">{</span> <span class="n">path</span> <span class="o">=</span> <span class="s">"../hello_macro"</span> <span class="p">}</span>
<span class="n">hello_macro_derive</span> <span class="o">=</span> <span class="p">{</span> <span class="n">path</span> <span class="o">=</span> <span class="s">"../hello_macro/hello_macro_derive"</span> <span class="p">}</span>
</code></pre></div></div>
<p>Put the code in Listing 19-30 into <em>src/main.rs</em>, and run <code class="language-plaintext highlighter-rouge">cargo run</code>: it should print <code class="language-plaintext highlighter-rouge">Hello, Macro! My name is Pancakes!</code> The implementation of the <code class="language-plaintext highlighter-rouge">HelloMacro</code> trait from the procedural macro was included without the <code class="language-plaintext highlighter-rouge">pancakes</code> crate needing to implement it; the <code class="language-plaintext highlighter-rouge">#[derive(HelloMacro)]</code> added the trait implementation.</p>

<p>Next, let’s explore how the other kinds of procedural macros differ from custom derive macros.</p>

<h3 id="attribute-like-macros">Attribute-like macros</h3>
<p>Attribute-like macros are similar to custom derive macros, but instead of generating code for the <code class="language-plaintext highlighter-rouge">derive</code> attribute, they allow you to create new attributes. 
They’re also more flexible: <code class="language-plaintext highlighter-rouge">derive</code> only works for structs and enums; attributes can be applied to other items as well, such as functions. 
Here’s an example of using an attribute-like macro: say you have an attribute named <code class="language-plaintext highlighter-rouge">route</code> that annotates functions when using a web application framework:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[route(GET,</span> <span class="s">"/"</span><span class="nd">)]</span>
<span class="k">fn</span> <span class="nf">index</span><span class="p">()</span> <span class="p">{</span>
</code></pre></div></div>
<p>This <code class="language-plaintext highlighter-rouge">#[route]</code> attribute would be defined by the framework as a procedural macro. The signature of the macro definition function would look like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[proc_macro_attribute]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">route</span><span class="p">(</span><span class="n">attr</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
</code></pre></div></div>
<p>Here, we have two parameters of type <code class="language-plaintext highlighter-rouge">TokenStream</code>. 
The first is for the contents of the attribute: the <code class="language-plaintext highlighter-rouge">GET, "/"</code> part. 
The second is the body of the item the attribute is attached to: in this case, <code class="language-plaintext highlighter-rouge">fn index() {}</code> and the rest of the function’s body.</p>

<p>Other than that, attribute-like macros work the same way as custom derive macros: you create a crate with the <code class="language-plaintext highlighter-rouge">proc-macro</code> crate type and implement a function that generates the code you want!</p>

<h3 id="function-like-macros">Function-like macros</h3>
<p>Function-like macros define macros that look like function calls. 
Similarly to <code class="language-plaintext highlighter-rouge">macro_rules!</code> macros, they’re more flexible than functions; 
for example, they can take an unknown number of arguments. 
However, <code class="language-plaintext highlighter-rouge">macro_rules!</code> macros can be defined only using the match-like syntax we discussed in the section “Declarative Macros with <code class="language-plaintext highlighter-rouge">macro_rules!</code> for General Metaprogramming” earlier. 
Function-like macros take a <code class="language-plaintext highlighter-rouge">TokenStream</code> parameter and their definition manipulates that <code class="language-plaintext highlighter-rouge">TokenStream</code> using Rust code as the other two types of procedural macros do. 
An example of a function-like macro is an <code class="language-plaintext highlighter-rouge">sql!</code> macro that might be called like so:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">sql</span> <span class="o">=</span> <span class="nd">sql!</span><span class="p">(</span><span class="n">SELECT</span> <span class="o">*</span> <span class="n">FROM</span> <span class="n">posts</span> <span class="n">WHERE</span> <span class="n">id</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>
<p>This macro would parse the SQL statement inside it and check that it’s syntactically correct, which is much more complex processing than a <code class="language-plaintext highlighter-rouge">macro_rules!</code> macro can do. 
The <code class="language-plaintext highlighter-rouge">sql!</code> macro would be defined like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[proc_macro]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sql</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
</code></pre></div></div>
<p>This definition is similar to the custom derive macro’s signature: we receive the tokens that are inside the parentheses and return the code we wanted to generate.</p>

<h2 id="summary">Summary</h2>
<p>Whew! Now you have some Rust features in your toolbox that you won’t use often, but you’ll know they’re available in very particular circumstances. 
We’ve introduced several complex topics so that when you encounter them in error message suggestions or in other peoples’ code, you’ll be able to recognize these concepts and syntax. 
Use this chapter as a reference to guide you to solutions.</p>

<p>Next, we’ll put everything we’ve discussed throughout the book into practice and do one more project!</p>

        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/#advanced-functions" class="page__taxonomy-item" rel="tag">Advanced functions</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#advanced-traits" class="page__taxonomy-item" rel="tag">Advanced traits</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#advanced-types" class="page__taxonomy-item" rel="tag">Advanced types</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#closures" class="page__taxonomy-item" rel="tag">closures</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#macro" class="page__taxonomy-item" rel="tag">macro</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#unsafe" class="page__taxonomy-item" rel="tag">Unsafe</a>
    
    </span>
  </p>




  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/categories/#rust-language" class="page__taxonomy-item" rel="tag">RUST Language</a>
    
    </span>
  </p>


        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2020-12-27T00:00:00+00:00">December 27, 2020</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?text=RUST+%3A+19.+Advanced+Features%20https%3A%2F%2Fjjungs-lee.github.io%2F%2Frust%2F19.Advanced-Features" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fjjungs-lee.github.io%2F%2Frust%2F19.Advanced-Features" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fjjungs-lee.github.io%2F%2Frust%2F19.Advanced-Features" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/rust/18.Patterns-and-Matching" class="pagination--pager" title="RUST : 18. Patterns and Matching
">Previous</a>
    
    
      <a href="/rust/How-to-check-overflow-and-underflow-in-integer-types" class="pagination--pager" title="RUST : How to check overflow and underflow in integer types
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/rust/2.Primitives" rel="permalink">Rust by Example : 2. Primitives
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  6 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">Rust provides access to a wide variety of primitives. A sample includes:
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/rust/1.Hello-World" rel="permalink">Rust by Example : 1. Hello World
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  13 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">This is the source code of the traditional Hello World program.
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/rust/0.Rust-By-Exaple" rel="permalink">Rust by Example : 0. Introduction
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">If you’re studying rust, it’s very helpful to follow the examples. I’m going to try to study it. :)
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/vs%20code/VSCODE-Dev-set(Settings-Sync)/" rel="permalink">Dev Setting - Settings Sync
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">I have a trouble cuz the development settings at home and at work are different.
It’s so inconvenient. So I’m trying to use syncing up settings(vscode plugin...</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
      
        
      
        
          <li><a href="https://github.com/jjungs-lee" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
      
        
      
        
      
        
          <li><a href="https://www.linkedin.com/in/jjungs-lee" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
    

    <li><a href="NONE"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2022 JJungs-lee. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script src="https://kit.fontawesome.com/4eee35f757.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>







  </body>
</html>
