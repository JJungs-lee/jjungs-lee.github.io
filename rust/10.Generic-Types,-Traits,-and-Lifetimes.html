<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.17.2 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html -->

<!----><title>Yes! I Take IT :)</title>
<meta name="description" content="Generic Types, Traits, and LifetimesEvery programming language has tools for effectively handling the duplication of concepts. In Rust, one such tool is generics. Generics are abstract stand-ins for concrete types or other properties. When we’re writing code, we can express the behavior of generics or how they relate to other generics without knowing what will be in their place when compiling and running the code.">


  <meta name="author" content="JJungs-lee">


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Yes! I Take IT">
<meta property="og:title" content="RUST : 10. Generic Types, Traits, and Lifetimes">
<meta property="og:url" content="https://jjungs-lee.github.io//rust/10.Generic-Types,-Traits,-and-Lifetimes">


  <meta property="og:description" content="Generic Types, Traits, and LifetimesEvery programming language has tools for effectively handling the duplication of concepts. In Rust, one such tool is generics. Generics are abstract stand-ins for concrete types or other properties. When we’re writing code, we can express the behavior of generics or how they relate to other generics without knowing what will be in their place when compiling and running the code.">







  <meta property="article:published_time" content="2020-03-05T00:00:00+00:00">





  

  


<link rel="canonical" href="https://jjungs-lee.github.io//rust/10.Generic-Types,-Traits,-and-Lifetimes">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "JJungs-lee",
      "url": "https://jjungs-lee.github.io//"
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="NONE" type="application/atom+xml" rel="alternate" title="Yes! I Take IT Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          <b>I.T.I</b> <small>by JHLee</small>
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/posts/" >Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/kernel/" >Kernel</a>
            </li><li class="masthead__menu-item">
              <a href="/swim/" >Swim</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="/assets/images/author_jhl.png" alt="JJungs-lee" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">JJungs-lee</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>Do Coding! Do Study!</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Somewhere</span>
        </li>
      

      
        
          
        
          
        
          
        
          
        
          
            <li><a href="https://github.com/jjungs-lee" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
          
        
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="RUST : 10. Generic Types, Traits, and Lifetimes">
    <meta itemprop="description" content="Generic Types, Traits, and LifetimesEvery programming language has tools for effectively handling the duplication of concepts. In Rust, one such tool is generics. Generics are abstract stand-ins for concrete types or other properties. When we’re writing code, we can express the behavior of generics or how they relate to other generics without knowing what will be in their place when compiling and running the code.">
    <meta itemprop="datePublished" content="2020-03-05T00:00:00+00:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">RUST : 10. Generic Types, Traits, and Lifetimes
</h1>
          
            <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  60 minute read

</p>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
        <h2 id="generic-types-traits-and-lifetimes">Generic Types, Traits, and Lifetimes</h2>
<p>Every programming language has tools for effectively handling the duplication of concepts. 
In Rust, one such tool is <code class="language-plaintext highlighter-rouge">generics</code>. Generics are abstract stand-ins for concrete types or other properties. 
When we’re writing code, we can express the behavior of generics or how they relate to other generics without knowing what will be in their place when compiling and running the code.</p>

<p>Similar to the way a function takes parameters with unknown values to run the same code on multiple concrete values, 
functions can take parameters of some generic type instead of a concrete type, like i32 or String. 
In fact, we’ve already used generics in Chapter 6 with <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code>, Chapter 8 with <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code> and <code class="language-plaintext highlighter-rouge">HashMap&lt;K, V&gt;</code>, and Chapter 9 with <code class="language-plaintext highlighter-rouge">Result&lt;T, E&gt;</code>. 
In this chapter, you’ll explore how to define your own types, functions, and methods with generics!</p>

<p>First, we’ll review how to extract a function to reduce code duplication. Next, we’ll use the same technique to make a generic function from two functions that differ only in the types of their parameters. We’ll also explain how to use generic types in struct and enum definitions.</p>

<p>Then you’ll learn how to use <em>traits</em> to define behavior in a generic way. 
You can combine traits with generic types to constrain a generic type to only those types that have a particular behavior, as opposed to just any type.</p>

<p>Finally, we’ll discuss <em>lifetimes</em>, a variety of generics that give the compiler information about how references relate to each other. 
Lifetimes allow us to borrow values in many situations while still enabling the compiler to check that the references are valid.</p>

<h3 id="removing-duplication-by-extracting-a-function">Removing Duplication by Extracting a Function</h3>
<p>Before diving into generics syntax, let’s first look at how to remove duplication that doesn’t involve generic types by extracting a function. 
Then we’ll apply this technique to extract a generic function! In the same way that you recognize duplicated code to extract into a function, you’ll start to recognize duplicated code that can use generics.</p>

<p>Consider a short program that finds the largest number in a list, as shown in Listing 10-1.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">number_list</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">34</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">65</span><span class="p">];</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">largest</span> <span class="o">=</span> <span class="n">number_list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">for</span> <span class="n">number</span> <span class="n">in</span> <span class="n">number_list</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">number</span> <span class="o">&gt;</span> <span class="n">largest</span> <span class="p">{</span>
            <span class="n">largest</span> <span class="o">=</span> <span class="n">number</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"The largest number is {}"</span><span class="p">,</span> <span class="n">largest</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-10-1-code-to-find-the-largest-number-in-a-list-of-numbers">Listing 10-1: Code to find the largest number in a list of numbers</h4>
<p>This code stores a list of integers in the variable <code class="language-plaintext highlighter-rouge">number_list</code> and places the first number in the list in a variable named <code class="language-plaintext highlighter-rouge">largest</code>. 
Then it iterates through all the numbers in the list, and if the current number is greater than the number stored in <code class="language-plaintext highlighter-rouge">largest</code>, it replaces the number in that variable. 
However, if the current number is less than or equal to the largest number seen so far, the variable doesn’t change, and the code moves on to the next number in the list. 
After considering all the numbers in the list, <code class="language-plaintext highlighter-rouge">largest</code> should hold the largest number, which in this case is 100.</p>

<p>To find the largest number in two different lists of numbers, we can duplicate the code in Listing 10-1 and use the same logic at two different places in the program, as shown in Listing 10-2.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">number_list</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">34</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">65</span><span class="p">];</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">largest</span> <span class="o">=</span> <span class="n">number_list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">for</span> <span class="n">number</span> <span class="n">in</span> <span class="n">number_list</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">number</span> <span class="o">&gt;</span> <span class="n">largest</span> <span class="p">{</span>
            <span class="n">largest</span> <span class="o">=</span> <span class="n">number</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"The largest number is {}"</span><span class="p">,</span> <span class="n">largest</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">number_list</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">102</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">6000</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">8</span><span class="p">];</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">largest</span> <span class="o">=</span> <span class="n">number_list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">for</span> <span class="n">number</span> <span class="n">in</span> <span class="n">number_list</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">number</span> <span class="o">&gt;</span> <span class="n">largest</span> <span class="p">{</span>
            <span class="n">largest</span> <span class="o">=</span> <span class="n">number</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"The largest number is {}"</span><span class="p">,</span> <span class="n">largest</span><span class="p">);</span>
</code></pre></div></div>
<h4 id="listing-10-2-code-to-find-the-largest-number-in-two-lists-of-numbers">Listing 10-2: Code to find the largest number in two lists of numbers</h4>
<p>Although this code works, <strong>duplicating</strong> code is tedious and error prone. 
We also have to update the code in multiple places when we want to change it.</p>

<p>To eliminate this duplication, we can create an abstraction by defining a function that operates on any list of integers given to it in a parameter. 
This solution makes our code clearer and lets us express the concept of finding the largest number in a list abstractly.</p>

<p>In Listing 10-3, we extracted the code that finds the largest number into a function named largest. 
Unlike the code in Listing 10-1, which can find the largest number in only one particular list, this program can find the largest number in two different lists.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">largest</span><span class="p">(</span><span class="n">list</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">i32</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">largest</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">for</span> <span class="o">&amp;</span><span class="n">item</span> <span class="n">in</span> <span class="n">list</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="n">largest</span> <span class="p">{</span>
            <span class="n">largest</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">largest</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">number_list</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">34</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">65</span><span class="p">];</span>

    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">largest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">number_list</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"The largest number is {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">number_list</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">102</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">6000</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">8</span><span class="p">];</span>

    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">largest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">number_list</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"The largest number is {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-10-3-abstracted-code-to-find-the-largest-number-in-two-lists">Listing 10-3: Abstracted code to find the largest number in two lists</h4>
<p>The <code class="language-plaintext highlighter-rouge">largest</code> function has a parameter called <code class="language-plaintext highlighter-rouge">list</code>, 
which represents any concrete slice of <code class="language-plaintext highlighter-rouge">i32</code> values that we might pass into the function. As a result, when we call the function, the code runs on the specific values that we pass in.</p>

<p>In sum, here are the steps we took to change the code from Listing 10-2 to Listing 10-3:</p>

<ol>
  <li>Identify duplicate code.</li>
  <li>Extract the duplicate code into the body of the function and specify the inputs and return values of that code in the function signature.</li>
  <li>Update the two instances of duplicated code to call the function instead.</li>
</ol>

<p>Next, we’ll use these same steps with generics to reduce code duplication in different ways. 
In the same way that the function body can operate on an abstract list instead of specific values, 
generics allow code to operate on abstract types.</p>

<h2 id="generic-data-types">Generic Data Types</h2>
<p>We can use generics to create definitions for items like function signatures or structs, 
which we can then use with many different concrete data types. 
Let’s first look at how to define functions, structs, enums, and methods using generics. 
Then we’ll discuss how generics affect code performance.</p>

<h3 id="in-function-definitions">In Function Definitions</h3>
<p>When defining a function that uses generics, we place the generics in the signature of the function where we would usually specify the data types of the parameters and return value. 
Doing so makes our code more flexible and provides more functionality to callers of our function while preventing code duplication.</p>

<p>Continuing with our <code class="language-plaintext highlighter-rouge">largest</code> function, Listing 10-4 shows two functions that both find the largest value in a slice.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">largest_i32</span><span class="p">(</span><span class="n">list</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">i32</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">largest</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">for</span> <span class="o">&amp;</span><span class="n">item</span> <span class="n">in</span> <span class="n">list</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="n">largest</span> <span class="p">{</span>
            <span class="n">largest</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">largest</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">largest_char</span><span class="p">(</span><span class="n">list</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">char</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">char</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">largest</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">for</span> <span class="o">&amp;</span><span class="n">item</span> <span class="n">in</span> <span class="n">list</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="n">largest</span> <span class="p">{</span>
            <span class="n">largest</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">largest</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">number_list</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">34</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">65</span><span class="p">];</span>

    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">largest_i32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">number_list</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"The largest number is {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">char_list</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="sc">'y'</span><span class="p">,</span> <span class="sc">'m'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'q'</span><span class="p">];</span>

    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">largest_char</span><span class="p">(</span><span class="o">&amp;</span><span class="n">char_list</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"The largest char is {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-10-4-two-functions-that-differ-only-in-their-names-and-the-types-in-their-signatures">Listing 10-4: Two functions that differ only in their names and the types in their signatures</h4>

<p>The <code class="language-plaintext highlighter-rouge">largest_i32</code> function is the one we extracted in Listing 10-3 that finds the largest <code class="language-plaintext highlighter-rouge">i32</code> in a slice. 
The <code class="language-plaintext highlighter-rouge">largest_char</code> function finds the largest <code class="language-plaintext highlighter-rouge">char</code> in a slice. 
The function bodies have the same code, so let’s eliminate the duplication by introducing a generic type parameter in a single function.</p>

<p>To parameterize the types in the new function we’ll define, we need to name the type parameter, just as we do for the value parameters to a function. You can use any identifier as a type parameter name. 
But we’ll use <code class="language-plaintext highlighter-rouge">T</code> because, by convention, parameter names in Rust are short, often just a letter, and Rust’s type-naming convention is CamelCase. Short for “type,” <code class="language-plaintext highlighter-rouge">T</code> is the default choice of most Rust programmers.</p>

<p>When we use a parameter in the body of the function, we have to declare the parameter name in the signature so the compiler knows what that name means. 
Similarly, when we use a type parameter name in a function signature, we have to declare the type parameter name before we use it. 
To define the generic <code class="language-plaintext highlighter-rouge">largest</code> function, place type name declarations inside angle brackets, <code class="language-plaintext highlighter-rouge">&lt;&gt;</code>, between the name of the function and the parameter list, like this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">largest</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">list</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
</code></pre></div></div>

<p>We read this definition as: the function <code class="language-plaintext highlighter-rouge">largest</code> is generic over some type <code class="language-plaintext highlighter-rouge">T</code>. 
This function has one parameter named <code class="language-plaintext highlighter-rouge">list</code>, which is a slice of values of type <code class="language-plaintext highlighter-rouge">T</code>. 
The <code class="language-plaintext highlighter-rouge">largest</code> function will return a value of the same type <code class="language-plaintext highlighter-rouge">T</code>.</p>

<p>Listing 10-5 shows the combined largest function definition using the generic data type in its signature. 
The listing also shows how we can call the function with either a slice of <code class="language-plaintext highlighter-rouge">i32</code> values or <code class="language-plaintext highlighter-rouge">char</code> values. 
Note that this code won’t compile yet, but we’ll fix it later in this chapter.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">largest</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">list</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">largest</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">for</span> <span class="o">&amp;</span><span class="n">item</span> <span class="n">in</span> <span class="n">list</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="n">largest</span> <span class="p">{</span>
            <span class="n">largest</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">largest</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">number_list</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">34</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">65</span><span class="p">];</span>

    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">largest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">number_list</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"The largest number is {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">char_list</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="sc">'y'</span><span class="p">,</span> <span class="sc">'m'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'q'</span><span class="p">];</span>

    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">largest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">char_list</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"The largest char is {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-10-5-a-definition-of-the-largest-function-that-uses-generic-type-parameters-but-doesnt-compile-yet">Listing 10-5: A definition of the largest function that uses generic type parameters but doesn’t compile yet</h4>

<p>If we compile this code right now, we’ll get this error:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">error</span><span class="p">[</span><span class="n">E0369</span><span class="p">]:</span> <span class="n">binary</span> <span class="n">operation</span> <span class="err">`</span><span class="o">&gt;</span><span class="err">`</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">applied</span> <span class="n">to</span> <span class="k">type</span> <span class="err">`</span><span class="n">T</span><span class="err">`</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span><span class="mi">12</span>
  <span class="p">|</span>
<span class="mi">5</span> <span class="p">|</span>         <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="n">largest</span> <span class="p">{</span>
  <span class="p">|</span>            <span class="o">^^^^^^^^^^^^^^</span>
  <span class="p">|</span>
  <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">an</span> <span class="n">implementation</span> <span class="n">of</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="n">PartialOrd</span><span class="err">`</span> 
          <span class="n">might</span> <span class="n">be</span> <span class="n">missing</span> <span class="k">for</span> <span class="err">`</span><span class="n">T</span><span class="err">`</span>
</code></pre></div></div>
<p>The note mentions <code class="language-plaintext highlighter-rouge">std::cmp::PartialOrd</code>, which is a <em>trait</em>. 
We’ll talk about traits in the next section. 
For now, this error states that the body of largest won’t work for all possible types that <code class="language-plaintext highlighter-rouge">T</code> could be. 
Because we want to compare values of type <code class="language-plaintext highlighter-rouge">T</code> in the body, we can only use types whose values can be ordered. 
To enable comparisons, the standard library has the <code class="language-plaintext highlighter-rouge">std::cmp::PartialOrd</code> trait that you can implement on types (see Appendix C for more on this trait). 
You’ll learn how to specify that a generic type has a particular trait in the “Traits as Parameters” section, but let’s first explore other ways of using generic type parameters.</p>

<h3 id="in-struct-definitions">In Struct Definitions</h3>
<p>We can also define structs to use a generic type parameter in one or more fields using the <code class="language-plaintext highlighter-rouge">&lt;&gt;</code> syntax. 
Listing 10-6 shows how to define a <code class="language-plaintext highlighter-rouge">Point&lt;T&gt;</code> struct to hold <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> coordinate values of any type.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">integer</span> <span class="o">=</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">10</span> <span class="p">};</span>
    <span class="k">let</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">4.0</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>
<p>#### 
Listing 10-6: A Point<T> struct that holds x and y values of type T</T></p>

<p>The syntax for using generics in struct definitions is similar to that used in function definitions. First, we declare the name of the type parameter inside angle brackets just after the name of the struct. Then we can use the generic type in the struct definition where we would otherwise specify concrete data types.</p>

<p>Note that because we’ve used only one generic type to define Point<T>, this definition says that the Point<T> struct is generic over some type T, and the fields x and y are both that same type, whatever that type may be. If we create an instance of a Point<T> that has values of different types, as in Listing 10-7, our code won’t compile.</T></T></T></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">wont_work</span> <span class="o">=</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">4.0</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-10-7-the-fields-x-and-y-must-be-the-same-type-because-both-have-the-same-generic-data-type-t">Listing 10-7: The fields x and y must be the same type because both have the same generic data type T.</h4>
<p>In this example, when we assign the integer value 5 to x, we let the compiler know that the generic type T will be an integer for this instance of <code class="language-plaintext highlighter-rouge">Point&lt;T&gt;</code>. Then when we specify 4.0 for y, which we’ve defined to have the same type as x, we’ll get a type mismatch error like this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">error</span><span class="p">[</span><span class="n">E0308</span><span class="p">]:</span> <span class="n">mismatched</span> <span class="n">types</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">7</span><span class="p">:</span><span class="mi">38</span>
  <span class="p">|</span>
<span class="mi">7</span> <span class="p">|</span>     <span class="k">let</span> <span class="n">wont_work</span> <span class="o">=</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">4.0</span> <span class="p">};</span>
  <span class="p">|</span>                                      <span class="o">^^^</span> <span class="n">expected</span> <span class="n">integer</span><span class="p">,</span> <span class="n">found</span>
<span class="n">floating</span><span class="o">-</span><span class="n">point</span> <span class="n">number</span>
  <span class="p">|</span>
  <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">expected</span> <span class="k">type</span> <span class="err">`</span><span class="p">{</span><span class="n">integer</span><span class="p">}</span><span class="err">`</span>
             <span class="n">found</span> <span class="k">type</span> <span class="err">`</span><span class="p">{</span><span class="nb">float</span><span class="p">}</span><span class="err">`</span>
</code></pre></div></div>
<p>To define a Point struct where x and y are both generics but could have different types, we can use multiple generic type parameters. 
For example, in Listing 10-8, we can change the definition of Point to be generic over types T and U where x is of type T and y is of type U.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Point</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">U</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">both_integer</span> <span class="o">=</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">10</span> <span class="p">};</span>
    <span class="k">let</span> <span class="n">both_float</span> <span class="o">=</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">4.0</span> <span class="p">};</span>
    <span class="k">let</span> <span class="n">integer_and_float</span> <span class="o">=</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">4.0</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-10-8-a-pointt-u-generic-over-two-types-so-that-x-and-y-can-be-values-of-different-types">Listing 10-8: A Point&lt;T, U&gt; generic over two types so that x and y can be values of different types</h4>
<p>Now all the instances of Point shown are allowed! You can use as many generic type parameters in a definition as you want, but using more than a few makes your code hard to read. When you need lots of generic types in your code, it could indicate that your code needs restructuring into smaller pieces.</p>

<h3 id="in-enum-definitions">In Enum Definitions</h3>
<p>As we did with structs, we can define <strong>enums</strong> to hold generic data types in their variants. 
Let’s take another look at the <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code> enum that the standard library provides, which we used in Chapter 6:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">T</span><span class="p">),</span>
    <span class="nb">None</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This definition should now make more sense to you. 
As you can see, <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code> is an enum that is generic over type <code class="language-plaintext highlighter-rouge">T</code> and has <strong>two</strong> variants: <code class="language-plaintext highlighter-rouge">Some</code>, which holds one value of type <code class="language-plaintext highlighter-rouge">T</code>, and a <code class="language-plaintext highlighter-rouge">None</code> variant that doesn’t hold any value. 
By using the <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code> enum, we can express the abstract concept of having an optional value, and because <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code> is generic, we can use this abstraction no matter what the type of the optional value is.</p>

<p>Enums can use multiple generic types as well. 
The definition of the <code class="language-plaintext highlighter-rouge">Result</code> enum that we used in Chapter 9 is one example:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">T</span><span class="p">),</span>
    <span class="nf">Err</span><span class="p">(</span><span class="n">E</span><span class="p">),</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">Result</code> enum is generic over <strong>two</strong> types, <code class="language-plaintext highlighter-rouge">T</code> and <code class="language-plaintext highlighter-rouge">E</code>, and has two variants: <code class="language-plaintext highlighter-rouge">Ok</code>, which holds a value of type <code class="language-plaintext highlighter-rouge">T</code>, and <code class="language-plaintext highlighter-rouge">Err</code>, which holds a value of type <code class="language-plaintext highlighter-rouge">E</code>. 
This definition makes it convenient to use the <code class="language-plaintext highlighter-rouge">Result</code> enum anywhere we have an operation that might succeed (return a value of some type <code class="language-plaintext highlighter-rouge">T</code>) or fail (return an error of some type <code class="language-plaintext highlighter-rouge">E</code>). 
In fact, this is what we used to open a file in Listing 9-3, where <code class="language-plaintext highlighter-rouge">T</code> was filled in with the type <code class="language-plaintext highlighter-rouge">std::fs::File</code> when the file was opened successfully and <code class="language-plaintext highlighter-rouge">E</code> was filled in with the type <code class="language-plaintext highlighter-rouge">std::io::Error</code> when there were problems opening the file.</p>

<p>When you recognize situations in your code with multiple struct or enum definitions that differ only in the types of the values they hold, you can avoid duplication by using generic types instead.</p>

<h3 id="in-method-definitions">In Method Definitions</h3>
<p>We can implement methods on <strong>structs</strong> and <strong>enums</strong> (as we did in Chapter 5) and use generic types in their definitions, too. 
Listing 10-9 shows the <code class="language-plaintext highlighter-rouge">Point&lt;T&gt;</code> struct we defined in Listing 10-6 with a method named <code class="language-plaintext highlighter-rouge">x</code> implemented on it.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">x</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="py">.x</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">10</span> <span class="p">};</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"p.x = {}"</span><span class="p">,</span> <span class="n">p</span><span class="nf">.x</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-10-9-implementing-a-method-named-x-on-the-point-struct-that-will-return-a-reference-to-the-x-field-of-type-t">Listing 10-9: Implementing a method named x on the Point<T> struct that will return a reference to the x field of type T</T></h4>

<p>Here, we’ve defined a method named <code class="language-plaintext highlighter-rouge">x</code> on <code class="language-plaintext highlighter-rouge">Point&lt;T&gt;</code> that returns a reference to the data in the field x.</p>

<p>Note that we have to declare <code class="language-plaintext highlighter-rouge">T</code> just after <code class="language-plaintext highlighter-rouge">impl</code> so we can use it to specify that we’re implementing methods on the type <code class="language-plaintext highlighter-rouge">Point&lt;T&gt;</code>. 
By declaring <code class="language-plaintext highlighter-rouge">T</code> as a generic type after <code class="language-plaintext highlighter-rouge">impl</code>, Rust can identify that the type in the angle brackets in <code class="language-plaintext highlighter-rouge">Point</code> is a generic type rather than a concrete type.</p>

<p>We could, for example, implement methods only on <code class="language-plaintext highlighter-rouge">Point&lt;f32&gt;</code> instances rather than on <code class="language-plaintext highlighter-rouge">Point&lt;T&gt;</code> instances with any generic type. 
In Listing 10-10 we use the concrete type <code class="language-plaintext highlighter-rouge">f32</code>, meaning we don’t declare any types after <code class="language-plaintext highlighter-rouge">impl</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">Point</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">distance_from_origin</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">f32</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">self</span><span class="py">.x</span><span class="nf">.powi</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="k">self</span><span class="py">.y</span><span class="nf">.powi</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="nf">.sqrt</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-10-10-an-impl-block-that-only-applies-to-a-struct-with-a-particular-concrete-type-for-the-generic-type-parameter-t">Listing 10-10: An impl block that only applies to a struct with a particular concrete type for the generic type parameter T</h4>
<p>This code means the type <code class="language-plaintext highlighter-rouge">Point&lt;f32&gt;</code> will have a method named <code class="language-plaintext highlighter-rouge">distance_from_origin</code> and other instances of <code class="language-plaintext highlighter-rouge">Point&lt;T&gt;</code> where <code class="language-plaintext highlighter-rouge">T</code> is not of type <code class="language-plaintext highlighter-rouge">f32</code> will not have this method defined. 
The method measures how far our point is from the point at coordinates (0.0, 0.0) and uses mathematical operations that are available only for floating point types.</p>

<p>Generic type parameters in a struct definition aren’t always the same as those you use in that struct’s method signatures. 
For example, Listing 10-11 defines the method <code class="language-plaintext highlighter-rouge">mixup</code> on the <code class="language-plaintext highlighter-rouge">Point&lt;T, U&gt;</code> struct from Listing 10-8. 
The method takes another <code class="language-plaintext highlighter-rouge">Point</code> as a parameter, which might have different types from the <code class="language-plaintext highlighter-rouge">self</code> <code class="language-plaintext highlighter-rouge">Point</code> we’re calling <code class="language-plaintext highlighter-rouge">mixup</code> on. 
The method creates a new <code class="language-plaintext highlighter-rouge">Point</code> instance with the <code class="language-plaintext highlighter-rouge">x</code> value from the <code class="language-plaintext highlighter-rouge">self</code> <code class="language-plaintext highlighter-rouge">Point</code> (of type <code class="language-plaintext highlighter-rouge">T</code>) and the <code class="language-plaintext highlighter-rouge">y</code> value from the passed-in <code class="language-plaintext highlighter-rouge">Point</code> (of type <code class="language-plaintext highlighter-rouge">W</code>).</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Point</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">U</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="n">Point</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">mixup</span><span class="o">&lt;</span><span class="n">V</span><span class="p">,</span> <span class="n">W</span><span class="o">&gt;</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Point</span><span class="o">&lt;</span><span class="n">V</span><span class="p">,</span> <span class="n">W</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Point</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">W</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">Point</span> <span class="p">{</span>
            <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span><span class="p">,</span>
            <span class="n">y</span><span class="p">:</span> <span class="n">other</span><span class="py">.y</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">10.4</span> <span class="p">};</span>
    <span class="k">let</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="s">"Hello"</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="sc">'c'</span><span class="p">};</span>

    <span class="k">let</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">p1</span><span class="nf">.mixup</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"p3.x = {}, p3.y = {}"</span><span class="p">,</span> <span class="n">p3</span><span class="py">.x</span><span class="p">,</span> <span class="n">p3</span><span class="py">.y</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-10-11-a-method-that-uses-different-generic-types-from-its-structs-definition">Listing 10-11: A method that uses different generic types from its struct’s definition</h4>
<p>In <code class="language-plaintext highlighter-rouge">main</code>, we’ve defined a <code class="language-plaintext highlighter-rouge">Point</code> that has an <code class="language-plaintext highlighter-rouge">i32</code> for <code class="language-plaintext highlighter-rouge">x</code> (with value <code class="language-plaintext highlighter-rouge">5</code>) and an <code class="language-plaintext highlighter-rouge">f64</code> for <code class="language-plaintext highlighter-rouge">y</code> (with value 10.4). 
The <code class="language-plaintext highlighter-rouge">p2</code> variable is a <code class="language-plaintext highlighter-rouge">Point</code> struct that has a <code class="language-plaintext highlighter-rouge">string slice</code> for <code class="language-plaintext highlighter-rouge">x</code> (with value <code class="language-plaintext highlighter-rouge">"Hello"</code>) and a <code class="language-plaintext highlighter-rouge">char</code> for <code class="language-plaintext highlighter-rouge">y</code> (with value <code class="language-plaintext highlighter-rouge">c</code>). 
Calling <code class="language-plaintext highlighter-rouge">mixup</code> on <code class="language-plaintext highlighter-rouge">p1</code> with the argument <code class="language-plaintext highlighter-rouge">p2</code> gives us <code class="language-plaintext highlighter-rouge">p3</code>, which will have an <code class="language-plaintext highlighter-rouge">i32</code> for <code class="language-plaintext highlighter-rouge">x</code>, because <code class="language-plaintext highlighter-rouge">x</code> came from <code class="language-plaintext highlighter-rouge">p1</code>. 
The <code class="language-plaintext highlighter-rouge">p3</code> variable will have a char for <code class="language-plaintext highlighter-rouge">y</code>, because <code class="language-plaintext highlighter-rouge">y</code> came from <code class="language-plaintext highlighter-rouge">p2</code>. The println! macro call will print <code class="language-plaintext highlighter-rouge">p3.x = 5, p3.y = c</code>.</p>

<p>The purpose of this example is to demonstrate a situation in which some generic parameters are declared with <code class="language-plaintext highlighter-rouge">impl</code> and some are declared with the method definition. 
Here, the generic parameters <code class="language-plaintext highlighter-rouge">T</code> and <code class="language-plaintext highlighter-rouge">U</code> are declared after <code class="language-plaintext highlighter-rouge">impl</code>, because they go with the struct definition. 
The generic parameters <code class="language-plaintext highlighter-rouge">V</code> and <code class="language-plaintext highlighter-rouge">W</code> are declared after <code class="language-plaintext highlighter-rouge">fn mixup</code>, because they’re only relevant to the method.</p>

<h3 id="performance-of-code-using-generics">Performance of Code Using Generics</h3>
<p>You might be wondering whether there is a runtime cost when you’re using generic type parameters. 
The good news is that Rust implements generics in such a way that your code doesn’t run <strong>any slower</strong> using generic types than it would with concrete types.</p>

<p>Rust accomplishes this by performing <em>monomorphization</em> of the code that is using generics at compile time. 
<strong>Monomorphization</strong> is the process of turning generic code into specific code by filling in the concrete types that are used when compiled.</p>

<p>In this process, the compiler does the opposite of the steps we used to create the generic function in Listing 10-5: 
the compiler looks at all the places where generic code is called and generates code for the concrete types the generic code is called with.</p>

<p>Let’s look at how this works with an example that uses the standard library’s <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code> enum:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">integer</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="k">let</span> <span class="nb">float</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="mf">5.0</span><span class="p">);</span>
</code></pre></div></div>
<p>When Rust compiles this code, it performs monomorphization. 
During that process, the compiler reads the values that have been used in <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code> instances and identifies two kinds of <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code>: one is <code class="language-plaintext highlighter-rouge">i32</code> and the other is <code class="language-plaintext highlighter-rouge">f64</code>. 
As such, it expands the generic definition of <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code> into <code class="language-plaintext highlighter-rouge">Option_i32</code> and <code class="language-plaintext highlighter-rouge">Option_f64</code>, thereby <strong>replacing</strong> the generic definition with the specific ones.</p>

<p>The monomorphized version of the code looks like the following. The generic <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code> is replaced with the specific definitions created by the compiler:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Option_i32</span> <span class="p">{</span>
    <span class="nf">Some</span><span class="p">(</span><span class="nb">i32</span><span class="p">),</span>
    <span class="nb">None</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">Option_f64</span> <span class="p">{</span>
    <span class="nf">Some</span><span class="p">(</span><span class="nb">f64</span><span class="p">),</span>
    <span class="nb">None</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">integer</span> <span class="o">=</span> <span class="nn">Option_i32</span><span class="p">::</span><span class="nf">Some</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="k">let</span> <span class="nb">float</span> <span class="o">=</span> <span class="nn">Option_f64</span><span class="p">::</span><span class="nf">Some</span><span class="p">(</span><span class="mf">5.0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Because Rust compiles generic code into code that specifies the type in each instance, <strong>we pay no runtime cost for using generics</strong>. 
When the code runs, it performs just as it would if we had duplicated each definition by hand. 
The process of monomorphization makes Rust’s generics extremely efficient at runtime.</p>

<h2 id="traits-defining-shared-behavior">Traits: Defining Shared Behavior</h2>
<p>A <em>trait</em> tells the Rust compiler about functionality a particular type has and can share with other types. 
We can use traits to define shared behavior in an abstract way. 
We can use <strong>trait bounds</strong> to specify that a generic can be any type that has certain behavior.</p>

<p class="notice--info"><strong>Note</strong>: Traits are similar to a feature often called interfaces in other languages, although with some differences.</p>

<h3 id="defining-a-trait">Defining a Trait</h3>
<p>A type’s behavior consists of the methods we can call on that type. 
Different types share the same behavior if we can call the same methods on all of those types. 
<strong>Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose</strong>.</p>

<p>For example, let’s say we have multiple structs that hold various kinds and amounts of text: a <code class="language-plaintext highlighter-rouge">NewsArticle</code> struct that holds a news story filed in a particular location and a <code class="language-plaintext highlighter-rouge">Tweet</code> that can have at most 280 characters along with metadata that indicates whether it was a new tweet, a retweet, or a reply to another tweet.</p>

<p>We want to make a media aggregator library that can display summaries of data that might be stored in a <code class="language-plaintext highlighter-rouge">NewsArticle</code> or <code class="language-plaintext highlighter-rouge">Tweet</code> instance. 
To do this, we need a summary from each type, and we need to request that summary by calling a <code class="language-plaintext highlighter-rouge">summarize</code> method on an instance. 
Listing 10-12 shows the definition of a <code class="language-plaintext highlighter-rouge">Summary</code> trait that expresses this behavior.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">Summary</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">summarize</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-10-12-a-summary-trait-that-consists-of-the-behavior-provided-by-a-summarize-method">Listing 10-12: A Summary trait that consists of the behavior provided by a summarize method</h4>
<p>Here, we declare a trait using the <code class="language-plaintext highlighter-rouge">trait</code> keyword and then the trait’s name, which is <code class="language-plaintext highlighter-rouge">Summary</code> in this case. 
Inside the curly brackets, we declare the method signatures that describe the behaviors of the types that implement this trait, which in this case is <code class="language-plaintext highlighter-rouge">fn summarize(&amp;self) -&gt; String</code>.</p>

<p>After the method signature, instead of providing an implementation within curly brackets, we use a semicolon. 
Each type implementing this trait must provide its own custom behavior for the body of the method. 
The compiler will enforce that any type that has the <code class="language-plaintext highlighter-rouge">Summary</code> trait will have the method <code class="language-plaintext highlighter-rouge">summarize</code> defined with this signature exactly.</p>

<p>A trait can have multiple <strong>methods</strong> in its body: the method signatures are listed one per line and each line ends in a semicolon.</p>

<h3 id="implementing-a-trait-on-a-type">Implementing a Trait on a Type</h3>
<p>Now that we’ve defined the desired behavior using the <code class="language-plaintext highlighter-rouge">Summary</code> trait, we can implement it on the types in our media aggregator. 
Listing 10-13 shows an implementation of the <code class="language-plaintext highlighter-rouge">Summary</code> trait on the <code class="language-plaintext highlighter-rouge">NewsArticle</code> struct that uses the headline, the author, and the location to create the return value of <code class="language-plaintext highlighter-rouge">summarize</code>. 
For the <code class="language-plaintext highlighter-rouge">Tweet</code> struct, we define <code class="language-plaintext highlighter-rouge">summarize</code> as the username followed by the entire text of the tweet, assuming that tweet content is already limited to 280 characters.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">NewsArticle</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">headline</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">location</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">author</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">content</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Summary</span> <span class="k">for</span> <span class="n">NewsArticle</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">summarize</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"{}, by {} ({})"</span><span class="p">,</span> <span class="k">self</span><span class="py">.headline</span><span class="p">,</span> <span class="k">self</span><span class="py">.author</span><span class="p">,</span> <span class="k">self</span><span class="py">.location</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Tweet</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">username</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">content</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">reply</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">retweet</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Summary</span> <span class="k">for</span> <span class="n">Tweet</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">summarize</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"{}: {}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.username</span><span class="p">,</span> <span class="k">self</span><span class="py">.content</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-10-13-implementing-the-summary-trait-on-the-newsarticle-and-tweet-types">Listing 10-13: Implementing the Summary trait on the NewsArticle and Tweet types</h4>

<p>Implementing a trait on a type is similar to implementing regular methods. 
The difference is that after <code class="language-plaintext highlighter-rouge">impl</code>, we put the <code class="language-plaintext highlighter-rouge">trait name</code> that we want to implement, then use the <code class="language-plaintext highlighter-rouge">for</code> keyword, and then <code class="language-plaintext highlighter-rouge">specify the name of the type</code> we want to implement the trait for. 
Within the <code class="language-plaintext highlighter-rouge">impl</code> block, we put the method signatures that the trait definition has defined. 
Instead of adding a semicolon after each signature, we use curly brackets and fill in the method body with the specific behavior that we want the methods of the trait to have for the particular type.</p>

<p>After implementing the trait, we can call the methods on instances of <code class="language-plaintext highlighter-rouge">NewsArticle</code> and <code class="language-plaintext highlighter-rouge">Tweet</code> in the same way we call regular methods, like this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">tweet</span> <span class="o">=</span> <span class="n">Tweet</span> <span class="p">{</span>
    <span class="n">username</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"horse_ebooks"</span><span class="p">),</span>
    <span class="n">content</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"of course, as you probably already know, people"</span><span class="p">),</span>
    <span class="n">reply</span><span class="p">:</span> <span class="k">false</span><span class="p">,</span>
    <span class="n">retweet</span><span class="p">:</span> <span class="k">false</span><span class="p">,</span>
<span class="p">};</span>

<span class="nd">println!</span><span class="p">(</span><span class="s">"1 new tweet: {}"</span><span class="p">,</span> <span class="n">tweet</span><span class="nf">.summarize</span><span class="p">());</span>
</code></pre></div></div>
<p>This code prints <code class="language-plaintext highlighter-rouge">1 new tweet: horse_ebooks: of course, as you probably already know, people</code>.</p>

<p>Note that because we defined the <code class="language-plaintext highlighter-rouge">Summary</code> trait and the <code class="language-plaintext highlighter-rouge">NewsArticle</code> and <code class="language-plaintext highlighter-rouge">Tweet</code> types in the same <em>lib.rs</em> in Listing 10-13, they’re all in the same scope. 
Let’s say this <em>lib.rs</em> is for a crate we’ve called <code class="language-plaintext highlighter-rouge">aggregator</code> and someone else wants to use our crate’s functionality to implement the <code class="language-plaintext highlighter-rouge">Summary</code> trait on a struct defined within their library’s scope. 
They would need to bring the trait into their scope first. 
They would do so by <code class="language-plaintext highlighter-rouge">specifying use aggregator::Summary;</code>, which then would enable them to implement <code class="language-plaintext highlighter-rouge">Summary</code> for their type.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="n">crate</span> <span class="n">aggregator</span><span class="p">;</span>

<span class="k">use</span> <span class="nn">aggregator</span><span class="p">::</span><span class="n">Summary</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">WeatherForecast</span> <span class="p">{</span>
    <span class="n">high_temp</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span>
    <span class="n">low_temp</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span>
    <span class="n">chance_of_precipitation</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Summary</span> <span class="k">for</span> <span class="n">WeatherForecast</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">summarize</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"The high will be {}, and the low will be {}. The chance of
        precipitation is {}%."</span><span class="p">,</span> <span class="k">self</span><span class="py">.high_temp</span><span class="p">,</span> <span class="k">self</span><span class="py">.low_temp</span><span class="p">,</span>
        <span class="k">self</span><span class="py">.chance_of_precipitation</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">Summary</code> trait would also need to be a public trait for another crate to implement it, which it is because we put the pub keyword before trait in Listing 10-12.</p>

<p>One restriction to note with trait implementations is that we can implement a trait on a type only if either the <strong>trait</strong> or the <strong>type is local to our crate</strong>. 
For example, we can implement standard library traits like <code class="language-plaintext highlighter-rouge">Display</code> on a custom type like <code class="language-plaintext highlighter-rouge">Tweet</code> as part of our <code class="language-plaintext highlighter-rouge">aggregator</code> crate functionality, because the type <code class="language-plaintext highlighter-rouge">Tweet</code> is local to our <code class="language-plaintext highlighter-rouge">aggregator</code> crate. 
We can also implement <code class="language-plaintext highlighter-rouge">Summary</code> on <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code> in our <code class="language-plaintext highlighter-rouge">aggregator</code> crate, because the trait <code class="language-plaintext highlighter-rouge">Summary</code> is local to our <code class="language-plaintext highlighter-rouge">aggregator</code> crate.</p>

<p>But we can’t implement external traits on external types. 
For example, we can’t implement the <code class="language-plaintext highlighter-rouge">Display</code> trait on <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code> within our <code class="language-plaintext highlighter-rouge">aggregator</code> crate, because <code class="language-plaintext highlighter-rouge">Display</code> and <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code> are defined in the standard library and aren’t local to our <code class="language-plaintext highlighter-rouge">aggregator</code> crate. 
This restriction is part of a property of programs called <em>coherence</em>, and more specifically the <em>orphan rule</em>, so named because the parent type is not present. 
This rule ensures that other people’s code can’t break your code and vice versa. 
Without the rule, two crates could implement the same trait for the same type, and Rust wouldn’t know which implementation to use.</p>

<h3 id="default-implementations">Default Implementations</h3>
<p>Sometimes it’s useful to have default behavior for some or all of the methods in a trait instead of requiring implementations for all methods on every type. 
Then, as we implement the trait on a particular type, we can keep or override each method’s default behavior.</p>

<p>Listing 10-14 shows how to specify a default string for the <code class="language-plaintext highlighter-rouge">summarize</code> method of the <code class="language-plaintext highlighter-rouge">Summary</code> trait instead of only defining the method signature, as we did in Listing 10-12.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">Summary</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">summarize</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"(Read more...)"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-10-14-definition-of-a-summary-trait-with-a-default-implementation-of-the-summarize-method">Listing 10-14: Definition of a Summary trait with a default implementation of the summarize method</h4>
<p>To use a default implementation to summarize instances of <code class="language-plaintext highlighter-rouge">NewsArticle</code> instead of defining a custom implementation, we specify an empty <code class="language-plaintext highlighter-rouge">impl</code> block with <code class="language-plaintext highlighter-rouge">impl Summary for NewsArticle {}</code>.</p>

<p>Even though we’re no longer defining the <code class="language-plaintext highlighter-rouge">summarize</code> method on <code class="language-plaintext highlighter-rouge">NewsArticle</code> directly, 
we’ve provided a default implementation and specified that <code class="language-plaintext highlighter-rouge">NewsArticle</code> implements the <code class="language-plaintext highlighter-rouge">Summary</code> trait. 
As a result, we can still call the <code class="language-plaintext highlighter-rouge">summarize</code> method on an instance of <code class="language-plaintext highlighter-rouge">NewsArticle</code>, like this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">article</span> <span class="o">=</span> <span class="n">NewsArticle</span> <span class="p">{</span>
    <span class="n">headline</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Penguins win the Stanley Cup Championship!"</span><span class="p">),</span>
    <span class="n">location</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Pittsburgh, PA, USA"</span><span class="p">),</span>
    <span class="n">author</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Iceburgh"</span><span class="p">),</span>
    <span class="n">content</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"The Pittsburgh Penguins once again are the best
    hockey team in the NHL."</span><span class="p">),</span>
<span class="p">};</span>

<span class="nd">println!</span><span class="p">(</span><span class="s">"New article available! {}"</span><span class="p">,</span> <span class="n">article</span><span class="nf">.summarize</span><span class="p">());</span>
</code></pre></div></div>
<p>This code prints <code class="language-plaintext highlighter-rouge">New article available! (Read more...)</code>.</p>

<p>Creating a default implementation for <code class="language-plaintext highlighter-rouge">summarize</code> doesn’t require us to change anything about the implementation of <code class="language-plaintext highlighter-rouge">Summary</code> on <code class="language-plaintext highlighter-rouge">Tweet</code> in Listing 10-13. 
The reason is that the syntax for overriding a default implementation is the same as the syntax for implementing a trait method that doesn’t have a default implementation.</p>

<p>Default implementations can call other methods in the same trait, even if those other methods don’t have a default implementation. 
In this way, a trait can provide a lot of useful functionality and only require implementors to specify a small part of it. 
For example, we could define the <code class="language-plaintext highlighter-rouge">Summary</code> trait to have a <code class="language-plaintext highlighter-rouge">summarize_author</code> method whose implementation is required, and then define a <code class="language-plaintext highlighter-rouge">summarize</code> method that has a default implementation that calls the <code class="language-plaintext highlighter-rouge">summarize_author</code> method:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">Summary</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">summarize_author</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">summarize</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"(Read more from {}...)"</span><span class="p">,</span> <span class="k">self</span><span class="nf">.summarize_author</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>To use this version of <code class="language-plaintext highlighter-rouge">Summary</code>, we only need to define <code class="language-plaintext highlighter-rouge">summarize_author</code> when we implement the trait on a type:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">Summary</span> <span class="k">for</span> <span class="n">Tweet</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">summarize_author</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"@{}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.username</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>After we define <code class="language-plaintext highlighter-rouge">summarize_author</code>, we can call <code class="language-plaintext highlighter-rouge">summarize</code> on instances of the <code class="language-plaintext highlighter-rouge">Tweet</code> struct, and the default implementation of <code class="language-plaintext highlighter-rouge">summarize</code> will call the definition of <code class="language-plaintext highlighter-rouge">summarize_author</code> that we’ve provided. 
Because we’ve implemented <code class="language-plaintext highlighter-rouge">summarize_author</code>, the <code class="language-plaintext highlighter-rouge">Summary</code> trait has given us the behavior of the <code class="language-plaintext highlighter-rouge">summarize</code> method without requiring us to write any more code.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">tweet</span> <span class="o">=</span> <span class="n">Tweet</span> <span class="p">{</span>
    <span class="n">username</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"horse_ebooks"</span><span class="p">),</span>
    <span class="n">content</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"of course, as you probably already know, people"</span><span class="p">),</span>
    <span class="n">reply</span><span class="p">:</span> <span class="k">false</span><span class="p">,</span>
    <span class="n">retweet</span><span class="p">:</span> <span class="k">false</span><span class="p">,</span>
<span class="p">};</span>

<span class="nd">println!</span><span class="p">(</span><span class="s">"1 new tweet: {}"</span><span class="p">,</span> <span class="n">tweet</span><span class="nf">.summarize</span><span class="p">());</span>
</code></pre></div></div>
<p>This code prints <code class="language-plaintext highlighter-rouge">1 new tweet: (Read more from @horse_ebooks...)</code>.
Note that it isn’t possible to call the default implementation from an overriding implementation of that same method.</p>

<h3 id="traits-as-parameters">Traits as Parameters</h3>
<p>Now that you know how to define and implement traits, we can explore how to use traits to define functions that accept many different types.</p>

<p>For example, in Listing 10-13, we implemented the <code class="language-plaintext highlighter-rouge">Summary</code> trait on the <code class="language-plaintext highlighter-rouge">NewsArticle</code> and <code class="language-plaintext highlighter-rouge">Tweet</code> types. 
We can define a <code class="language-plaintext highlighter-rouge">notify</code> function that calls the <code class="language-plaintext highlighter-rouge">summarize</code> method on its <code class="language-plaintext highlighter-rouge">item</code> parameter, which is of some type that implements the <code class="language-plaintext highlighter-rouge">Summary</code> trait. 
To do this, we can use the <code class="language-plaintext highlighter-rouge">impl Trait</code> syntax, like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">notify</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Summary</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Breaking news! {}"</span><span class="p">,</span> <span class="n">item</span><span class="nf">.summarize</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Instead of a concrete type for the <code class="language-plaintext highlighter-rouge">item</code> parameter, we specify the <code class="language-plaintext highlighter-rouge">impl</code> keyword and the trait name. 
This parameter accepts any type that implements the specified trait. 
In the body of <code class="language-plaintext highlighter-rouge">notify</code>, we can call any methods on <code class="language-plaintext highlighter-rouge">item</code> that come from the <code class="language-plaintext highlighter-rouge">Summary</code> trait, such as <code class="language-plaintext highlighter-rouge">summarize</code>. 
We can call <code class="language-plaintext highlighter-rouge">notify</code> and pass in any instance of <code class="language-plaintext highlighter-rouge">NewsArticle</code> or <code class="language-plaintext highlighter-rouge">Tweet</code>. 
Code that calls the function with any other type, such as a <code class="language-plaintext highlighter-rouge">String</code> or an <code class="language-plaintext highlighter-rouge">i32</code>, won’t compile because those types don’t implement <code class="language-plaintext highlighter-rouge">Summary</code>.</p>

<h3 id="trait-bound-syntax">Trait Bound Syntax</h3>
<p>The <code class="language-plaintext highlighter-rouge">impl Trait</code> syntax works for straightforward cases but is actually syntax sugar for a longer form, which is called a <strong>trait bound</strong>; it looks like this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="n">notify</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Summary</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Breaking news! {}"</span><span class="p">,</span> <span class="n">item</span><span class="nf">.summarize</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This longer form is equivalent to the example in the previous section but is more verbose. 
We place trait bounds with the declaration of the generic type parameter after a colon and inside angle brackets.</p>

<p>The <code class="language-plaintext highlighter-rouge">impl Trait</code> syntax is convenient and makes for more concise code in simple cases. 
The trait bound syntax can express more complexity in other cases. 
For example, we can have two parameters that implement <code class="language-plaintext highlighter-rouge">Summary</code>. Using the <code class="language-plaintext highlighter-rouge">impl Trait</code> syntax looks like this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">notify</span><span class="p">(</span><span class="n">item1</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Summary</span><span class="p">,</span> <span class="n">item2</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Summary</span><span class="p">)</span> <span class="p">{</span>
</code></pre></div></div>
<p>If we wanted this function to allow <code class="language-plaintext highlighter-rouge">item1</code> and <code class="language-plaintext highlighter-rouge">item2</code> to have different types, using <code class="language-plaintext highlighter-rouge">impl Trait</code> would be appropriate (as long as both types implement <code class="language-plaintext highlighter-rouge">Summary</code>). 
If we wanted to force both parameters to have the same type, that’s only possible to express using a trait bound, like this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="n">notify</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Summary</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item1</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">item2</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
</code></pre></div></div>
<p>The generic type <code class="language-plaintext highlighter-rouge">T</code> specified as the type of the <code class="language-plaintext highlighter-rouge">item1</code> and <code class="language-plaintext highlighter-rouge">item2</code> parameters constrains the function such that the concrete type of the value passed as an argument for <code class="language-plaintext highlighter-rouge">item1</code> and <code class="language-plaintext highlighter-rouge">item2</code> must be the same.</p>

<h3 id="specifying-multiple-trait-bounds-with-the--syntax">Specifying Multiple Trait Bounds with the + Syntax</h3>
<p>We can also specify more than one trait bound. 
Say we wanted <code class="language-plaintext highlighter-rouge">notify</code> to use display formatting on <code class="language-plaintext highlighter-rouge">item</code> as well as the <code class="language-plaintext highlighter-rouge">summarize</code> method: 
we specify in the <code class="language-plaintext highlighter-rouge">notify</code> definition that <code class="language-plaintext highlighter-rouge">item</code> must implement both <code class="language-plaintext highlighter-rouge">Display</code> and <code class="language-plaintext highlighter-rouge">Summary</code>. 
We can do so using the <code class="language-plaintext highlighter-rouge">+</code> syntax:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">notify</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Summary</span> <span class="o">+</span> <span class="n">Display</span><span class="p">)</span> <span class="p">{</span>
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">+</code> syntax is also valid with <code class="language-plaintext highlighter-rouge">trait bounds</code> on generic types:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="n">notify</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Summary</span> <span class="o">+</span> <span class="n">Display</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
</code></pre></div></div>
<p>With the two trait bounds specified, the body of <code class="language-plaintext highlighter-rouge">notify</code> can call <code class="language-plaintext highlighter-rouge">summarize</code> and use <code class="language-plaintext highlighter-rouge">{}</code> to format item.</p>

<h3 id="clearer-trait-bounds-with-where-clauses">Clearer Trait Bounds with where Clauses</h3>
<p>Using too many trait bounds has its downsides. 
Each generic has its own trait bounds, so functions with multiple generic type parameters can contain lots of trait bound information between the function’s name and its parameter list, making the function signature hard to read. 
For this reason, Rust has alternate syntax for specifying trait bounds inside a where clause after the function signature. 
So instead of writing this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">some_function</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Display</span> <span class="o">+</span> <span class="n">Clone</span><span class="p">,</span> <span class="n">U</span><span class="p">:</span> <span class="n">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">U</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
</code></pre></div></div>
<p>we can use a where clause, like this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">some_function</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">U</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span>
    <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">Display</span> <span class="o">+</span> <span class="n">Clone</span><span class="p">,</span>
          <span class="n">U</span><span class="p">:</span> <span class="n">Clone</span> <span class="o">+</span> <span class="n">Debug</span>
<span class="p">{</span>
</code></pre></div></div>
<p>This function’s signature is less cluttered: the function name, parameter list, and return type are close together, similar to a function without lots of trait bounds.</p>

<h3 id="returning-types-that-implement-traits">Returning Types that Implement Traits</h3>
<p>We can also use the <code class="language-plaintext highlighter-rouge">impl Trait</code> syntax in the return position to return a value of some type that implements a trait, as shown here:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">returns_summarizable</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="n">Summary</span> <span class="p">{</span>
    <span class="n">Tweet</span> <span class="p">{</span>
        <span class="n">username</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"horse_ebooks"</span><span class="p">),</span>
        <span class="n">content</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"of course, as you probably already know, people"</span><span class="p">),</span>
        <span class="n">reply</span><span class="p">:</span> <span class="k">false</span><span class="p">,</span>
        <span class="n">retweet</span><span class="p">:</span> <span class="k">false</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>By using <code class="language-plaintext highlighter-rouge">impl Summary</code> for the return type, we specify that the <code class="language-plaintext highlighter-rouge">returns_summarizable</code> function returns some type that implements the <code class="language-plaintext highlighter-rouge">Summary</code> trait without naming the concrete type. 
In this case, <code class="language-plaintext highlighter-rouge">returns_summarizable</code> returns a <code class="language-plaintext highlighter-rouge">Tweet</code>, but the code calling this function doesn’t know that.</p>

<p>The ability to return a type that is only specified by the trait it implements is especially useful in the context of closures and iterators, which we cover in Chapter 13. 
Closures and iterators create types that only the compiler knows or types that are very long to specify. 
The <code class="language-plaintext highlighter-rouge">impl Trait</code> syntax lets you concisely specify that a function returns some type that implements the <code class="language-plaintext highlighter-rouge">Iterator</code> trait without needing to write out a very long type.</p>

<p>However, you can only use <code class="language-plaintext highlighter-rouge">impl Trait</code> if you’re returning a single type. 
For example, this code that returns either a <code class="language-plaintext highlighter-rouge">NewsArticle</code> or a <code class="language-plaintext highlighter-rouge">Tweet</code> with the return type specified as <code class="language-plaintext highlighter-rouge">impl Summary</code> wouldn’t work:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">returns_summarizable</span><span class="p">(</span><span class="n">switch</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="n">Summary</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">switch</span> <span class="p">{</span>
        <span class="n">NewsArticle</span> <span class="p">{</span>
            <span class="n">headline</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Penguins win the Stanley Cup Championship!"</span><span class="p">),</span>
            <span class="n">location</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Pittsburgh, PA, USA"</span><span class="p">),</span>
            <span class="n">author</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Iceburgh"</span><span class="p">),</span>
            <span class="n">content</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"The Pittsburgh Penguins once again are the best
            hockey team in the NHL."</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">Tweet</span> <span class="p">{</span>
            <span class="n">username</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"horse_ebooks"</span><span class="p">),</span>
            <span class="n">content</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"of course, as you probably already know, people"</span><span class="p">),</span>
            <span class="n">reply</span><span class="p">:</span> <span class="k">false</span><span class="p">,</span>
            <span class="n">retweet</span><span class="p">:</span> <span class="k">false</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Returning either a <code class="language-plaintext highlighter-rouge">NewsArticle</code> or a <code class="language-plaintext highlighter-rouge">Tweet</code> isn’t allowed due to restrictions around how the impl Trait syntax is implemented in the compiler. 
We’ll cover how to write a function with this behavior in the “Using Trait Objects That Allow for Values of Different Types” section of Chapter 17.</p>

<h3 id="fixing-the-largest-function-with-trait-bounds">Fixing the largest Function with Trait Bounds</h3>
<p>Now that you know how to specify the behavior you want to use using the generic type parameter’s bounds, let’s return to Listing 10-5 to fix the definition of the largest function that uses a generic type parameter! 
Last time we tried to run that code, we received this error:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">error</span><span class="p">[</span><span class="n">E0369</span><span class="p">]:</span> <span class="n">binary</span> <span class="n">operation</span> <span class="err">`</span><span class="o">&gt;</span><span class="err">`</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">applied</span> <span class="n">to</span> <span class="k">type</span> <span class="err">`</span><span class="n">T</span><span class="err">`</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span><span class="mi">12</span>
  <span class="p">|</span>
<span class="mi">5</span> <span class="p">|</span>         <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="n">largest</span> <span class="p">{</span>
  <span class="p">|</span>            <span class="o">^^^^^^^^^^^^^^</span>
  <span class="p">|</span>
  <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">an</span> <span class="n">implementation</span> <span class="n">of</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="n">PartialOrd</span><span class="err">`</span> <span class="n">might</span> <span class="n">be</span> <span class="n">missing</span> <span class="k">for</span> <span class="err">`</span><span class="n">T</span><span class="err">`</span>
</code></pre></div></div>
<p>In the body of <code class="language-plaintext highlighter-rouge">largest</code> we wanted to compare two values of type <code class="language-plaintext highlighter-rouge">T</code> using the greater than (<code class="language-plaintext highlighter-rouge">&gt;</code>) operator. 
Because that operator is defined as a default method on the standard <code class="language-plaintext highlighter-rouge">library trait std::cmp::PartialOrd</code>, we need to specify <code class="language-plaintext highlighter-rouge">PartialOrd</code> in the trait bounds for <code class="language-plaintext highlighter-rouge">T</code> so the <code class="language-plaintext highlighter-rouge">largest</code> function can work on slices of any type that we can compare. 
We don’t need to bring <code class="language-plaintext highlighter-rouge">PartialOrd</code> into scope because it’s in the prelude. 
Change the signature of largest to look like this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">largest</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">PartialOrd</span><span class="o">&gt;</span><span class="p">(</span><span class="n">list</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
</code></pre></div></div>
<p>This time when we compile the code, we get a different set of errors:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">error</span><span class="p">[</span><span class="n">E0508</span><span class="p">]:</span> <span class="n">cannot</span> <span class="k">move</span> <span class="n">out</span> <span class="n">of</span> <span class="k">type</span> <span class="err">`</span><span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="err">`</span><span class="p">,</span> <span class="n">a</span> <span class="n">non</span><span class="o">-</span><span class="k">copy</span> <span class="n">slice</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">23</span>
  <span class="p">|</span>
<span class="mi">2</span> <span class="p">|</span>     <span class="k">let</span> <span class="k">mut</span> <span class="n">largest</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="p">|</span>                       <span class="o">^^^^^^^</span>
  <span class="p">|</span>                       <span class="p">|</span>
  <span class="p">|</span>                       <span class="n">cannot</span> <span class="k">move</span> <span class="n">out</span> <span class="n">of</span> <span class="n">here</span>
  <span class="p">|</span>                       <span class="n">help</span><span class="p">:</span> <span class="n">consider</span> <span class="n">using</span> <span class="n">a</span> <span class="n">reference</span> <span class="n">instead</span><span class="p">:</span> <span class="err">`</span><span class="o">&amp;</span><span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="err">`</span>

<span class="n">error</span><span class="p">[</span><span class="n">E0507</span><span class="p">]:</span> <span class="n">cannot</span> <span class="k">move</span> <span class="n">out</span> <span class="n">of</span> <span class="n">borrowed</span> <span class="n">content</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">9</span>
  <span class="p">|</span>
<span class="mi">4</span> <span class="p">|</span>     <span class="k">for</span> <span class="o">&amp;</span><span class="n">item</span> <span class="n">in</span> <span class="n">list</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">|</span>         <span class="o">^----</span>
  <span class="p">|</span>         <span class="p">||</span>
  <span class="p">|</span>         <span class="p">|</span><span class="n">hint</span><span class="p">:</span> <span class="n">to</span> <span class="n">prevent</span> <span class="k">move</span><span class="p">,</span> <span class="k">use</span> <span class="err">`</span><span class="k">ref</span> <span class="n">item</span><span class="err">`</span> <span class="n">or</span> <span class="err">`</span><span class="k">ref</span> <span class="k">mut</span> <span class="n">item</span><span class="err">`</span>
  <span class="p">|</span>         <span class="n">cannot</span> <span class="k">move</span> <span class="n">out</span> <span class="n">of</span> <span class="n">borrowed</span> <span class="n">content</span>
</code></pre></div></div>
<p>The key line in this error is <code class="language-plaintext highlighter-rouge">cannot move out of type [T], a non-copy slice</code>. 
With our non-generic versions of the largest function, we were only trying to find the largest <code class="language-plaintext highlighter-rouge">i32</code> or <code class="language-plaintext highlighter-rouge">char</code>. 
As discussed in the “Stack-Only Data: Copy” section in Chapter 4, types like <code class="language-plaintext highlighter-rouge">i32</code> and <code class="language-plaintext highlighter-rouge">char</code> that have a known size can be stored on the stack, so they implement the <code class="language-plaintext highlighter-rouge">Copy</code> trait. 
But when we made the largest function generic, it became possible for the <code class="language-plaintext highlighter-rouge">list</code> parameter to have types in it that don’t implement the <code class="language-plaintext highlighter-rouge">Copy</code> trait. 
Consequently, we wouldn’t be able to move the value out of <code class="language-plaintext highlighter-rouge">list[0]</code> and into the <code class="language-plaintext highlighter-rouge">largest</code> variable, resulting in this error.</p>

<p>To call this code with only those types that implement the <code class="language-plaintext highlighter-rouge">Copy</code> trait, we can add <code class="language-plaintext highlighter-rouge">Copy</code> to the trait bounds of <code class="language-plaintext highlighter-rouge">T</code>! 
Listing 10-15 shows the complete code of a generic largest function that will compile as long as the types of the values in the slice that we pass into the function implement the <code class="language-plaintext highlighter-rouge">PartialOrd</code> and <code class="language-plaintext highlighter-rouge">Copy</code> traits, like <code class="language-plaintext highlighter-rouge">i32</code> and <code class="language-plaintext highlighter-rouge">char</code> do.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">largest</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">PartialOrd</span> <span class="o">+</span> <span class="nb">Copy</span><span class="o">&gt;</span><span class="p">(</span><span class="n">list</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">largest</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">for</span> <span class="o">&amp;</span><span class="n">item</span> <span class="n">in</span> <span class="n">list</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="n">largest</span> <span class="p">{</span>
            <span class="n">largest</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">largest</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">number_list</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">34</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">65</span><span class="p">];</span>

    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">largest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">number_list</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"The largest number is {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">char_list</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="sc">'y'</span><span class="p">,</span> <span class="sc">'m'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'q'</span><span class="p">];</span>

    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">largest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">char_list</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"The largest char is {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-10-15-a-working-definition-of-the-largest-function-that-works-on-any-generic-type-that-implements-the-partialord-and-copy-traits">Listing 10-15: A working definition of the largest function that works on any generic type that implements the PartialOrd and Copy traits</h4>

<p>If we don’t want to restrict the <code class="language-plaintext highlighter-rouge">largest</code> function to the types that implement the <code class="language-plaintext highlighter-rouge">Copy</code> trait, we could specify that <code class="language-plaintext highlighter-rouge">T</code> has the trait bound <code class="language-plaintext highlighter-rouge">Clone</code> instead of <code class="language-plaintext highlighter-rouge">Copy</code>. 
Then we could clone each value in the slice when we want the <code class="language-plaintext highlighter-rouge">largest</code> function to have ownership. 
Using the <code class="language-plaintext highlighter-rouge">clone</code> function means we’re potentially making more heap allocations in the case of types that own heap data like <code class="language-plaintext highlighter-rouge">String</code>, and heap allocations can be slow if we’re working with large amounts of data.</p>

<p>Another way we could implement <code class="language-plaintext highlighter-rouge">largest</code> is for the function to return a reference to a <code class="language-plaintext highlighter-rouge">T</code> value in the slice. 
If we change the return type to <code class="language-plaintext highlighter-rouge">&amp;T</code> instead of <code class="language-plaintext highlighter-rouge">T</code>, thereby changing the body of the function to return a reference, we wouldn’t need the <code class="language-plaintext highlighter-rouge">Clone</code> or <code class="language-plaintext highlighter-rouge">Copy</code> trait bounds and we could avoid heap allocations. 
Try implementing these alternate solutions on your own!</p>

<h3 id="using-trait-bounds-to-conditionally-implement-methods">Using Trait Bounds to Conditionally Implement Methods</h3>
<p>By using a trait bound with an <code class="language-plaintext highlighter-rouge">impl</code> block that uses generic type parameters, we can implement methods conditionally for types that implement the specified traits. 
For example, the type <code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code> in Listing 10-16 always implements the <code class="language-plaintext highlighter-rouge">new</code> function. 
But <code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code> only implements the <code class="language-plaintext highlighter-rouge">cmp_display</code> method if its inner type <code class="language-plaintext highlighter-rouge">T</code> implements the <code class="language-plaintext highlighter-rouge">PartialOrd</code> trait that enables comparison <em>and</em> the <code class="language-plaintext highlighter-rouge">Display</code> trait that enables printing.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#![allow(unused_variables)]</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">Pair</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
      <span class="n">y</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
  <span class="p">}</span>

  <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Pair</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
          <span class="n">Self</span> <span class="p">{</span>
              <span class="n">x</span><span class="p">,</span>
              <span class="n">y</span><span class="p">,</span>
          <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Display</span> <span class="o">+</span> <span class="n">PartialOrd</span><span class="o">&gt;</span> <span class="n">Pair</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="k">fn</span> <span class="nf">cmp_display</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="k">self</span><span class="py">.x</span> <span class="o">&gt;=</span> <span class="k">self</span><span class="py">.y</span> <span class="p">{</span>
              <span class="nd">println!</span><span class="p">(</span><span class="s">"The largest member is x = {}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.x</span><span class="p">);</span>
          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
              <span class="nd">println!</span><span class="p">(</span><span class="s">"The largest member is y = {}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.y</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-10-16-conditionally-implement-methods-on-a-generic-type-depending-on-trait-bounds">Listing 10-16: Conditionally implement methods on a generic type depending on trait bounds</h4>
<p>We can also conditionally implement a trait for any type that implements another trait. 
Implementations of a trait on any type that satisfies the trait bounds are called <em>blanket implementations</em> and are extensively used in the Rust standard library. 
For example, the standard library implements the <code class="language-plaintext highlighter-rouge">ToString</code> trait on any type that implements the <code class="language-plaintext highlighter-rouge">Display</code> trait. 
The <code class="language-plaintext highlighter-rouge">impl</code> block in the standard library looks similar to this code:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Display</span><span class="o">&gt;</span> <span class="n">ToString</span> <span class="k">for</span> <span class="n">T</span> <span class="p">{</span>
    <span class="c">// --snip--</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Because the standard library has this blanket implementation, we can call the <code class="language-plaintext highlighter-rouge">to_string</code> method defined by the <code class="language-plaintext highlighter-rouge">ToString</code> trait on any type that implements the <code class="language-plaintext highlighter-rouge">Display</code> trait. 
For example, we can turn integers into their corresponding <code class="language-plaintext highlighter-rouge">String</code> values like this because integers implement <code class="language-plaintext highlighter-rouge">Display</code>:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">3</span><span class="nf">.to_string</span><span class="p">();</span>
</code></pre></div></div>
<p>Blanket implementations appear in the documentation for the trait in the “Implementors” section.</p>

<p>Traits and trait bounds let us write code that uses generic type parameters to reduce duplication but also specify to the compiler that we want the generic type to have particular behavior. 
The compiler can then use the trait bound information to check that all the concrete types used with our code provide the correct behavior. 
In dynamically typed languages, we would get an error at runtime if we called a method on a type which didn’t implement the type which defines the method. 
But Rust moves these errors to compile time so we’re forced to fix the problems before our code is even able to run. 
Additionally, we don’t have to write code that checks for behavior at runtime because we’ve already checked at compile time. 
Doing so improves performance without having to give up the flexibility of generics.</p>

<p>Another kind of generic that we’ve already been using is called <em>lifetimes</em>. 
Rather than ensuring that a type has the behavior we want, lifetimes ensure that references are valid as long as we need them to be. 
Let’s look at how lifetimes do that.</p>

<h2 id="validating-references-with-lifetimes">Validating References with Lifetimes</h2>
<p>One detail we didn’t discuss in the “References and Borrowing” section in Chapter 4 is that every reference in Rust has a <strong>lifetime</strong>, which is the scope for which that reference is valid. 
Most of the time, lifetimes are implicit and inferred, just like most of the time, types are inferred. 
We must annotate types when multiple types are possible. 
In a similar way, we must annotate lifetimes when the lifetimes of references could be related in a few different ways. 
Rust requires us to annotate the relationships using generic lifetime parameters to ensure the actual references used at runtime will definitely be valid.</p>

<p>The concept of lifetimes is somewhat different from tools in other programming languages, arguably making lifetimes Rust’s most <em>distinctive</em> feature. 
Although we won’t cover lifetimes in their entirety in this chapter, we’ll discuss common ways you might encounter lifetime syntax so you can become familiar with the concepts.</p>

<h3 id="preventing-dangling-references-with-lifetimes">Preventing Dangling References with Lifetimes</h3>
<p>The main aim of lifetimes is to prevent dangling references, which cause a program to reference data other than the data it’s intended to reference. 
Consider the program in Listing 10-17, which has an outer scope and an inner scope.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="k">let</span> <span class="n">r</span><span class="p">;</span>

    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"r: {}"</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-10-17-an-attempt-to-use-a-reference-whose-value-has-gone-out-of-scope">Listing 10-17: An attempt to use a reference whose value has gone out of scope</h4>

<p class="notice--info"><strong>Note</strong>: The examples in Listings 10-17, 10-18, and 10-24 declare variables without giving them an initial value, so the variable name exists in the outer scope. At first glance, this might appear to be in conflict with Rust’s having no null values. However, if we try to use a variable before giving it a value, we’ll get a compile-time error, which shows that Rust indeed does not allow null values.</p>

<p>The outer scope declares a variable named <code class="language-plaintext highlighter-rouge">r</code> with no initial value, and the inner scope declares a variable named <code class="language-plaintext highlighter-rouge">x</code> with the initial value of 5. 
Inside the inner scope, we attempt to set the value of <code class="language-plaintext highlighter-rouge">r</code> as a reference to <code class="language-plaintext highlighter-rouge">x</code>. 
Then the inner scope ends, and we attempt to print the value in <code class="language-plaintext highlighter-rouge">r</code>. 
This code won’t compile because the value <code class="language-plaintext highlighter-rouge">r</code> is referring to has gone out of scope before we try to use it. 
Here is the error message:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">error</span><span class="p">[</span><span class="n">E0597</span><span class="p">]:</span> <span class="err">`</span><span class="n">x</span><span class="err">`</span> <span class="n">does</span> <span class="n">not</span> <span class="n">live</span> <span class="n">long</span> <span class="n">enough</span>
  <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">7</span><span class="p">:</span><span class="mi">5</span>
   <span class="p">|</span>
<span class="mi">6</span>  <span class="p">|</span>         <span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
   <span class="p">|</span>              <span class="o">-</span> <span class="n">borrow</span> <span class="n">occurs</span> <span class="n">here</span>
<span class="mi">7</span>  <span class="p">|</span>     <span class="p">}</span>
   <span class="p">|</span>     <span class="o">^</span> <span class="err">`</span><span class="n">x</span><span class="err">`</span> <span class="n">dropped</span> <span class="n">here</span> <span class="k">while</span> <span class="n">still</span> <span class="n">borrowed</span>
<span class="o">...</span>
<span class="mi">10</span> <span class="p">|</span> <span class="p">}</span>
   <span class="p">|</span> <span class="o">-</span> <span class="n">borrowed</span> <span class="n">value</span> <span class="n">needs</span> <span class="n">to</span> <span class="n">live</span> <span class="n">until</span> <span class="n">here</span>
</code></pre></div></div>
<p>The variable <code class="language-plaintext highlighter-rouge">x</code> doesn’t “live long enough.” 
The reason is that <code class="language-plaintext highlighter-rouge">x</code> will be out of scope when the inner scope ends on line 7. 
But <code class="language-plaintext highlighter-rouge">r</code> is still valid for the outer scope; because its scope is larger, we say that it “lives longer.” 
If Rust allowed this code to work, <code class="language-plaintext highlighter-rouge">r</code> would be referencing memory that was deallocated when <code class="language-plaintext highlighter-rouge">x</code> went out of scope, and anything we tried to do with <code class="language-plaintext highlighter-rouge">r</code> wouldn’t work correctly. 
So how does Rust determine that this code is invalid? It uses a borrow checker.</p>

<h3 id="the-borrow-checker">The Borrow Checker</h3>
<p>The Rust compiler has a <em>borrow checker</em> that compares scopes to determine whether all borrows are valid. 
Listing 10-18 shows the same code as Listing 10-17 but with annotations showing the lifetimes of the variables.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="k">let</span> <span class="n">r</span><span class="p">;</span>                <span class="c">// ---------+-- 'a</span>
                          <span class="c">//          |</span>
    <span class="p">{</span>                     <span class="c">//          |</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>        <span class="c">// -+-- 'b  |</span>
        <span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>           <span class="c">//  |       |</span>
    <span class="p">}</span>                     <span class="c">// -+       |</span>
                          <span class="c">//          |</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"r: {}"</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span> <span class="c">//          |</span>
<span class="p">}</span>                         <span class="c">// ---------+</span>
</code></pre></div></div>
<h4 id="listing-10-18-annotations-of-the-lifetimes-of-r-and-x-named-a-and-b-respectively">Listing 10-18: Annotations of the lifetimes of r and x, named ‘a and ‘b, respectively</h4>

<p>Here, we’ve annotated the lifetime of <code class="language-plaintext highlighter-rouge">r</code> with <code class="language-plaintext highlighter-rouge">'a</code> and the lifetime of <code class="language-plaintext highlighter-rouge">x</code> with <code class="language-plaintext highlighter-rouge">'b</code>. 
As you can see, the inner <code class="language-plaintext highlighter-rouge">'b</code> block is much smaller than the outer <code class="language-plaintext highlighter-rouge">'a</code> lifetime block. 
At compile time, Rust compares the size of the two lifetimes and sees that <code class="language-plaintext highlighter-rouge">r</code> has a lifetime of <code class="language-plaintext highlighter-rouge">'a</code> but that it refers to memory with a lifetime of <code class="language-plaintext highlighter-rouge">'b</code>. 
The program is rejected because ‘b is shorter than ‘a: the subject of the reference doesn’t live as long as the reference.</p>

<p>Listing 10-19 fixes the code so it doesn’t have a dangling reference and compiles without any errors.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>            <span class="c">// ----------+-- 'b</span>
                          <span class="c">//           |</span>
    <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>           <span class="c">// --+-- 'a  |</span>
                          <span class="c">//   |       |</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"r: {}"</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span> <span class="c">//   |       |</span>
                          <span class="c">// --+       |</span>
<span class="p">}</span>                         <span class="c">// ----------+</span>
</code></pre></div></div>
<h4 id="listing-10-19-a-valid-reference-because-the-data-has-a-longer-lifetime-than-the-reference">Listing 10-19: A valid reference because the data has a longer lifetime than the reference</h4>

<p>Here, <code class="language-plaintext highlighter-rouge">x</code> has the lifetime <code class="language-plaintext highlighter-rouge">'b</code>, which in this case is larger than <code class="language-plaintext highlighter-rouge">'a</code>. This means <code class="language-plaintext highlighter-rouge">r</code> can reference <code class="language-plaintext highlighter-rouge">x</code> because Rust knows that the reference in r will always be valid while <code class="language-plaintext highlighter-rouge">x</code> is valid.</p>

<p>Now that you know where the lifetimes of references are and how Rust analyzes lifetimes to ensure references will always be valid, let’s explore generic lifetimes of parameters and return values in the context of functions.</p>

<h3 id="generic-lifetimes-in-functions">Generic Lifetimes in Functions</h3>
<p>Let’s write a function that returns the longer of two string slices. 
This function will take two string slices and return a string slice. 
After we’ve implemented the longest function, the code in Listing 10-20 should print The longest string is abcd.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">string1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"abcd"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">string2</span> <span class="o">=</span> <span class="s">"xyz"</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">longest</span><span class="p">(</span><span class="n">string1</span><span class="nf">.as_str</span><span class="p">(),</span> <span class="n">string2</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"The longest string is {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-10-20-a-main-function-that-calls-the-longest-function-to-find-the-longer-of-two-string-slices">Listing 10-20: A main function that calls the longest function to find the longer of two string slices</h4>

<p>Note that we want the function to take string slices, which are references, because we don’t want the <code class="language-plaintext highlighter-rouge">longest</code> function to take ownership of its parameters. 
We want to allow the function to accept slices of a <code class="language-plaintext highlighter-rouge">String</code> (the type stored in the variable <code class="language-plaintext highlighter-rouge">string1</code>) as well as string literals (which is what variable <code class="language-plaintext highlighter-rouge">string2</code> contains).</p>

<p>Refer to the “String Slices as Parameters” section in Chapter 4 for more discussion about why the parameters we use in Listing 10-20 are the ones we want.</p>

<p>If we try to implement the <code class="language-plaintext highlighter-rouge">longest</code> function as shown in Listing 10-21, it won’t compile.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">longest</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">x</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">y</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">x</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">y</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-10-21-an-implementation-of-the-longest-function-that-returns-the-longer-of-two-string-slices-but-does-not-yet-compile">Listing 10-21: An implementation of the longest function that returns the longer of two string slices but does not yet compile</h4>

<p>Instead, we get the following error that talks about lifetimes:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">error</span><span class="p">[</span><span class="n">E0106</span><span class="p">]:</span> <span class="n">missing</span> <span class="n">lifetime</span> <span class="n">specifier</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="mi">33</span>
  <span class="p">|</span>
<span class="mi">1</span> <span class="p">|</span> <span class="k">fn</span> <span class="nf">longest</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
  <span class="p">|</span>                                 <span class="o">^</span> <span class="n">expected</span> <span class="n">lifetime</span> <span class="n">parameter</span>
  <span class="p">|</span>
  <span class="o">=</span> <span class="n">help</span><span class="p">:</span> <span class="n">this</span> <span class="n">function</span><span class="nv">'s</span> <span class="k">return</span> <span class="k">type</span> <span class="n">contains</span> <span class="n">a</span> <span class="n">borrowed</span> <span class="n">value</span><span class="p">,</span> <span class="n">but</span> <span class="n">the</span>
<span class="n">signature</span> <span class="n">does</span> <span class="n">not</span> <span class="n">say</span> <span class="n">whether</span> <span class="n">it</span> <span class="n">is</span> <span class="n">borrowed</span> <span class="n">from</span> <span class="err">`</span><span class="n">x</span><span class="err">`</span> <span class="n">or</span> <span class="err">`</span><span class="n">y</span><span class="err">`</span>
</code></pre></div></div>

<p>The help text reveals that the return type needs a generic lifetime parameter on it because Rust can’t tell whether the reference being returned refers to <code class="language-plaintext highlighter-rouge">x</code> or <code class="language-plaintext highlighter-rouge">y</code>. 
Actually, we don’t know either, because the <code class="language-plaintext highlighter-rouge">if</code> block in the body of this function returns a reference to <code class="language-plaintext highlighter-rouge">x</code> and the <code class="language-plaintext highlighter-rouge">else</code> block returns a reference to <code class="language-plaintext highlighter-rouge">y</code>!</p>

<p>When we’re defining this function, we don’t know the concrete values that will be passed into this function, so we don’t know whether the <code class="language-plaintext highlighter-rouge">if</code> case or the <code class="language-plaintext highlighter-rouge">else</code> case will execute. 
We also don’t know the concrete lifetimes of the references that will be passed in, so we can’t look at the scopes as we did in Listings 10-18 and 10-19 to determine whether the reference we return will always be valid. 
The borrow checker can’t determine this either, because it doesn’t know how the lifetimes of <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> relate to the lifetime of the return value. 
To fix this error, we’ll add generic lifetime parameters that define the relationship between the references so the borrow checker can perform its analysis.</p>

<h3 id="lifetime-annotation-syntax">Lifetime Annotation Syntax</h3>
<p>Lifetime annotations don’t change how long any of the references live. 
Just as functions can accept any type when the signature specifies a generic type parameter, functions can accept references with any lifetime by specifying a generic lifetime parameter. 
Lifetime annotations describe the relationships of the lifetimes of multiple references to each other without affecting the lifetimes.</p>

<p><strong>Lifetime annotations</strong> have a slightly unusual syntax: the names of lifetime parameters must start with an apostrophe (<code class="language-plaintext highlighter-rouge">'</code>) and are usually all lowercase and very short, like generic types. 
Most people use the name <code class="language-plaintext highlighter-rouge">'a</code>. 
We place lifetime parameter annotations after the <code class="language-plaintext highlighter-rouge">&amp;</code> of a reference, using a space to separate the annotation from the reference’s type.</p>

<p>Here are some examples: a reference to an <code class="language-plaintext highlighter-rouge">i32</code> without a lifetime parameter, a reference to an <code class="language-plaintext highlighter-rouge">i32</code> that has a lifetime parameter named <code class="language-plaintext highlighter-rouge">'a</code>, and a mutable reference to an <code class="language-plaintext highlighter-rouge">i32</code> that also has the lifetime <code class="language-plaintext highlighter-rouge">'a</code>.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&amp;</span><span class="nb">i32</span>        <span class="c">// a reference</span>
<span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">i32</span>     <span class="c">// a reference with an explicit lifetime</span>
<span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="nb">i32</span> <span class="c">// a mutable reference with an explicit lifetime</span>
</code></pre></div></div>
<p>One lifetime annotation by itself doesn’t have much meaning, because the annotations are meant to tell Rust how generic lifetime parameters of multiple references relate to each other. 
For example, let’s say we have a function with the parameter <code class="language-plaintext highlighter-rouge">first</code> that is a reference to an <code class="language-plaintext highlighter-rouge">i32</code> with lifetime <code class="language-plaintext highlighter-rouge">'a</code>. 
The function also has another parameter named <code class="language-plaintext highlighter-rouge">second</code> that is another reference to an <code class="language-plaintext highlighter-rouge">i32</code> that also has the lifetime <code class="language-plaintext highlighter-rouge">'a</code>. 
The lifetime annotations indicate that the references <code class="language-plaintext highlighter-rouge">first</code> and <code class="language-plaintext highlighter-rouge">second</code> must both live as long as that generic lifetime.</p>

<h3 id="lifetime-annotations-in-function-signatures">Lifetime Annotations in Function Signatures</h3>
<p>Now let’s examine lifetime annotations in the context of the longest function. 
As with generic type parameters, we need to declare generic lifetime parameters inside angle brackets between the function name and the parameter list. 
The constraint we want to express in this signature is that all the references in the parameters and the return value must have the same lifetime. 
We’ll name the lifetime <code class="language-plaintext highlighter-rouge">'a</code> and then add it to each reference, as shown in Listing 10-22.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">longest</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">x</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">y</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">x</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">y</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-10-22-the-longest-function-definition-specifying-that-all-the-references-in-the-signature-must-have-the-same-lifetime-a">Listing 10-22: The longest function definition specifying that all the references in the signature must have the same lifetime ‘a</h4>

<p>This code should compile and produce the result we want when we use it with the <code class="language-plaintext highlighter-rouge">main</code> function in Listing 10-20.</p>

<p>The function signature now tells Rust that for some lifetime <code class="language-plaintext highlighter-rouge">'a</code>, the function takes two parameters, both of which are string slices that live at least as long as lifetime <code class="language-plaintext highlighter-rouge">'a</code>. 
The function signature also tells Rust that the string slice returned from the function will live at least as long as lifetime <code class="language-plaintext highlighter-rouge">'a</code>. 
In practice, it means that the lifetime of the reference returned by the longest function is the same as the smaller of the lifetimes of the references passed in. 
These constraints are what we want Rust to enforce. 
Remember, when we specify the lifetime parameters in this function signature, we’re not changing the lifetimes of any values passed in or returned. 
Rather, we’re specifying that the borrow checker should reject any values that don’t adhere to these constraints. 
Note that the <code class="language-plaintext highlighter-rouge">longest</code> function doesn’t need to know exactly how long <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> will live, only that some scope can be substituted for <code class="language-plaintext highlighter-rouge">'a</code> that will satisfy this signature.</p>

<p>When annotating lifetimes in functions, the annotations go in the function signature, not in the function body. 
Rust can analyze the code within the function without any help. 
However, when a function has references to or from code outside that function, it becomes almost impossible for Rust to figure out the lifetimes of the parameters or return values on its own. 
The lifetimes might be different each time the function is called. This is why we need to annotate the lifetimes manually.</p>

<p>When we pass concrete references to <code class="language-plaintext highlighter-rouge">longest</code>, the concrete lifetime that is substituted for <code class="language-plaintext highlighter-rouge">'a</code> is the part of the scope of <code class="language-plaintext highlighter-rouge">x</code> that overlaps with the scope of <code class="language-plaintext highlighter-rouge">y</code>. 
In other words, the generic lifetime <code class="language-plaintext highlighter-rouge">'a</code> will get the concrete lifetime that is equal to the smaller of the lifetimes of <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code>. 
Because we’ve annotated the returned reference with the same lifetime parameter <code class="language-plaintext highlighter-rouge">'a</code>, the returned reference will also be valid for the length of the smaller of the lifetimes of <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code>.</p>

<p>Let’s look at how the lifetime annotations restrict the <code class="language-plaintext highlighter-rouge">longest</code> function by passing in references that have different concrete lifetimes. Listing 10-23 is a straightforward example.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">string1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"long string is long"</span><span class="p">);</span>

    <span class="p">{</span>
        <span class="k">let</span> <span class="n">string2</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"xyz"</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">longest</span><span class="p">(</span><span class="n">string1</span><span class="nf">.as_str</span><span class="p">(),</span> <span class="n">string2</span><span class="nf">.as_str</span><span class="p">());</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"The longest string is {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-10-23-using-the-longest-function-with-references-to-string-values-that-have-different-concrete-lifetimes">Listing 10-23: Using the longest function with references to String values that have different concrete lifetimes</h4>

<p>In this example, <code class="language-plaintext highlighter-rouge">string1</code> is valid until the end of the outer scope, <code class="language-plaintext highlighter-rouge">string2</code> is valid until the end of the inner scope, and <code class="language-plaintext highlighter-rouge">result</code> references something that is valid until the end of the inner scope. 
Run this code, and you’ll see that the borrow checker approves of this code; it will compile and print <code class="language-plaintext highlighter-rouge">The longest string is long string is long</code>.</p>

<p>Next, let’s try an example that shows that the lifetime of the reference in <code class="language-plaintext highlighter-rouge">result</code> must be the smaller lifetime of the two arguments. 
We’ll move the declaration of the <code class="language-plaintext highlighter-rouge">result</code> variable outside the inner scope but leave the assignment of the value to the <code class="language-plaintext highlighter-rouge">result</code> variable inside the scope with <code class="language-plaintext highlighter-rouge">string2</code>. 
Then we’ll move the <code class="language-plaintext highlighter-rouge">println!</code> that uses <code class="language-plaintext highlighter-rouge">result</code> outside the inner scope, after the inner scope has ended. 
The code in Listing 10-24 will not compile.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">string1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"long string is long"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">string2</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"xyz"</span><span class="p">);</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nf">longest</span><span class="p">(</span><span class="n">string1</span><span class="nf">.as_str</span><span class="p">(),</span> <span class="n">string2</span><span class="nf">.as_str</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"The longest string is {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-10-24-attempting-to-use-result-after-string2-has-gone-out-of-scope">Listing 10-24: Attempting to use result after string2 has gone out of scope</h4>

<p>When we try to compile this code, we’ll get this error:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">error</span><span class="p">[</span><span class="n">E0597</span><span class="p">]:</span> <span class="err">`</span><span class="n">string2</span><span class="err">`</span> <span class="n">does</span> <span class="n">not</span> <span class="n">live</span> <span class="n">long</span> <span class="n">enough</span>
  <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">15</span><span class="p">:</span><span class="mi">5</span>
   <span class="p">|</span>
<span class="mi">14</span> <span class="p">|</span>         <span class="n">result</span> <span class="o">=</span> <span class="nf">longest</span><span class="p">(</span><span class="n">string1</span><span class="nf">.as_str</span><span class="p">(),</span> <span class="n">string2</span><span class="nf">.as_str</span><span class="p">());</span>
   <span class="p">|</span>                                            <span class="o">-------</span> <span class="n">borrow</span> <span class="n">occurs</span> <span class="n">here</span>
<span class="mi">15</span> <span class="p">|</span>     <span class="p">}</span>
   <span class="p">|</span>     <span class="o">^</span> <span class="err">`</span><span class="n">string2</span><span class="err">`</span> <span class="n">dropped</span> <span class="n">here</span> <span class="k">while</span> <span class="n">still</span> <span class="n">borrowed</span>
<span class="mi">16</span> <span class="p">|</span>     <span class="nd">println!</span><span class="p">(</span><span class="s">"The longest string is {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="mi">17</span> <span class="p">|</span> <span class="p">}</span>
   <span class="p">|</span> <span class="o">-</span> <span class="n">borrowed</span> <span class="n">value</span> <span class="n">needs</span> <span class="n">to</span> <span class="n">live</span> <span class="n">until</span> <span class="n">here</span>
</code></pre></div></div>
<p>The error shows that for <code class="language-plaintext highlighter-rouge">result</code> to be valid for the <code class="language-plaintext highlighter-rouge">println!</code> statement, <code class="language-plaintext highlighter-rouge">string2</code> would need to be valid until the end of the outer scope. 
Rust knows this because we annotated the lifetimes of the function parameters and return values using the same lifetime parameter <code class="language-plaintext highlighter-rouge">'a</code>.</p>

<p>As humans, we can look at this code and see that <code class="language-plaintext highlighter-rouge">string1</code> is longer than <code class="language-plaintext highlighter-rouge">string2</code> and therefore <code class="language-plaintext highlighter-rouge">result</code> will contain a reference to <code class="language-plaintext highlighter-rouge">string1</code>. 
Because <code class="language-plaintext highlighter-rouge">string1</code> has not gone out of scope yet, a reference to <code class="language-plaintext highlighter-rouge">string1</code> will still be valid for the <code class="language-plaintext highlighter-rouge">println!</code> statement. 
However, the compiler can’t see that the reference is valid in this case. 
We’ve told Rust that the lifetime of the reference returned by the <code class="language-plaintext highlighter-rouge">longest</code> function is the same as the smaller of the lifetimes of the references passed in. 
Therefore, the borrow checker disallows the code in Listing 10-24 as possibly having an invalid reference.</p>

<p>Try designing more experiments that vary the values and lifetimes of the references passed in to the <code class="language-plaintext highlighter-rouge">longest</code> function and how the returned reference is used. 
Make hypotheses about whether or not your experiments will pass the borrow checker before you compile; then check to see if you’re right!</p>

<h3 id="thinking-in-terms-of-lifetimes">Thinking in Terms of Lifetimes</h3>
<p>The way in which you need to specify lifetime parameters depends on what your function is doing. 
For example, if we changed the implementation of the <code class="language-plaintext highlighter-rouge">longest</code> function to always return the first parameter rather than the longest string slice, we wouldn’t need to specify a lifetime on the <code class="language-plaintext highlighter-rouge">y</code> parameter. 
The following code will compile:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">longest</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span> <span class="p">{</span>
    <span class="n">x</span>
<span class="p">}</span>
</code></pre></div></div>
<p>In this example, we’ve specified a lifetime parameter <code class="language-plaintext highlighter-rouge">'a</code> for the parameter <code class="language-plaintext highlighter-rouge">x</code> and the return type, but not for the parameter <code class="language-plaintext highlighter-rouge">y</code>, because the lifetime of <code class="language-plaintext highlighter-rouge">y</code> does not have any relationship with the lifetime of <code class="language-plaintext highlighter-rouge">x</code> or the return value.</p>

<p>When returning a reference from a function, the lifetime parameter for the return type needs to match the lifetime parameter for one of the parameters. 
If the reference returned does <em>not</em> refer to one of the parameters, it must refer to a value created within this function, which would be a <strong>dangling reference</strong> because the value will go out of scope at the end of the function. 
Consider this attempted implementation of the <code class="language-plaintext highlighter-rouge">longest</code> function that won’t compile:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">longest</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"really long string"</span><span class="p">);</span>
    <span class="n">result</span><span class="nf">.as_str</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Here, even though we’ve specified a lifetime parameter <code class="language-plaintext highlighter-rouge">'a</code> for the return type, this implementation will fail to compile because the return value lifetime is not related to the lifetime of the parameters at all. 
Here is the error message we get:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">error</span><span class="p">[</span><span class="n">E0597</span><span class="p">]:</span> <span class="err">`</span><span class="n">result</span><span class="err">`</span> <span class="n">does</span> <span class="n">not</span> <span class="n">live</span> <span class="n">long</span> <span class="n">enough</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span>
  <span class="p">|</span>
<span class="mi">3</span> <span class="p">|</span>     <span class="n">result</span><span class="nf">.as_str</span><span class="p">()</span>
  <span class="p">|</span>     <span class="o">^^^^^^</span> <span class="n">does</span> <span class="n">not</span> <span class="n">live</span> <span class="n">long</span> <span class="n">enough</span>
<span class="mi">4</span> <span class="p">|</span> <span class="p">}</span>
  <span class="p">|</span> <span class="o">-</span> <span class="n">borrowed</span> <span class="n">value</span> <span class="n">only</span> <span class="n">lives</span> <span class="n">until</span> <span class="n">here</span>
  <span class="p">|</span>
<span class="n">note</span><span class="p">:</span> <span class="n">borrowed</span> <span class="n">value</span> <span class="n">must</span> <span class="n">be</span> <span class="n">valid</span> <span class="k">for</span> <span class="n">the</span> <span class="n">lifetime</span> <span class="nv">'a</span> <span class="k">as</span> <span class="n">defined</span> <span class="n">on</span> <span class="n">the</span>
<span class="n">function</span> <span class="n">body</span> <span class="n">at</span> <span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="o">...</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span>
  <span class="p">|</span>
<span class="mi">1</span> <span class="p">|</span> <span class="o">/</span> <span class="k">fn</span> <span class="n">longest</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span> <span class="p">{</span>
<span class="mi">2</span> <span class="p">|</span> <span class="p">|</span>     <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"really long string"</span><span class="p">);</span>
<span class="mi">3</span> <span class="p">|</span> <span class="p">|</span>     <span class="n">result</span><span class="nf">.as_str</span><span class="p">()</span>
<span class="mi">4</span> <span class="p">|</span> <span class="p">|</span> <span class="p">}</span>
  <span class="p">|</span> <span class="p">|</span><span class="mi">_</span><span class="o">^</span>
</code></pre></div></div>
<p>The problem is that <code class="language-plaintext highlighter-rouge">result</code> goes out of scope and gets cleaned up at the end of the <code class="language-plaintext highlighter-rouge">longest</code> function. 
We’re also trying to return a reference to <code class="language-plaintext highlighter-rouge">result</code> from the function. 
There is no way we can specify lifetime parameters that would change the dangling reference, and Rust won’t let us create a dangling reference. 
In this case, the best fix would be to return an owned data type rather than a reference so the calling function is then responsible for cleaning up the value.</p>

<p>Ultimately, lifetime syntax is about connecting the lifetimes of various parameters and return values of functions. 
Once they’re connected, Rust has enough information to allow memory-safe operations and disallow operations that would create dangling pointers or otherwise violate memory safety.</p>

<h3 id="lifetime-annotations-in-struct-definitions">Lifetime Annotations in Struct Definitions</h3>
<p>So far, we’ve only defined structs to hold owned types. 
It’s possible for structs to hold references, but in that case we would need to add a lifetime annotation on every reference in the struct’s definition. 
Listing 10-25 has a struct named <code class="language-plaintext highlighter-rouge">ImportantExcerpt</code> that holds a string slice.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">ImportantExcerpt</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">part</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">novel</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Call me Ishmael. Some years ago..."</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">first_sentence</span> <span class="o">=</span> <span class="n">novel</span><span class="nf">.split</span><span class="p">(</span><span class="sc">'.'</span><span class="p">)</span>
        <span class="nf">.next</span><span class="p">()</span>
        <span class="nf">.expect</span><span class="p">(</span><span class="s">"Could not find a '.'"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ImportantExcerpt</span> <span class="p">{</span> <span class="n">part</span><span class="p">:</span> <span class="n">first_sentence</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-10-25-a-struct-that-holds-a-reference-so-its-definition-needs-a-lifetime-annotation">Listing 10-25: A struct that holds a reference, so its definition needs a lifetime annotation</h4>

<p>This struct has one field, <code class="language-plaintext highlighter-rouge">part</code>, that holds a string slice, which is a reference. 
As with generic data types, we declare the name of the generic lifetime parameter inside angle brackets after the name of the struct so we can use the lifetime parameter in the body of the struct definition. 
This annotation means an instance of <code class="language-plaintext highlighter-rouge">ImportantExcerpt</code> can’t outlive the reference it holds in its <code class="language-plaintext highlighter-rouge">part</code> field.</p>

<p>The <code class="language-plaintext highlighter-rouge">main</code> function here creates an instance of the <code class="language-plaintext highlighter-rouge">ImportantExcerpt</code> struct that holds a reference to the first sentence of the <code class="language-plaintext highlighter-rouge">String</code> owned by the variable <code class="language-plaintext highlighter-rouge">novel</code>. 
The data in <code class="language-plaintext highlighter-rouge">novel</code> exists before the <code class="language-plaintext highlighter-rouge">ImportantExcerpt</code> instance is created. 
In addition, <code class="language-plaintext highlighter-rouge">novel</code> doesn’t go out of scope until after the <code class="language-plaintext highlighter-rouge">ImportantExcerpt</code> goes out of scope, so the reference in the <code class="language-plaintext highlighter-rouge">ImportantExcerpt</code> instance is valid.</p>

<h3 id="lifetime-elision">Lifetime Elision</h3>
<p>You’ve learned that every reference has a lifetime and that you need to specify lifetime parameters for functions or structs that use references. 
However, in Chapter 4 we had a function in Listing 4-9, which is shown again in Listing 10-26, that compiled without lifetime annotations.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">first_word</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.as_bytes</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">item</span><span class="p">)</span> <span class="n">in</span> <span class="n">bytes</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">item</span> <span class="o">==</span> <span class="n">b</span><span class="sc">' '</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="o">..</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="listing-10-26-a-function-we-defined-in-listing-4-9-that-compiled-without-lifetime-annotations-even-though-the-parameter-and-return-type-are-references">Listing 10-26: A function we defined in Listing 4-9 that compiled without lifetime annotations, even though the parameter and return type are references</h4>

<p>The reason this function compiles without lifetime annotations is historical: in early versions (pre-1.0) of Rust, this code wouldn’t have compiled because every reference needed an explicit lifetime. 
At that time, the function signature would have been written like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">first_word</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span> <span class="p">{</span>
</code></pre></div></div>
<p>After writing a lot of Rust code, the Rust team found that Rust programmers were entering the same lifetime annotations over and over in particular situations. 
These situations were predictable and followed a few deterministic patterns. 
The developers programmed these patterns into the compiler’s code so the borrow checker could infer the lifetimes in these situations and wouldn’t need explicit annotations.</p>

<p>This piece of Rust history is relevant because it’s possible that more deterministic patterns will emerge and be added to the compiler. In the future, even fewer lifetime annotations might be required.</p>

<p>The patterns programmed into Rust’s analysis of references are called the <em>lifetime elision rules</em>. 
These aren’t rules for programmers to follow; they’re a set of particular cases that the compiler will consider, and if your code fits these cases, you don’t need to write the lifetimes explicitly.</p>

<p>The elision rules don’t provide full inference. 
If Rust deterministically applies the rules but there is still ambiguity as to what lifetimes the references have, the compiler won’t guess what the lifetime of the remaining references should be. 
In this case, instead of guessing, the compiler will give you an error that you can resolve by adding the lifetime annotations that specify how the references relate to each other.</p>

<p>Lifetimes on function or method parameters are called <em>input lifetimes</em>, and lifetimes on return values are called <em>output lifetimes</em>.</p>

<p>The compiler uses <strong>three</strong> rules to figure out what lifetimes references have when there aren’t explicit annotations. 
The first rule applies to input lifetimes, and the second and third rules apply to output lifetimes. 
If the compiler gets to the end of the three rules and there are still references for which it can’t figure out lifetimes, the compiler will stop with an error. These rules apply to fn definitions as well as impl blocks.</p>

<p>The <strong>first rule</strong> is that each parameter that is a reference gets its own lifetime parameter. 
In other words, a function with one parameter gets one lifetime parameter: <code class="language-plaintext highlighter-rouge">fn foo&lt;'a&gt;(x: &amp;'a i32)</code>; a function with two parameters gets two separate lifetime parameters: <code class="language-plaintext highlighter-rouge">fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>; and so on.</p>

<p>The <strong>second rule</strong> is if there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters: <code class="language-plaintext highlighter-rouge">fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>

<p>The <strong>third rule</strong> is if there are multiple input lifetime parameters, but one of them is <code class="language-plaintext highlighter-rouge">&amp;self</code> or <code class="language-plaintext highlighter-rouge">&amp;mut self</code> because this is a method, the lifetime of <code class="language-plaintext highlighter-rouge">self</code> is assigned to all output lifetime parameters. 
This third rule makes methods much nicer to read and write because fewer symbols are necessary.</p>

<p>Let’s pretend we’re the compiler. 
We’ll apply these rules to figure out what the lifetimes of the references in the signature of the first_word function in Listing 10-26 are. 
The signature starts without any lifetimes associated with the references:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">first_word</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
</code></pre></div></div>

<p>Then the compiler applies the <strong>first rule</strong>, which specifies that each parameter gets its own lifetime. 
We’ll call it <code class="language-plaintext highlighter-rouge">'a</code> as usual, so now the signature is this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">first_word</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
</code></pre></div></div>

<p>The <strong>second rule</strong> applies because there is exactly one input lifetime. 
The second rule specifies that the lifetime of the one input parameter gets assigned to the output lifetime, so the signature is now this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">first_word</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span> <span class="p">{</span>
</code></pre></div></div>

<p>Now all the references in this function signature have lifetimes, and the compiler can continue its analysis without needing the programmer to annotate the lifetimes in this function signature.</p>

<p>Let’s look at another example, this time using the longest function that had no lifetime parameters when we started working with it in Listing 10-21:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">longest</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
</code></pre></div></div>
<p>Let’s apply the <strong>first rule</strong>: each parameter gets its own lifetime. 
This time we have two parameters instead of one, so we have two lifetimes:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">longest</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="nv">'b</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'b</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
</code></pre></div></div>
<p>You can see that the <strong>second rule</strong> doesn’t apply because there is more than one input lifetime. 
The third rule doesn’t apply either, because longest is a function rather than a method, so none of the parameters are self. 
After working through all <strong>three rules</strong>, we still haven’t figured out what the return type’s lifetime is. 
This is why we got an <strong>error</strong> trying to compile the code in Listing 10-21: the compiler worked through the lifetime elision rules but still couldn’t figure out all the lifetimes of the references in the signature.</p>

<p>Because the third rule really only applies in method signatures, we’ll look at lifetimes in that context next to see why the third rule means we don’t have to annotate lifetimes in method signatures very often.</p>

<h3 id="lifetime-annotations-in-method-definitions">Lifetime Annotations in Method Definitions</h3>
<p>When we implement methods on a struct with lifetimes, we use the same syntax as that of generic type parameters shown in Listing 10-11. 
Where we declare and use the lifetime parameters depends on whether they’re related to the struct fields or the method parameters and return values.</p>

<p>Lifetime names for struct fields always need to be declared after the <code class="language-plaintext highlighter-rouge">impl</code> keyword and then used after the struct’s name, because those lifetimes are part of the struct’s type.</p>

<p>In method signatures inside the <code class="language-plaintext highlighter-rouge">impl</code> block, references might be tied to the lifetime of references in the struct’s fields, or they might be independent. 
In addition, the lifetime elision rules often make it so that lifetime annotations aren’t necessary in method signatures. 
Let’s look at some examples using the struct named <code class="language-plaintext highlighter-rouge">ImportantExcerpt</code> that we defined in Listing 10-25.</p>

<p>First, we’ll use a method named <code class="language-plaintext highlighter-rouge">level</code> whose only parameter is a reference to <code class="language-plaintext highlighter-rouge">self</code> and whose return value is an <code class="language-plaintext highlighter-rouge">i32</code>, which is not a reference to anything:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">ImportantExcerpt</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">level</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
        <span class="mi">3</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The lifetime parameter declaration after <code class="language-plaintext highlighter-rouge">impl</code> and its use after the type name are required, but we’re <strong>not required</strong> to annotate the lifetime of the reference to <code class="language-plaintext highlighter-rouge">self</code> because of the first elision rule.</p>

<p>Here is an example where the third lifetime elision rule applies:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">ImportantExcerpt</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">announce_and_return_part</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">announcement</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Attention please: {}"</span><span class="p">,</span> <span class="n">announcement</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.part</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>There are two input lifetimes, so Rust applies the first lifetime elision rule and gives both <code class="language-plaintext highlighter-rouge">&amp;self</code> and <code class="language-plaintext highlighter-rouge">announcement</code> their own lifetimes. 
Then, because one of the parameters is <code class="language-plaintext highlighter-rouge">&amp;self</code>, the return type gets the lifetime of <code class="language-plaintext highlighter-rouge">&amp;self</code>, and all lifetimes have been accounted for.</p>

<h3 id="the-static-lifetime">The Static Lifetime</h3>
<p>One special lifetime we need to discuss is <code class="language-plaintext highlighter-rouge">'static</code>, which means that this reference can live for the entire duration of the program. 
All string literals have the <code class="language-plaintext highlighter-rouge">'static</code> lifetime, which we can annotate as follows:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'static</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"I have a static lifetime."</span><span class="p">;</span>
</code></pre></div></div>
<p>The text of this string is stored directly in the program’s binary, which is always available. 
Therefore, the lifetime of all string literals is <code class="language-plaintext highlighter-rouge">'static</code>.</p>

<p>You might see suggestions to use the <code class="language-plaintext highlighter-rouge">'static</code> lifetime in error messages. 
But before specifying <code class="language-plaintext highlighter-rouge">'static</code> as the lifetime for a reference, think about whether the reference you have actually lives the entire lifetime of your program or not. 
You might consider whether you want it to live that long, even if it could. 
Most of the time, the problem results from attempting to create a dangling reference or a mismatch of the available lifetimes. 
In such cases, the solution is fixing those problems, not specifying the <code class="language-plaintext highlighter-rouge">'static</code> lifetime.</p>

<h3 id="generic-type-parameters-trait-bounds-and-lifetimes-together">Generic Type Parameters, Trait Bounds, and Lifetimes Together</h3>
<p>Let’s briefly look at the syntax of specifying generic type parameters, trait bounds, and lifetimes all in one function!</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span><span class="p">;</span>

<span class="k">fn</span> <span class="n">longest_with_an_announcement</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="n">ann</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span>
    <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">Display</span>
<span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Announcement! {}"</span><span class="p">,</span> <span class="n">ann</span><span class="p">);</span>
    <span class="k">if</span> <span class="n">x</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">y</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">x</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">y</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This is the <code class="language-plaintext highlighter-rouge">longest</code> function from Listing 10-22 that returns the longer of two string slices. 
But now it has an extra parameter named <code class="language-plaintext highlighter-rouge">ann</code> of the generic type <code class="language-plaintext highlighter-rouge">T</code>, which can be filled in by any type that implements the <code class="language-plaintext highlighter-rouge">Display</code> trait as specified by the <code class="language-plaintext highlighter-rouge">where</code> clause. 
This extra parameter will be printed before the function compares the lengths of the string slices, which is why the <code class="language-plaintext highlighter-rouge">Display</code> trait bound is necessary. 
Because lifetimes are a type of generic, the declarations of the lifetime parameter <code class="language-plaintext highlighter-rouge">'a</code> and the generic type parameter <code class="language-plaintext highlighter-rouge">T</code> go in the same list inside the angle brackets after the function name.</p>

<h2 id="summary">Summary</h2>
<p>We covered a lot in this chapter! Now that you know about generic type parameters, traits and trait bounds, and generic lifetime parameters, you’re ready to write code without repetition that works in many different situations.</p>

<p>Generic type parameters let you apply the code to different types. 
Traits and trait bounds ensure that even though the types are generic, they’ll have the behavior the code needs. 
You learned how to use lifetime annotations to ensure that this flexible code won’t have any dangling references. 
And all of this analysis happens at compile time, which doesn’t affect runtime performance!</p>

        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/#generic" class="page__taxonomy-item" rel="tag">Generic</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#lifetimes" class="page__taxonomy-item" rel="tag">Lifetimes</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#template" class="page__taxonomy-item" rel="tag">Template</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#traits" class="page__taxonomy-item" rel="tag">Traits</a>
    
    </span>
  </p>




  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/categories/#rust-language" class="page__taxonomy-item" rel="tag">RUST Language</a>
    
    </span>
  </p>


        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2020-03-05T00:00:00+00:00">March 5, 2020</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?text=RUST+%3A+10.+Generic+Types%2C+Traits%2C+and+Lifetimes%20https%3A%2F%2Fjjungs-lee.github.io%2F%2Frust%2F10.Generic-Types%2C-Traits%2C-and-Lifetimes" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fjjungs-lee.github.io%2F%2Frust%2F10.Generic-Types%2C-Traits%2C-and-Lifetimes" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fjjungs-lee.github.io%2F%2Frust%2F10.Generic-Types%2C-Traits%2C-and-Lifetimes" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/rust/9.Error-Handling" class="pagination--pager" title="RUST : 9. Error Handling
">Previous</a>
    
    
      <a href="/article/ms-creating-a-new-Rust-like-programming-language/" class="pagination--pager" title="Microsoft: We’re creating a new Rust-like programming language for secure coding
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/Algorithm/Data-structure-List" rel="permalink">Data Structure - LIST
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  Also known as linked list
  The linked list is a data space in which data can be added and deleted whenever necessary, without a space of a fixed size.
  ...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/rust/How-to-check-overflow-and-underflow-in-integer-types" rel="permalink">RUST : How to check overflow and underflow in integer types
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  2 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">What is overflow and underflow?
Overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be repr...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/rust/19.Advanced-Features" rel="permalink">RUST : 19. Advanced Features
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  69 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">Advanced Features
By now, you’ve learned the most commonly used parts of the Rust programming language. 
Before we do one more project in Chapter 20, we’ll l...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/rust/18.Patterns-and-Matching" rel="permalink">RUST : 18. Patterns and Matching
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  38 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">Patterns and Matching
Patterns are a special syntax in Rust for matching against the structure of types, both complex and simple. 
Using patterns in conjunct...</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
      
        
      
        
          <li><a href="https://github.com/jjungs-lee" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
      
        
      
        
      
    

    <li><a href="NONE"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2021 JJungs-lee. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script src="https://kit.fontawesome.com/4eee35f757.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>







  </body>
</html>
