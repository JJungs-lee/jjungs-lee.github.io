<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://jjungs-lee.github.io//feed.xml" rel="self" type="application/atom+xml" /><link href="https://jjungs-lee.github.io//" rel="alternate" type="text/html" /><updated>2023-06-16T17:13:51+00:00</updated><id>https://jjungs-lee.github.io//feed.xml</id><title type="html">Yes! I Take IT</title><subtitle>This is JJung's Website.</subtitle><author><name>JJungs-lee</name></author><entry><title type="html">Rust by Example : 3. Custom Types</title><link href="https://jjungs-lee.github.io//rust/3.Custom-Types" rel="alternate" type="text/html" title="Rust by Example : 3. Custom Types" /><published>2022-03-04T00:00:00+00:00</published><updated>2022-03-04T00:00:00+00:00</updated><id>https://jjungs-lee.github.io//rust/3.Custom%20Types</id><content type="html" xml:base="https://jjungs-lee.github.io//rust/3.Custom-Types"><![CDATA[<p>Rust custom data types are formed mainly through the two keywords:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">struct</code>: define a structure</li>
  <li><code class="language-plaintext highlighter-rouge">enum</code>: define an enumeration</li>
</ul>

<p>Constants can also be created via the <code class="language-plaintext highlighter-rouge">const</code> and <code class="language-plaintext highlighter-rouge">static</code> keywords.</p>

<h2 id="31-structures">3.1 Structures</h2>
<p>There are three types of structures (“structs”) that can be created using the <code class="language-plaintext highlighter-rouge">struct</code> keyword:</p>

<ul>
  <li>Tuple structs, which are, basically, named tuples.</li>
  <li>The classic C structs</li>
  <li>Unit structs, which are field-less, are useful for generics.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Person</span> <span class="p">{</span>
  <span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
  <span class="n">age</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// A unit struct</span>
<span class="k">struct</span> <span class="n">Unit</span><span class="p">;</span>

<span class="c1">// A tuple struct</span>
<span class="k">struct</span> <span class="nf">Pair</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">f32</span><span class="p">);</span>

<span class="c1">// A struct with two fields</span>
<span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
  <span class="n">x</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>
  <span class="n">y</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// Structs can be reused as fields of another struct</span>
<span class="nd">#[allow(dead_code)]</span>
<span class="k">struct</span> <span class="n">Rectangle</span> <span class="p">{</span>
  <span class="c1">// A rectangle can be specified by </span>
  <span class="c1">// where the top left and bottom right corners are in space.</span>
  <span class="n">top_left</span><span class="p">:</span> <span class="n">Point</span><span class="p">,</span>
  <span class="n">bottom_right</span><span class="p">:</span> <span class="n">Point</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Create struct with field init shorthand</span>
  <span class="k">let</span> <span class="n">name</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Peter"</span><span class="p">);</span>
  <span class="k">let</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">peter</span> <span class="o">=</span> <span class="n">Person</span> <span class="p">{</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span> <span class="p">};</span>

  <span class="c1">// Print debug struct</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">peter</span><span class="p">);</span>

  <span class="c1">// Instantiate a `Point`</span>
  <span class="k">let</span> <span class="n">point</span><span class="p">:</span> <span class="n">Point</span> <span class="o">=</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mf">10.3</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">0.4</span> <span class="p">};</span>

  <span class="c1">// Access the fields of the point</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"point coordinates: ({}, {})"</span><span class="p">,</span> <span class="n">point</span><span class="py">.x</span><span class="p">,</span> <span class="n">point</span><span class="py">.y</span><span class="p">);</span>

  <span class="c1">// Make a new point by using struct update syntax </span>
  <span class="c1">// to use the fields of our other one</span>
  <span class="k">let</span> <span class="n">bottom_right</span> <span class="o">=</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mf">5.2</span><span class="p">,</span> <span class="o">..</span><span class="n">point</span> <span class="p">};</span>

  <span class="c1">// `bottom_right.y` will be the same as `point.y` </span>
  <span class="c1">// because we used that field from `point`</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"second point: ({}, {})"</span><span class="p">,</span> <span class="n">bottom_right</span><span class="py">.x</span><span class="p">,</span> <span class="n">bottom_right</span><span class="py">.y</span><span class="p">);</span>

  <span class="c1">// Destructure the point using a `let` binding</span>
  <span class="k">let</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="n">left_edge</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">top_edge</span> <span class="p">}</span> <span class="o">=</span> <span class="n">point</span><span class="p">;</span>

  <span class="k">let</span> <span class="n">_rectangle</span> <span class="o">=</span> <span class="n">Rectangle</span> <span class="p">{</span>
    <span class="c1">// struct instantiation is an expression too</span>
    <span class="n">top_left</span><span class="p">:</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="n">left_edge</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">top_edge</span> <span class="p">},</span>
    <span class="n">bottom_right</span><span class="p">:</span> <span class="n">bottom_right</span><span class="p">,</span>
  <span class="p">};</span>

  <span class="c1">// Instantiate a unit struct</span>
  <span class="k">let</span> <span class="n">_unit</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">;</span>

  <span class="c1">// Instantiate a tuple struct</span>
  <span class="k">let</span> <span class="n">pair</span> <span class="o">=</span> <span class="nf">Pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">);</span>

  <span class="c1">// Access the fields of a tuple struct</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"pair contains {:?} and {:?}"</span><span class="p">,</span> <span class="n">pair</span><span class="na">.0</span><span class="p">,</span> <span class="n">pair</span><span class="na">.1</span><span class="p">);</span>

  <span class="c1">// Destructure a tuple struct</span>
  <span class="k">let</span> <span class="nf">Pair</span><span class="p">(</span><span class="n">integer</span><span class="p">,</span> <span class="n">decimal</span><span class="p">)</span> <span class="o">=</span> <span class="n">pair</span><span class="p">;</span>

  <span class="nd">println!</span><span class="p">(</span><span class="s">"pair contains {:?} and {:?}"</span><span class="p">,</span> <span class="n">integer</span><span class="p">,</span> <span class="n">decimal</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="activity">Activity</h3>
<ol>
  <li>Add a function <code class="language-plaintext highlighter-rouge">rect_area</code> which calculates the area of a <code class="language-plaintext highlighter-rouge">Rectangle</code> 
(try using nested destructuring).</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
  <span class="n">x</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>
  <span class="n">y</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Rectangle</span> <span class="p">{</span>
  <span class="n">top_left</span><span class="p">:</span> <span class="n">Point</span><span class="p">,</span>
  <span class="n">bottom_right</span><span class="p">:</span> <span class="n">Point</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Rectangle</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">rect_area</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">f32</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">Rectangle</span> <span class="p">{</span>
      <span class="n">top_left</span><span class="p">:</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">y1</span> <span class="p">},</span>
      <span class="n">bottom_right</span><span class="p">:</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">y2</span> <span class="p">},</span>
    <span class="p">}</span> <span class="o">=</span> <span class="k">self</span><span class="p">;</span>

    <span class="p">((</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y2</span><span class="p">))</span><span class="nf">.abs</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">rec</span> <span class="o">=</span> <span class="n">Rectangle</span> <span class="p">{</span>
    <span class="n">top_left</span><span class="p">:</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">10.0</span> <span class="p">},</span>
    <span class="n">bottom_right</span><span class="p">:</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">5.0</span> <span class="p">},</span>
  <span class="p">};</span>

  <span class="nd">println!</span><span class="p">(</span><span class="s">"rec area: {}"</span><span class="p">,</span> <span class="n">rec</span><span class="nf">.rect_area</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>
<ol>
  <li>Add a function <code class="language-plaintext highlighter-rouge">square</code> which takes a <code class="language-plaintext highlighter-rouge">Point</code> and a <code class="language-plaintext highlighter-rouge">f32</code> as arguments, 
and returns a Rectangle with its top left corner on the point, 
and a width and height corresponding to the <code class="language-plaintext highlighter-rouge">f32</code>.</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
  <span class="n">x</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>
  <span class="n">y</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Rectangle</span> <span class="p">{</span>
  <span class="n">top_left</span><span class="p">:</span> <span class="n">Point</span><span class="p">,</span>
  <span class="n">bottom_right</span><span class="p">:</span> <span class="n">Point</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">square</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="n">Point</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">f32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Rectangle</span> <span class="p">{</span>
  <span class="n">Rectangle</span> <span class="p">{</span> 
    <span class="n">top_left</span><span class="p">:</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="n">p</span><span class="py">.x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">p</span><span class="py">.y</span> <span class="o">+</span> <span class="n">size</span><span class="p">},</span>
    <span class="n">bottom_right</span> <span class="p">:</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span><span class="n">p</span><span class="py">.x</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">p</span><span class="py">.y</span><span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"square {:?}"</span><span class="p">,</span> <span class="nf">square</span><span class="p">(</span><span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">0.0</span> <span class="p">},</span> <span class="mf">5.0</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="32-enums">3.2 Enums</h2>
<p>The <code class="language-plaintext highlighter-rouge">enum</code> keyword allows the creation of a type which may be one of a few different variants. 
Any variant which is valid as a <code class="language-plaintext highlighter-rouge">struct</code> is also valid as an <code class="language-plaintext highlighter-rouge">enum</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create an `enum` to classify a web event. Note how both</span>
<span class="c1">// names and type information together specify the variant:</span>
<span class="c1">// `PageLoad != PageUnload` and `KeyPress(char) != Paste(String)`.</span>
<span class="c1">// Each is different and independent.</span>
<span class="k">enum</span> <span class="n">WebEvent</span> <span class="p">{</span>
  <span class="c1">// An `enum` may either be `unit-like`,</span>
  <span class="n">PageLoad</span><span class="p">,</span>
  <span class="n">PageUnload</span><span class="p">,</span>
  <span class="c1">// like tuple structs,</span>
  <span class="nf">KeyPress</span><span class="p">(</span><span class="nb">char</span><span class="p">),</span>
  <span class="nf">Paste</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
  <span class="c1">// or c-like structures.</span>
  <span class="n">Click</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="nb">i64</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">i64</span> <span class="p">},</span>
<span class="p">}</span>

<span class="c1">// A function which takes a `WebEvent` enum as an argument and</span>
<span class="c1">// returns nothing.</span>
<span class="k">fn</span> <span class="nf">inspect</span><span class="p">(</span><span class="n">event</span><span class="p">:</span> <span class="n">WebEvent</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">match</span> <span class="n">event</span> <span class="p">{</span>
    <span class="nn">WebEvent</span><span class="p">::</span><span class="n">PageLoad</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"page loaded"</span><span class="p">),</span>
    <span class="nn">WebEvent</span><span class="p">::</span><span class="n">PageUnload</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"page unloaded"</span><span class="p">),</span>
    <span class="c1">// Destructure `c` from inside the `enum`.</span>
    <span class="nn">WebEvent</span><span class="p">::</span><span class="nf">KeyPress</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"pressed '{}'."</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span>
    <span class="nn">WebEvent</span><span class="p">::</span><span class="nf">Paste</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"pasted </span><span class="se">\"</span><span class="s">{}</span><span class="se">\"</span><span class="s">."</span><span class="p">,</span> <span class="n">s</span><span class="p">),</span>
    <span class="c1">// Destructure `Click` into `x` and `y`.</span>
    <span class="nn">WebEvent</span><span class="p">::</span><span class="n">Click</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
      <span class="nd">println!</span><span class="p">(</span><span class="s">"clicked at x={}, y={}."</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="p">},</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">pressed</span> <span class="o">=</span> <span class="nn">WebEvent</span><span class="p">::</span><span class="nf">KeyPress</span><span class="p">(</span><span class="sc">'x'</span><span class="p">);</span>
  <span class="c1">// `to_owned()` creates an owned `String` from a string slice.</span>
  <span class="k">let</span> <span class="n">pasted</span>  <span class="o">=</span> <span class="nn">WebEvent</span><span class="p">::</span><span class="nf">Paste</span><span class="p">(</span><span class="s">"my text"</span><span class="nf">.to_owned</span><span class="p">());</span>
  <span class="k">let</span> <span class="n">click</span>   <span class="o">=</span> <span class="nn">WebEvent</span><span class="p">::</span><span class="n">Click</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">80</span> <span class="p">};</span>
  <span class="k">let</span> <span class="n">load</span>    <span class="o">=</span> <span class="nn">WebEvent</span><span class="p">::</span><span class="n">PageLoad</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">unload</span>  <span class="o">=</span> <span class="nn">WebEvent</span><span class="p">::</span><span class="n">PageUnload</span><span class="p">;</span>

  <span class="nf">inspect</span><span class="p">(</span><span class="n">pressed</span><span class="p">);</span>
  <span class="nf">inspect</span><span class="p">(</span><span class="n">pasted</span><span class="p">);</span>
  <span class="nf">inspect</span><span class="p">(</span><span class="n">click</span><span class="p">);</span>
  <span class="nf">inspect</span><span class="p">(</span><span class="n">load</span><span class="p">);</span>
  <span class="nf">inspect</span><span class="p">(</span><span class="n">unload</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="type-aliases">Type aliases</h3>
<p>If you use a type alias, you can refer to each enum variant via its alias. 
This might be useful if the enum’s name is too long or too generic, and you want to rename it.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">VeryVerboseEnumOfThingsToDoWithNumbers</span> <span class="p">{</span>
  <span class="nb">Add</span><span class="p">,</span>
  <span class="n">Subtract</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// Creates a type alias</span>
<span class="k">type</span> <span class="n">Operations</span> <span class="o">=</span> <span class="n">VeryVerboseEnumOfThingsToDoWithNumbers</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// We can refer to each variant via its alias,</span>
  <span class="c1">// not its long and inconvenient name.</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">Operations</span><span class="p">::</span><span class="nb">Add</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The most common place you’ll see this is in <code class="language-plaintext highlighter-rouge">impl</code> blocks using the <code class="language-plaintext highlighter-rouge">Self</code> alias.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">VeryVerboseEnumOfThingsToDoWithNumbers</span> <span class="p">{</span>
  <span class="nb">Add</span><span class="p">,</span>
  <span class="n">Subtract</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">VeryVerboseEnumOfThingsToDoWithNumbers</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
      <span class="k">Self</span><span class="p">::</span><span class="nb">Add</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span>
      <span class="k">Self</span><span class="p">::</span><span class="n">Subtract</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>To learn more about enums and type aliases, you can read the stabilization report from when this feature was stabilized into Rust.</p>

<h3 id="321-use">3.2.1 use</h3>
<p>The <code class="language-plaintext highlighter-rouge">use</code> declaration can be used so manual scoping isn’t needed:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// An attribute to hide warnings for unused code.</span>
<span class="nd">#![allow(dead_code)]</span>

<span class="k">enum</span> <span class="n">Status</span> <span class="p">{</span>
  <span class="n">Rich</span><span class="p">,</span>
  <span class="n">Poor</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">Work</span> <span class="p">{</span>
  <span class="n">Civilian</span><span class="p">,</span>
  <span class="n">Soldier</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Explicitly `use` each name so they are available without</span>
  <span class="c1">// manual scoping.</span>
  <span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="nn">Status</span><span class="p">::{</span><span class="n">Poor</span><span class="p">,</span> <span class="n">Rich</span><span class="p">};</span>
  <span class="c1">// Automatically `use` each name inside `Work`.</span>
  <span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="nn">Work</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

  <span class="c1">// Equivalent to `Status::Poor`.</span>
  <span class="k">let</span> <span class="n">status</span> <span class="o">=</span> <span class="n">Poor</span><span class="p">;</span>
  <span class="c1">// Equivalent to `Work::Civilian`.</span>
  <span class="k">let</span> <span class="n">work</span> <span class="o">=</span> <span class="n">Civilian</span><span class="p">;</span>

  <span class="k">match</span> <span class="n">status</span> <span class="p">{</span>
    <span class="c1">// Note the lack of scoping because of the explicit `use` above.</span>
    <span class="n">Rich</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"The rich have lots of money!"</span><span class="p">),</span>
    <span class="n">Poor</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"The poor have no money..."</span><span class="p">),</span>
  <span class="p">}</span>

  <span class="k">match</span> <span class="n">work</span> <span class="p">{</span>
    <span class="c1">// Note again the lack of scoping.</span>
    <span class="n">Civilian</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Civilians work!"</span><span class="p">),</span>
    <span class="n">Soldier</span>  <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Soldiers fight!"</span><span class="p">),</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="322-c-like">3.2.2 C-like</h3>
<p><code class="language-plaintext highlighter-rouge">enum</code> can also be used as C-like enums.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// An attribute to hide warnings for unused code.</span>
<span class="nd">#![allow(dead_code)]</span>

<span class="c1">// enum with implicit discriminator (starts at 0)</span>
<span class="k">enum</span> <span class="n">Number</span> <span class="p">{</span>
  <span class="n">Zero</span><span class="p">,</span>
  <span class="n">One</span><span class="p">,</span>
  <span class="n">Two</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// enum with explicit discriminator</span>
<span class="k">enum</span> <span class="n">Color</span> <span class="p">{</span>
  <span class="n">Red</span> <span class="o">=</span> <span class="mi">0xff0000</span><span class="p">,</span>
  <span class="n">Green</span> <span class="o">=</span> <span class="mi">0x00ff00</span><span class="p">,</span>
  <span class="n">Blue</span> <span class="o">=</span> <span class="mi">0x0000ff</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// `enums` can be cast as integers.</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"zero is {}"</span><span class="p">,</span> <span class="nn">Number</span><span class="p">::</span><span class="n">Zero</span> <span class="k">as</span> <span class="nb">i32</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"one is {}"</span><span class="p">,</span> <span class="nn">Number</span><span class="p">::</span><span class="n">One</span> <span class="k">as</span> <span class="nb">i32</span><span class="p">);</span>

  <span class="nd">println!</span><span class="p">(</span><span class="s">"roses are #{:06x}"</span><span class="p">,</span> <span class="nn">Color</span><span class="p">::</span><span class="n">Red</span> <span class="k">as</span> <span class="nb">i32</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"violets are #{:06x}"</span><span class="p">,</span> <span class="nn">Color</span><span class="p">::</span><span class="n">Blue</span> <span class="k">as</span> <span class="nb">i32</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="323-testcase-linked-list">3.2.3 Testcase: linked-list</h3>
<p>A common way to implement a linked-list is via <code class="language-plaintext highlighter-rouge">enums</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="nn">List</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">List</span> <span class="p">{</span>
  <span class="c1">// Cons: Tuple struct that wraps an element and a pointer to the next node</span>
  <span class="nf">Cons</span><span class="p">(</span><span class="nb">u32</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;</span><span class="p">),</span>
  <span class="c1">// Nil: A node that signifies the end of the linked list</span>
  <span class="nb">Nil</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// Methods can be attached to an enum</span>
<span class="k">impl</span> <span class="n">List</span> <span class="p">{</span>
  <span class="c1">// Create an empty list</span>
  <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">List</span> <span class="p">{</span>
    <span class="c1">// `Nil` has type `List`</span>
    <span class="nb">Nil</span>
  <span class="p">}</span>

  <span class="c1">// Consume a list, and return the same list with a new element at its front</span>
  <span class="k">fn</span> <span class="nf">prepend</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">List</span> <span class="p">{</span>
    <span class="c1">// `Cons` also has type List</span>
    <span class="nf">Cons</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="k">self</span><span class="p">))</span>
  <span class="p">}</span>

  <span class="c1">// Return the length of the list</span>
  <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="c1">// `self` has to be matched, because the behavior of this method</span>
    <span class="c1">// depends on the variant of `self`</span>
    <span class="c1">// `self` has type `&amp;List`, and `*self` has type `List`, matching on a</span>
    <span class="c1">// concrete type `T` is preferred over a match on a reference `&amp;T`</span>
    <span class="c1">// after Rust 2018 you can use self here and tail (with no ref) below as well,</span>
    <span class="c1">// rust will infer &amp;s and ref tail. </span>
    <span class="c1">// See https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/default-match-bindings.html</span>
    <span class="k">match</span> <span class="o">*</span><span class="k">self</span> <span class="p">{</span>
      <span class="c1">// Can't take ownership of the tail, because `self` is borrowed;</span>
      <span class="c1">// instead take a reference to the tail</span>
      <span class="nf">Cons</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="k">ref</span> <span class="n">tail</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">tail</span><span class="nf">.len</span><span class="p">(),</span>
      <span class="c1">// Base Case: An empty list has zero length</span>
      <span class="nb">Nil</span> <span class="k">=&gt;</span> <span class="mi">0</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Return representation of the list as a (heap allocated) string</span>
  <span class="k">fn</span> <span class="nf">stringify</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="k">match</span> <span class="o">*</span><span class="k">self</span> <span class="p">{</span>
      <span class="nf">Cons</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">ref</span> <span class="n">tail</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="c1">// `format!` is similar to `print!`, but returns a heap</span>
        <span class="c1">// allocated string instead of printing to the console</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"{}, {}"</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="nf">.stringify</span><span class="p">())</span>
      <span class="p">},</span>
      <span class="nb">Nil</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"Nil"</span><span class="p">)</span>
      <span class="p">},</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Create an empty linked list</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">list</span> <span class="o">=</span> <span class="nn">List</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

  <span class="c1">// Prepend some elements</span>
  <span class="n">list</span> <span class="o">=</span> <span class="n">list</span><span class="nf">.prepend</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">list</span> <span class="o">=</span> <span class="n">list</span><span class="nf">.prepend</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">list</span> <span class="o">=</span> <span class="n">list</span><span class="nf">.prepend</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

  <span class="c1">// Show the final state of the list</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"linked list has length: {}"</span><span class="p">,</span> <span class="n">list</span><span class="nf">.len</span><span class="p">());</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">list</span><span class="nf">.stringify</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="constants">constants</h2>
<p>Rust has two different types of constants which can be declared in any scope including global. 
Both require explicit type annotation:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">const</code>: An unchangeable value (the common case).</li>
  <li><code class="language-plaintext highlighter-rouge">static</code>: A possibly <code class="language-plaintext highlighter-rouge">mut</code>able variable with <code class="language-plaintext highlighter-rouge">'static</code> lifetime. 
The static lifetime is inferred and does not have to be specified. 
Accessing or modifying a mutable static variable is <code class="language-plaintext highlighter-rouge">unsafe</code>.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Globals are declared outside all other scopes.</span>
<span class="k">static</span> <span class="n">LANGUAGE</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">"Rust"</span><span class="p">;</span>
<span class="k">const</span> <span class="n">THRESHOLD</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">is_big</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
  <span class="c1">// Access constant in some function</span>
  <span class="n">n</span> <span class="o">&gt;</span> <span class="n">THRESHOLD</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>

  <span class="c1">// Access constant in the main thread</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"This is {}"</span><span class="p">,</span> <span class="n">LANGUAGE</span><span class="p">);</span><span class="o">~</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"The threshold is {}"</span><span class="p">,</span> <span class="n">THRESHOLD</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{} is {}"</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="k">if</span> <span class="nf">is_big</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="s">"big"</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="s">"small"</span> <span class="p">});</span>

  <span class="c1">// Error! Cannot modify a `const`.</span>
  <span class="n">THRESHOLD</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="c1">// FIXME ^ Comment out this line</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>JJungs-lee</name></author><category term="RUST by Example" /><category term="Rust" /><category term="Example" /><category term="sturct" /><category term="enum" /><category term="const" /><category term="static" /><summary type="html"><![CDATA[Rust custom data types are formed mainly through the two keywords:]]></summary></entry><entry><title type="html">Rust by Example : 4. Variable Bindings</title><link href="https://jjungs-lee.github.io//rust/4.Variable-Bindings" rel="alternate" type="text/html" title="Rust by Example : 4. Variable Bindings" /><published>2022-03-04T00:00:00+00:00</published><updated>2022-03-04T00:00:00+00:00</updated><id>https://jjungs-lee.github.io//rust/4.Variable%20Bindings</id><content type="html" xml:base="https://jjungs-lee.github.io//rust/4.Variable-Bindings"><![CDATA[<p>Rust provides type safety via static typing. 
Variable bindings can be type annotated when declared. 
However, in most cases, the compiler will be able to infer the type of the variable from the context, heavily reducing the annotation burden.</p>

<p>Values (like literals) can be bound to variables, using the <code class="language-plaintext highlighter-rouge">let</code> binding.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">an_integer</span> <span class="o">=</span> <span class="mi">1u32</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">a_boolean</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">unit</span> <span class="o">=</span> <span class="p">();</span>

  <span class="c1">// copy `an_integer` into `copied_integer`</span>
  <span class="k">let</span> <span class="n">copied_integer</span> <span class="o">=</span> <span class="n">an_integer</span><span class="p">;</span>

  <span class="nd">println!</span><span class="p">(</span><span class="s">"An integer: {:?}"</span><span class="p">,</span> <span class="n">copied_integer</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"A boolean: {:?}"</span><span class="p">,</span> <span class="n">a_boolean</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Meet the unit value: {:?}"</span><span class="p">,</span> <span class="n">unit</span><span class="p">);</span>

  <span class="c1">// The compiler warns about unused variable bindings; </span>
  <span class="c1">// these warnings can be silenced by prefixing </span>
  <span class="c1">// the variable name with an underscore</span>
  <span class="k">let</span> <span class="n">_unused_variable</span> <span class="o">=</span> <span class="mi">3u32</span><span class="p">;</span>

  <span class="k">let</span> <span class="n">noisy_unused_variable</span> <span class="o">=</span> <span class="mi">2u32</span><span class="p">;</span>
  <span class="c1">// FIXME ^ Prefix with an underscore to suppress the warning</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="41-mutability">4.1 Mutability</h2>
<p>Variable bindings are immutable by default, but this can be overridden using the <code class="language-plaintext highlighter-rouge">mut</code> modifier.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">_immutable_binding</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">mutable_binding</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="nd">println!</span><span class="p">(</span><span class="s">"Before mutation: {}"</span><span class="p">,</span> <span class="n">mutable_binding</span><span class="p">);</span>

  <span class="c1">// Ok</span>
  <span class="n">mutable_binding</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="nd">println!</span><span class="p">(</span><span class="s">"After mutation: {}"</span><span class="p">,</span> <span class="n">mutable_binding</span><span class="p">);</span>

  <span class="c1">// Error!</span>
  <span class="n">_immutable_binding</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="c1">// FIXME ^ Comment out this line</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The compiler will throw a detailed diagnostic about mutability errors.</p>

<h2 id="42-scope-and-shadowing">4.2 Scope and Shadowing</h2>
<p>Variable bindings have a scope, and are constrained to live in a block. 
A block is a collection of statements enclosed by braces <code class="language-plaintext highlighter-rouge">{}</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// This binding lives in the main function</span>
  <span class="k">let</span> <span class="n">long_lived_binding</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="c1">// This is a block, and has a smaller scope than the main function</span>
  <span class="p">{</span>
      <span class="c1">// This binding only exists in this block</span>
      <span class="k">let</span> <span class="n">short_lived_binding</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

      <span class="nd">println!</span><span class="p">(</span><span class="s">"inner short: {}"</span><span class="p">,</span> <span class="n">short_lived_binding</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// End of the block</span>

  <span class="c1">// Error! `short_lived_binding` doesn't exist in this scope</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"outer short: {}"</span><span class="p">,</span> <span class="n">short_lived_binding</span><span class="p">);</span>
  <span class="c1">// FIXME ^ Comment out this line</span>

  <span class="nd">println!</span><span class="p">(</span><span class="s">"outer long: {}"</span><span class="p">,</span> <span class="n">long_lived_binding</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Also, variable shadowing is allowed.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">shadowed_binding</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"before being shadowed: {}"</span><span class="p">,</span> <span class="n">shadowed_binding</span><span class="p">);</span>

    <span class="c1">// This binding *shadows* the outer one</span>
    <span class="k">let</span> <span class="n">shadowed_binding</span> <span class="o">=</span> <span class="s">"abc"</span><span class="p">;</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"shadowed in inner block: {}"</span><span class="p">,</span> <span class="n">shadowed_binding</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"outside inner block: {}"</span><span class="p">,</span> <span class="n">shadowed_binding</span><span class="p">);</span>

  <span class="c1">// This binding *shadows* the previous binding</span>
  <span class="k">let</span> <span class="n">shadowed_binding</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"shadowed in outer block: {}"</span><span class="p">,</span> <span class="n">shadowed_binding</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="43-declare-first">4.3 Declare first</h2>
<p>It’s possible to declare variable bindings first, and initialize them later. 
However, this form is seldom used, as it may lead to the use of uninitialized variables.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Declare a variable binding</span>
  <span class="k">let</span> <span class="n">a_binding</span><span class="p">;</span>

  <span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

    <span class="c1">// Initialize the binding</span>
    <span class="n">a_binding</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nd">println!</span><span class="p">(</span><span class="s">"a binding: {}"</span><span class="p">,</span> <span class="n">a_binding</span><span class="p">);</span>

  <span class="k">let</span> <span class="n">another_binding</span><span class="p">;</span>

  <span class="c1">// Error! Use of uninitialized binding</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"another binding: {}"</span><span class="p">,</span> <span class="n">another_binding</span><span class="p">);</span>
  <span class="c1">// FIXME ^ Comment out this line</span>

  <span class="n">another_binding</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="nd">println!</span><span class="p">(</span><span class="s">"another binding: {}"</span><span class="p">,</span> <span class="n">another_binding</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The compiler forbids use of uninitialized variables, as this would lead to undefined behavior.</p>

<h2 id="44-freezing">4.4 Freezing</h2>
<p>When data is bound by the same name immutably, it also <em>freezes</em>. 
Frozen data can’t be modified until the immutable binding goes out of scope:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">_mutable_integer</span> <span class="o">=</span> <span class="mi">7i32</span><span class="p">;</span>

  <span class="p">{</span>
    <span class="c1">// Shadowing by immutable `_mutable_integer`</span>
    <span class="k">let</span> <span class="n">_mutable_integer</span> <span class="o">=</span> <span class="n">_mutable_integer</span><span class="p">;</span>

    <span class="c1">// Error! `_mutable_integer` is frozen in this scope</span>
    <span class="n">_mutable_integer</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
    <span class="c1">// FIXME ^ Comment out this line</span>

    <span class="c1">// `_mutable_integer` goes out of scope</span>
  <span class="p">}</span>

  <span class="c1">// Ok! `_mutable_integer` is not frozen in this scope</span>
  <span class="n">_mutable_integer</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>JJungs-lee</name></author><category term="RUST by Example" /><category term="Rust" /><category term="Example" /><summary type="html"><![CDATA[Rust provides type safety via static typing. Variable bindings can be type annotated when declared. However, in most cases, the compiler will be able to infer the type of the variable from the context, heavily reducing the annotation burden.]]></summary></entry><entry><title type="html">Rust by Example : 2. Primitives</title><link href="https://jjungs-lee.github.io//rust/2.Primitives" rel="alternate" type="text/html" title="Rust by Example : 2. Primitives" /><published>2022-03-03T00:00:00+00:00</published><updated>2022-03-03T00:00:00+00:00</updated><id>https://jjungs-lee.github.io//rust/2.Primitives</id><content type="html" xml:base="https://jjungs-lee.github.io//rust/2.Primitives"><![CDATA[<p>Rust provides access to a wide variety of <code class="language-plaintext highlighter-rouge">primitives</code>. A sample includes:</p>

<h3 id="scalar-types">Scalar Types</h3>
<ul>
  <li>signed integers: <code class="language-plaintext highlighter-rouge">i8</code>, <code class="language-plaintext highlighter-rouge">i16</code>, <code class="language-plaintext highlighter-rouge">i32</code>, <code class="language-plaintext highlighter-rouge">i64</code>, <code class="language-plaintext highlighter-rouge">i128</code> and <code class="language-plaintext highlighter-rouge">isize</code> (pointer size)</li>
  <li>unsigned integers: <code class="language-plaintext highlighter-rouge">u8</code>, <code class="language-plaintext highlighter-rouge">u16</code>, <code class="language-plaintext highlighter-rouge">u32</code>, <code class="language-plaintext highlighter-rouge">u64</code>, <code class="language-plaintext highlighter-rouge">u128</code> and <code class="language-plaintext highlighter-rouge">usize</code> (pointer size)</li>
  <li>floating point: <code class="language-plaintext highlighter-rouge">f32</code>, <code class="language-plaintext highlighter-rouge">f64</code></li>
  <li><code class="language-plaintext highlighter-rouge">char</code> Unicode scalar values like <code class="language-plaintext highlighter-rouge">'a'</code>, <code class="language-plaintext highlighter-rouge">'α'</code> and <code class="language-plaintext highlighter-rouge">'∞'</code> (4 bytes each)</li>
  <li><code class="language-plaintext highlighter-rouge">bool</code> either <code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code></li>
  <li>and the unit type <code class="language-plaintext highlighter-rouge">()</code>, whose only possible value is an empty tuple: <code class="language-plaintext highlighter-rouge">()</code></li>
</ul>

<p>Despite the value of a unit type being a tuple, it is not considered a compound type because it does not contain multiple values.</p>

<h3 id="compound-types">Compound Types</h3>
<ul>
  <li>arrays like <code class="language-plaintext highlighter-rouge">[1, 2, 3]</code></li>
  <li>tuples like <code class="language-plaintext highlighter-rouge">(1, true)</code>
Variables can always be type <em>annotated</em>. Numbers may additionally be annotated via a <em>suffix</em> or by <em>default</em>. Integers default to <code class="language-plaintext highlighter-rouge">i32</code> and floats to <code class="language-plaintext highlighter-rouge">f64</code>. Note that Rust can also infer types from context.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Variables can be type annotated.</span>
  <span class="k">let</span> <span class="n">logical</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>

  <span class="k">let</span> <span class="n">a_float</span><span class="p">:</span> <span class="nb">f64</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>  <span class="c1">// Regular annotation</span>
  <span class="k">let</span> <span class="n">an_integer</span>   <span class="o">=</span> <span class="mi">5i32</span><span class="p">;</span> <span class="c1">// Suffix annotation</span>

  <span class="c1">// Or a default will be used.</span>
  <span class="k">let</span> <span class="n">default_float</span>   <span class="o">=</span> <span class="mf">3.0</span><span class="p">;</span> <span class="c1">// `f64`</span>
  <span class="k">let</span> <span class="n">default_integer</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>   <span class="c1">// `i32`</span>
  
  <span class="c1">// A type can also be inferred from context </span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">inferred_type</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span> <span class="c1">// Type i64 is inferred from another line</span>
  <span class="n">inferred_type</span> <span class="o">=</span> <span class="mi">4294967296i64</span><span class="p">;</span>
  
  <span class="c1">// A mutable variable's value can be changed.</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">mutable</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span> <span class="c1">// Mutable `i32`</span>
  <span class="n">mutable</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>
  
  <span class="c1">// Error! The type of a variable can't be changed.</span>
  <span class="n">mutable</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
  
  <span class="c1">// Variables can be overwritten with shadowing.</span>
  <span class="k">let</span> <span class="n">mutable</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="21-literals-and-operators">2.1 Literals and operators</h2>
<p>Integers <code class="language-plaintext highlighter-rouge">1</code>, floats <code class="language-plaintext highlighter-rouge">1.2</code>, characters <code class="language-plaintext highlighter-rouge">'a'</code>, strings <code class="language-plaintext highlighter-rouge">"abc"</code>, booleans <code class="language-plaintext highlighter-rouge">true</code> and the unit type <code class="language-plaintext highlighter-rouge">()</code> can be expressed using literals.</p>

<p>Integers can, alternatively, be expressed using hexadecimal, octal or binary notation using these prefixes respectively: <code class="language-plaintext highlighter-rouge">0x</code>, <code class="language-plaintext highlighter-rouge">0o</code> or <code class="language-plaintext highlighter-rouge">0b</code>.</p>

<p>Underscores can be inserted in numeric literals to improve readability, e.g. <code class="language-plaintext highlighter-rouge">1_000</code> is the same as <code class="language-plaintext highlighter-rouge">1000</code>, and <code class="language-plaintext highlighter-rouge">0.000_001</code> is the same as <code class="language-plaintext highlighter-rouge">0.000001</code>.</p>

<p>We need to tell the compiler the type of the literals we use. For now, we’ll use the <code class="language-plaintext highlighter-rouge">u32</code> suffix to indicate that the literal is an unsigned 32-bit integer, and the <code class="language-plaintext highlighter-rouge">i32</code> suffix to indicate that it’s a signed 32-bit integer.</p>

<p>The operators available and their precedence in Rust are similar to other C-like languages.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Integer addition</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"1 + 2 = {}"</span><span class="p">,</span> <span class="mi">1u32</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>

  <span class="c1">// Integer subtraction</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"1 - 2 = {}"</span><span class="p">,</span> <span class="mi">1i32</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
  <span class="c1">// TODO ^ Try changing `1i32` to `1u32` to see why the type is important</span>

  <span class="c1">// Short-circuiting boolean logic</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"true AND false is {}"</span><span class="p">,</span> <span class="kc">true</span> <span class="o">&amp;&amp;</span> <span class="kc">false</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"true OR false is {}"</span><span class="p">,</span> <span class="kc">true</span> <span class="p">||</span> <span class="kc">false</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"NOT true is {}"</span><span class="p">,</span> <span class="o">!</span><span class="kc">true</span><span class="p">);</span>

  <span class="c1">// Bitwise operations</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"0011 AND 0101 is {:04b}"</span><span class="p">,</span> <span class="mi">0b0011u32</span> <span class="o">&amp;</span> <span class="mi">0b0101</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"0011 OR 0101 is {:04b}"</span><span class="p">,</span> <span class="mi">0b0011u32</span> <span class="p">|</span> <span class="mi">0b0101</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"0011 XOR 0101 is {:04b}"</span><span class="p">,</span> <span class="mi">0b0011u32</span> <span class="o">^</span> <span class="mi">0b0101</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"1 &lt;&lt; 5 is {}"</span><span class="p">,</span> <span class="mi">1u32</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"0x80 &gt;&gt; 2 is 0x{:x}"</span><span class="p">,</span> <span class="mi">0x80u32</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>

  <span class="c1">// Use underscores to improve readability!</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"One million is written as {}"</span><span class="p">,</span> <span class="mi">1_000_000u32</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="22-tuples">2.2 Tuples</h2>
<p>A tuple is a collection of values of different types. 
Tuples are constructed using parentheses <code class="language-plaintext highlighter-rouge">()</code>, 
and each tuple itself is a value with type signature <code class="language-plaintext highlighter-rouge">(T1, T2, ...)</code>, 
where <code class="language-plaintext highlighter-rouge">T1</code>, <code class="language-plaintext highlighter-rouge">T2</code> are the types of its members. 
Functions can use tuples to return multiple values, as tuples can hold any number of values.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Tuples can be used as function arguments and as return values</span>
<span class="k">fn</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">pair</span><span class="p">:</span> <span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">bool</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// `let` can be used to bind the members of a tuple to variables</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">integer</span><span class="p">,</span> <span class="n">boolean</span><span class="p">)</span> <span class="o">=</span> <span class="n">pair</span><span class="p">;</span>

    <span class="p">(</span><span class="n">boolean</span><span class="p">,</span> <span class="n">integer</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// The following struct is for the activity.</span>
<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="nf">Matrix</span><span class="p">(</span><span class="nb">f32</span><span class="p">,</span> <span class="nb">f32</span><span class="p">,</span> <span class="nb">f32</span><span class="p">,</span> <span class="nb">f32</span><span class="p">);</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// A tuple with a bunch of different types</span>
  <span class="k">let</span> <span class="n">long_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1u8</span><span class="p">,</span> <span class="mi">2u16</span><span class="p">,</span> <span class="mi">3u32</span><span class="p">,</span> <span class="mi">4u64</span><span class="p">,</span>
                    <span class="o">-</span><span class="mi">1i8</span><span class="p">,</span> <span class="o">-</span><span class="mi">2i16</span><span class="p">,</span> <span class="o">-</span><span class="mi">3i32</span><span class="p">,</span> <span class="o">-</span><span class="mi">4i64</span><span class="p">,</span>
                    <span class="mf">0.1f32</span><span class="p">,</span> <span class="mf">0.2f64</span><span class="p">,</span>
                    <span class="sc">'a'</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>

  <span class="c1">// Values can be extracted from the tuple using tuple indexing</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"long tuple first value: {}"</span><span class="p">,</span> <span class="n">long_tuple</span><span class="na">.0</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"long tuple second value: {}"</span><span class="p">,</span> <span class="n">long_tuple</span><span class="na">.1</span><span class="p">);</span>

  <span class="c1">// Tuples can be tuple members</span>
  <span class="k">let</span> <span class="n">tuple_of_tuples</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1u8</span><span class="p">,</span> <span class="mi">2u16</span><span class="p">,</span> <span class="mi">2u32</span><span class="p">),</span> <span class="p">(</span><span class="mi">4u64</span><span class="p">,</span> <span class="o">-</span><span class="mi">1i8</span><span class="p">),</span> <span class="o">-</span><span class="mi">2i16</span><span class="p">);</span>

  <span class="c1">// Tuples are printable</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"tuple of tuples: {:?}"</span><span class="p">,</span> <span class="n">tuple_of_tuples</span><span class="p">);</span>
  
  <span class="c1">// But long Tuples cannot be printed</span>
  <span class="c1">// let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);</span>
  <span class="c1">// println!("too long tuple: {:?}", too_long_tuple);</span>
  <span class="c1">// TODO ^ Uncomment the above 2 lines to see the compiler error</span>

  <span class="k">let</span> <span class="n">pair</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"pair is {:?}"</span><span class="p">,</span> <span class="n">pair</span><span class="p">);</span>

  <span class="nd">println!</span><span class="p">(</span><span class="s">"the reversed pair is {:?}"</span><span class="p">,</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">pair</span><span class="p">));</span>

  <span class="c1">// To create one element tuples, the comma is required to tell them apart</span>
  <span class="c1">// from a literal surrounded by parentheses</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"one element tuple: {:?}"</span><span class="p">,</span> <span class="p">(</span><span class="mi">5u32</span><span class="p">,));</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"just an integer: {:?}"</span><span class="p">,</span> <span class="p">(</span><span class="mi">5u32</span><span class="p">));</span>

  <span class="c1">//tuples can be destructured to create bindings</span>
  <span class="k">let</span> <span class="n">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"hello"</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>

  <span class="k">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="n">tuple</span><span class="p">;</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}, {:?}, {:?}, {:?}"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>

  <span class="k">let</span> <span class="n">matrix</span> <span class="o">=</span> <span class="nf">Matrix</span><span class="p">(</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">matrix</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>

<h3 id="activity">Activity</h3>
<ol>
  <li>Recap: Add the <code class="language-plaintext highlighter-rouge">fmt::Display</code> trait to the <code class="language-plaintext highlighter-rouge">Matrix</code> struct in the above example, so that if you switch from printing the debug format <code class="language-plaintext highlighter-rouge">{:?}</code> to the display format <code class="language-plaintext highlighter-rouge">{}</code>, you see the following output:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>( 1.1 1.2 )
( 2.1 2.2 )
</code></pre></div></div>
<p>You may want to refer back to the example for print display.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fmt</span><span class="p">;</span> <span class="c1">// Import `fmt`</span>

<span class="c1">// The following struct is for the activity.</span>
<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="nf">Matrix</span><span class="p">(</span><span class="nb">f32</span><span class="p">,</span> <span class="nb">f32</span><span class="p">,</span> <span class="nb">f32</span><span class="p">,</span> <span class="nb">f32</span><span class="p">);</span>

<span class="c1">// add to Display trait</span>
<span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="k">for</span> <span class="n">Matrix</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
    <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"( {} {} )</span><span class="se">\n</span><span class="s">( {} {} )"</span><span class="p">,</span> <span class="k">self</span><span class="na">.0</span><span class="p">,</span> <span class="k">self</span><span class="na">.1</span><span class="p">,</span> <span class="k">self</span><span class="na">.2</span><span class="p">,</span> <span class="k">self</span><span class="na">.3</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">matrix</span> <span class="o">=</span> <span class="nf">Matrix</span><span class="p">(</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">matrix</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>Add a <code class="language-plaintext highlighter-rouge">transpose</code> function using the reverse function as a template, which accepts a matrix as an argument, and returns a matrix in which two elements have been swapped. For example:</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">println!</span><span class="p">(</span><span class="s">"Matrix:</span><span class="se">\n</span><span class="s">{}"</span><span class="p">,</span> <span class="n">matrix</span><span class="p">);</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"Transpose:</span><span class="se">\n</span><span class="s">{}"</span><span class="p">,</span> <span class="nf">transpose</span><span class="p">(</span><span class="n">matrix</span><span class="p">));</span>
</code></pre></div></div>
<p>results in the output:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Matrix:
( 1.1 1.2 )
( 2.1 2.2 )
Transpose:
( 1.1 2.1 )
( 1.2 2.2 )
</code></pre></div></div>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fmt</span><span class="p">;</span> <span class="c1">// Import `fmt`</span>

<span class="c1">// The following struct is for the activity.</span>
<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="nf">Matrix</span><span class="p">(</span><span class="nb">f32</span><span class="p">,</span> <span class="nb">f32</span><span class="p">,</span> <span class="nb">f32</span><span class="p">,</span> <span class="nb">f32</span><span class="p">);</span>

<span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="k">for</span> <span class="n">Matrix</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
    <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"( {} {} )</span><span class="se">\n</span><span class="s">( {} {} )"</span><span class="p">,</span> <span class="k">self</span><span class="na">.0</span><span class="p">,</span> <span class="k">self</span><span class="na">.1</span><span class="p">,</span> <span class="k">self</span><span class="na">.2</span><span class="p">,</span> <span class="k">self</span><span class="na">.3</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">transpose</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="n">Matrix</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Matrix</span> <span class="p">{</span>
    <span class="nf">Matrix</span><span class="p">(</span><span class="n">m</span><span class="na">.0</span><span class="p">,</span> <span class="n">m</span><span class="na">.2</span><span class="p">,</span> <span class="n">m</span><span class="na">.1</span><span class="p">,</span> <span class="n">m</span><span class="na">.3</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">matrix</span> <span class="o">=</span> <span class="nf">Matrix</span><span class="p">(</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Matrix:</span><span class="se">\n</span><span class="s">{}"</span><span class="p">,</span> <span class="n">matrix</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Transpose:</span><span class="se">\n</span><span class="s">{}"</span><span class="p">,</span> <span class="nf">transpose</span><span class="p">(</span><span class="n">matrix</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="23-arrays-and-slices">2.3 Arrays and Slices</h2>

<p>An <strong>array</strong> is a collection of objects of the same type <code class="language-plaintext highlighter-rouge">T</code>, stored in contiguous memory. 
Arrays are created using brackets <code class="language-plaintext highlighter-rouge">[]</code>, and their length, which is known at compile time,
 is part of their type signature <code class="language-plaintext highlighter-rouge">[T; length]</code>.</p>

<p><strong>Slices</strong> are similar to arrays, but their length is not known at compile time. 
Instead, a slice is a two-word object, 
the first word is a pointer to the data, and the second word is the length of the slice. 
The word size is the same as usize, determined by the processor architecture eg 64 bits on an x86-64. 
Slices can be used to borrow a section of an array, and have the type signature <code class="language-plaintext highlighter-rouge">&amp;[T]</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">mem</span><span class="p">;</span>

<span class="c1">// This function borrows a slice</span>
<span class="k">fn</span> <span class="nf">analyze_slice</span><span class="p">(</span><span class="n">slice</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">i32</span><span class="p">])</span> <span class="p">{</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"first element of the slice: {}"</span><span class="p">,</span> <span class="n">slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"the slice has {} elements"</span><span class="p">,</span> <span class="n">slice</span><span class="nf">.len</span><span class="p">());</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Fixed-size array (type signature is superfluous)</span>
  <span class="k">let</span> <span class="n">xs</span><span class="p">:</span> <span class="p">[</span><span class="nb">i32</span><span class="p">;</span> <span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>

  <span class="c1">// All elements can be initialized to the same value</span>
  <span class="k">let</span> <span class="n">ys</span><span class="p">:</span> <span class="p">[</span><span class="nb">i32</span><span class="p">;</span> <span class="mi">500</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">500</span><span class="p">];</span>

  <span class="c1">// Indexing starts at 0</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"first element of the array: {}"</span><span class="p">,</span> <span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"second element of the array: {}"</span><span class="p">,</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="c1">// `len` returns the count of elements in the array</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"number of elements in array: {}"</span><span class="p">,</span> <span class="n">xs</span><span class="nf">.len</span><span class="p">());</span>

  <span class="c1">// Arrays are stack allocated</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"array occupies {} bytes"</span><span class="p">,</span> <span class="nn">mem</span><span class="p">::</span><span class="nf">size_of_val</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xs</span><span class="p">));</span>

  <span class="c1">// Arrays can be automatically borrowed as slices</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"borrow the whole array as a slice"</span><span class="p">);</span>
  <span class="nf">analyze_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xs</span><span class="p">);</span>

  <span class="c1">// Slices can point to a section of an array</span>
  <span class="c1">// They are of the form [starting_index..ending_index]</span>
  <span class="c1">// starting_index is the first position in the slice</span>
  <span class="c1">// ending_index is one more than the last position in the slice</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"borrow a section of the array as a slice"</span><span class="p">);</span>
  <span class="nf">analyze_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ys</span><span class="p">[</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">4</span><span class="p">]);</span>

  <span class="c1">// Out of bound indexing causes compile error</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">xs</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>JJungs-lee</name></author><category term="RUST by Example" /><category term="Rust" /><category term="Example" /><summary type="html"><![CDATA[Rust provides access to a wide variety of primitives. A sample includes:]]></summary></entry><entry><title type="html">Rust by Example : 0. Introduction</title><link href="https://jjungs-lee.github.io//rust/0.Rust-By-Exaple" rel="alternate" type="text/html" title="Rust by Example : 0. Introduction" /><published>2022-03-02T00:00:00+00:00</published><updated>2022-03-02T00:00:00+00:00</updated><id>https://jjungs-lee.github.io//rust/0.Rust%20By%20Exaple</id><content type="html" xml:base="https://jjungs-lee.github.io//rust/0.Rust-By-Exaple"><![CDATA[<p>If you’re studying rust, it’s very helpful to follow the examples. I’m going to try to study it. :)</p>

<p>Rust is a modern systems programming language focusing on safety, speed, and concurrency. It accomplishes these goals by being memory safe without using garbage collection.</p>

<p>Rust by Example (RBE) is a collection of runnable examples that illustrate various Rust concepts and standard libraries. 
To get even more out of these examples, don’t forget to <a href="https://www.rust-lang.org/tools/install">install Rust locally</a> and check out the <a href="https://doc.rust-lang.org/std/">official docs</a>. Additionally for the curious, you can also <a href="https://github.com/rust-lang/rust-by-example">check out the source code for this site</a>.
Now let’s begin!</p>

<h2 id="link">link</h2>
<ul>
  <li>[1. Hello World] - Start with a traditional Hello World program.</li>
  <li>[2. Primitives] - Learn about signed integers, unsigned integers and other primitives.</li>
  <li>[3. Custom Types] - struct and enum.</li>
  <li>[4. Variable Bindings] - mutable bindings, scope, shadowing.</li>
  <li>[5. Types] - Learn about changing and defining types.</li>
  <li>[6. Conversion]</li>
  <li>[7. Expressions]</li>
  <li>[8. Flow of Control] - if/else, for, and others.</li>
  <li>[9. Functions] - Learn about Methods, Closures and High Order Functions.</li>
  <li>[10. Modules] - Organize code using modules</li>
  <li>[11. Crates] - A crate is a compilation unit in Rust. Learn to create a library.</li>
  <li>[12. Cargo] - Go through some basic features of the official Rust package management tool.</li>
  <li>[13. Attributes] - An attribute is metadata applied to some module, crate or item.</li>
  <li>[14. Generics]  - Learn about writing a function or data type which can work for multiple types of arguments.</li>
  <li>[15. Scoping rules] - Scopes play an important part in ownership, borrowing, and lifetimes.</li>
  <li>[16. Traits] - A trait is a collection of methods defined for an unknown type: Self</li>
  <li>[17. Macros]</li>
  <li>[18. Error handling] - Learn Rust way of handling failures.</li>
  <li>[19. Std library types] - Learn about some custom types provided by std library.</li>
  <li>[20. Std misc] - More custom types for file handling, threads.</li>
  <li>[21. Testing] - All sorts of testing in Rust.</li>
  <li>[22. Unsafe Operations]</li>
  <li>[23. Compatibility]</li>
  <li>[24. Meta] - Documentation, Benchmarking.</li>
</ul>

<hr />
<p>[Reference] <br />
eng ver : <a href="https://doc.rust-lang.org/rust-by-example/index.html">https://doc.rust-lang.org/rust-by-example/index.html</a></p>]]></content><author><name>JJungs-lee</name></author><category term="RUST by Example" /><category term="Rust" /><category term="Example" /><summary type="html"><![CDATA[If you’re studying rust, it’s very helpful to follow the examples. I’m going to try to study it. :)]]></summary></entry><entry><title type="html">Rust by Example : 1. Hello World</title><link href="https://jjungs-lee.github.io//rust/1.Hello-World" rel="alternate" type="text/html" title="Rust by Example : 1. Hello World" /><published>2022-03-02T00:00:00+00:00</published><updated>2022-03-02T00:00:00+00:00</updated><id>https://jjungs-lee.github.io//rust/1.Hello%20World</id><content type="html" xml:base="https://jjungs-lee.github.io//rust/1.Hello-World"><![CDATA[<p>This is the source code of the traditional Hello World program.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This is the main function</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Statements here are executed when the compiled binary is called</span>

  <span class="c1">// Print text to the console</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello World!"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">println!</code> is a <a href="https://doc.rust-lang.org/rust-by-example/macros.html">macro</a> that prints text to the console.</p>

<p>A binary can be generated using the Rust compiler: <code class="language-plaintext highlighter-rouge">rustc</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ rustc hello.rs
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">rustc</code> will produce a <code class="language-plaintext highlighter-rouge">hello</code> binary that can be executed.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./hello
Hello World!
</code></pre></div></div>
<h3 id="activity">Activity</h3>
<p>Click ‘Run’ above to see the expected output. Next, add a new line with a second <code class="language-plaintext highlighter-rouge">println!</code> macro so that the output shows:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello World!  
I'm a Rustacean!
</code></pre></div></div>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// answer code</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello World!"</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"I'm a Rustacean!"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="11-comments">1.1 Comments</h2>

<p>Any program requires comments, and Rust supports a few different varieties:</p>

<ul>
  <li>Regular comments which are ignored by the compiler:
    <ul>
      <li>// Line comments which go to the end of the line.</li>
      <li>/* Block comments which go to the closing delimiter. */</li>
    </ul>
  </li>
  <li>Doc comments which are parsed into HTML library documentation:
    <ul>
      <li>/// Generate library docs for the following item.</li>
      <li>//! Generate library docs for the enclosing item.</li>
    </ul>
  </li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// This is an example of a line comment</span>
  <span class="c1">// There are two slashes at the beginning of the line</span>
  <span class="c1">// And nothing written inside these will be read by the compiler</span>

  <span class="c1">// println!("Hello, world!");</span>

  <span class="c1">// Run it. See? Now try deleting the two slashes, and run it again.</span>

  <span class="cm">/* 
    * This is another type of comment, a block comment. In general,
    * line comments are the recommended comment style. But
    * block comments are extremely useful for temporarily disabling
    * chunks of code. /* Block comments can be /* nested, */ */
    * so it takes only a few keystrokes to comment out everything
    * in this main() function. /*/*/* Try it yourself! */*/*/
    */</span>

  <span class="cm">/*
  Note: The previous column of `*` was entirely for style. There's
  no actual need for it.
  */</span>

  <span class="c1">// You can manipulate expressions more easily with block comments</span>
  <span class="c1">// than with line comments. Try deleting the comment delimiters</span>
  <span class="c1">// to change the result:</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">+</span> <span class="cm">/* 90 + */</span> <span class="mi">5</span><span class="p">;</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Is `x` 10 or 100? x = {}"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>
<p>See also: <br />
<a href="https://doc.rust-lang.org/rust-by-example/meta/doc.html">Library documentation</a></p>

<h2 id="12-formatted-print">1.2 Formatted print</h2>
<p>Printing is handled by a series of <code class="language-plaintext highlighter-rouge">macros</code> defined in <code class="language-plaintext highlighter-rouge">std::fmt</code> some of which include:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">format!</code>: write formatted text to <code class="language-plaintext highlighter-rouge">String</code></li>
  <li><code class="language-plaintext highlighter-rouge">print!</code>: same as <code class="language-plaintext highlighter-rouge">format!</code> but the text is printed to the console (io::stdout).</li>
  <li><code class="language-plaintext highlighter-rouge">println!</code>: same as <code class="language-plaintext highlighter-rouge">print!</code> but a newline is appended.</li>
  <li><code class="language-plaintext highlighter-rouge">eprint!</code>: same as <code class="language-plaintext highlighter-rouge">format!</code> but the text is printed to the standard error (io::stderr).</li>
  <li><code class="language-plaintext highlighter-rouge">eprintln!</code>: same as <code class="language-plaintext highlighter-rouge">eprint!</code> but a newline is appended.</li>
</ul>

<p>All parse text in the same fashion. As a plus, Rust checks formatting correctness at compile time.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// In general, the `{}` will be automatically replaced with any</span>
  <span class="c1">// arguments. These will be stringified.</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{} days"</span><span class="p">,</span> <span class="mi">31</span><span class="p">);</span>

  <span class="c1">// Without a suffix, 31 becomes an i32. You can change what type 31 is</span>
  <span class="c1">// by providing a suffix. The number 31i64 for example has the type i64.</span>

  <span class="c1">// There are various optional patterns this works with. Positional</span>
  <span class="c1">// arguments can be used.</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{0}, this is {1}. {1}, this is {0}"</span><span class="p">,</span> <span class="s">"Alice"</span><span class="p">,</span> <span class="s">"Bob"</span><span class="p">);</span>

  <span class="c1">// As can named arguments.</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{subject} {verb} {object}"</span><span class="p">,</span>
            <span class="n">object</span><span class="o">=</span><span class="s">"the lazy dog"</span><span class="p">,</span>
            <span class="n">subject</span><span class="o">=</span><span class="s">"the quick brown fox"</span><span class="p">,</span>
            <span class="n">verb</span><span class="o">=</span><span class="s">"jumps over"</span><span class="p">);</span>

  <span class="c1">// Special formatting can be specified after a `:`.</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{} of {:b} people know binary, the other half doesn't"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

  <span class="c1">// You can right-align text with a specified width. This will output</span>
  <span class="c1">// "     1". 5 white spaces and a "1".</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{number:&gt;width$}"</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">6</span><span class="p">);</span>

  <span class="c1">// You can pad numbers with extra zeroes. This will output "000001".</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{number:0&gt;width$}"</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">6</span><span class="p">);</span>

  <span class="c1">// Rust even checks to make sure the correct number of arguments are</span>
  <span class="c1">// used.</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"My name is {0}, {1} {0}"</span><span class="p">,</span> <span class="s">"Bond"</span><span class="p">);</span>
  <span class="c1">// FIXME ^ Add the missing argument: "James"</span>

  <span class="c1">// Create a structure named `Structure` which contains an `i32`.</span>
  <span class="nd">#[allow(dead_code)]</span>
  <span class="k">struct</span> <span class="nf">Structure</span><span class="p">(</span><span class="nb">i32</span><span class="p">);</span>

  <span class="c1">// However, custom types such as this structure require more complicated</span>
  <span class="c1">// handling. This will not work.</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"This struct `{}` won't print..."</span><span class="p">,</span> <span class="nf">Structure</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
  <span class="c1">// FIXME ^ Comment out this line.</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">std::fmt</code> contains many <code class="language-plaintext highlighter-rouge">traits</code> which govern the display of text. 
The base form of two important ones are listed below:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">fmt::Debug</code>: Uses the <code class="language-plaintext highlighter-rouge">{:?}</code> marker. Format text for debugging purposes.</li>
  <li><code class="language-plaintext highlighter-rouge">fmt::Display</code>: Uses the <code class="language-plaintext highlighter-rouge">{}</code> marker. Format text in a more elegant, user friendly fashion.
Here, we used <code class="language-plaintext highlighter-rouge">fmt::Display</code> because the std library provides implementations for these types. To print text for custom types, more steps are required.</li>
</ul>

<p>Implementing the fmt::Display trait automatically implements the <code class="language-plaintext highlighter-rouge">ToString</code> trait which allows us to <code class="language-plaintext highlighter-rouge">convert</code> the type to <code class="language-plaintext highlighter-rouge">String</code>.</p>

<h3 id="activities">Activities</h3>
<ul>
  <li>Fix the two issues in the above code (see FIXME) so that it runs without error.</li>
  <li>Add a <code class="language-plaintext highlighter-rouge">println!</code> macro call that prints: <code class="language-plaintext highlighter-rouge">Pi is roughly 3.142</code> by controlling the number of decimal places shown. For the purposes of this exercise, use <code class="language-plaintext highlighter-rouge">let pi = 3.141592</code> as an estimate for pi. (Hint: you may need to check the <code class="language-plaintext highlighter-rouge">std::fmt</code> documentation for setting the number of decimals to display)</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// #1 FIXME -&gt; println!("My name is {0}, {1} {0}", "Bond");</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"My name is {0}, {1} {0}"</span><span class="p">,</span> <span class="s">"Bond"</span><span class="p">,</span> <span class="s">"James"</span><span class="p">);</span>

  <span class="c1">// #2 FIXME -&gt; comment out </span>
  <span class="c1">// println!("This struct `{}` won't print...", Structure(3));</span>

  <span class="c1">// #3 Add a println! macro call that prints</span>
  <span class="k">let</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.141592</span><span class="p">;</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Pi is roughly {0:.3}"</span><span class="p">,</span> <span class="n">pi</span><span class="p">);</span>
</code></pre></div></div>
<p>See also: <br />
<a href="https://doc.rust-lang.org/std/fmt/">std::fmt</a>, 
<a href="https://doc.rust-lang.org/rust-by-example/macros.html">macros</a>, 
<a href="https://doc.rust-lang.org/rust-by-example/custom_types/structs.html">struct</a>, and 
<a href="https://doc.rust-lang.org/std/fmt/#formatting-traits">traits</a></p>

<h3 id="121-debug">1.2.1 Debug</h3>
<p>All types which want to use <code class="language-plaintext highlighter-rouge">std::fmt</code> formatting <code class="language-plaintext highlighter-rouge">traits</code> require an implementation to be printable. 
Automatic implementations are only provided for types such as in the <code class="language-plaintext highlighter-rouge">std</code> library. 
All others <em>must</em> be manually implemented somehow.</p>

<p>The <code class="language-plaintext highlighter-rouge">fmt::Debug</code> <code class="language-plaintext highlighter-rouge">trait</code> makes this very straightforward. <em>All</em> types can <code class="language-plaintext highlighter-rouge">derive</code> (automatically create) the <code class="language-plaintext highlighter-rouge">fmt::Debug</code> implementation. 
This is not true for <code class="language-plaintext highlighter-rouge">fmt::Display</code> which must be manually implemented.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This structure cannot be printed either with `fmt::Display` or</span>
<span class="c1">// with `fmt::Debug`.</span>
<span class="k">struct</span> <span class="nf">UnPrintable</span><span class="p">(</span><span class="nb">i32</span><span class="p">);</span>

<span class="c1">// The `derive` attribute automatically creates the implementation</span>
<span class="c1">// required to make this `struct` printable with `fmt::Debug`.</span>
<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="nf">DebugPrintable</span><span class="p">(</span><span class="nb">i32</span><span class="p">);</span>
</code></pre></div></div>

<p>All <code class="language-plaintext highlighter-rouge">std</code> library types are automatically printable with <code class="language-plaintext highlighter-rouge">{:?}</code> too:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Derive the `fmt::Debug` implementation for `Structure`. `Structure`</span>
<span class="c1">// is a structure which contains a single `i32`.</span>
<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="nf">Structure</span><span class="p">(</span><span class="nb">i32</span><span class="p">);</span>

<span class="c1">// Put a `Structure` inside of the structure `Deep`. Make it printable</span>
<span class="c1">// also.</span>
<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="nf">Deep</span><span class="p">(</span><span class="n">Structure</span><span class="p">);</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Printing with `{:?}` is similar to with `{}`.</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?} months in a year."</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{1:?} {0:?} is the {actor:?} name."</span><span class="p">,</span>
            <span class="s">"Slater"</span><span class="p">,</span>
            <span class="s">"Christian"</span><span class="p">,</span>
            <span class="n">actor</span><span class="o">=</span><span class="s">"actor's"</span><span class="p">);</span>

  <span class="c1">// `Structure` is printable!</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Now {:?} will print!"</span><span class="p">,</span> <span class="nf">Structure</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
  
  <span class="c1">// The problem with `derive` is there is no control over how</span>
  <span class="c1">// the results look. What if I want this to just show a `7`?</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Now {:?} will print!"</span><span class="p">,</span> <span class="nf">Deep</span><span class="p">(</span><span class="nf">Structure</span><span class="p">(</span><span class="mi">7</span><span class="p">)));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So <code class="language-plaintext highlighter-rouge">fmt::Debug</code> definitely makes this printable but sacrifices some elegance. Rust also provides “pretty printing” with <code class="language-plaintext highlighter-rouge">{:#?}</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Person</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span>
  <span class="n">age</span><span class="p">:</span> <span class="nb">u8</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Peter"</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">peter</span> <span class="o">=</span> <span class="n">Person</span> <span class="p">{</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span> <span class="p">};</span>

  <span class="c1">// Pretty print</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{:#?}"</span><span class="p">,</span> <span class="n">peter</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>One can manually implement <code class="language-plaintext highlighter-rouge">fmt::Display</code> to control the display.</p>

<p>See also: <br />
<a href="https://doc.rust-lang.org/reference/attributes.html">attributes</a>, 
<a href="https://doc.rust-lang.org/rust-by-example/trait/derive.html">derive</a>, 
<a href="https://doc.rust-lang.org/std/fmt/">std::fmt</a>, and 
<a href="https://doc.rust-lang.org/rust-by-example/custom_types/structs.html">struct</a></p>

<h3 id="122-display">1.2.2 Display</h3>
<p><code class="language-plaintext highlighter-rouge">fmt::Debug</code> hardly looks compact and clean, so it is often advantageous to customize the output appearance. This is done by manually implementing <code class="language-plaintext highlighter-rouge">fmt::Display</code>, which uses the <code class="language-plaintext highlighter-rouge">{}</code> print marker. Implementing it looks like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Import (via `use`) the `fmt` module to make it available.</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fmt</span><span class="p">;</span>

<span class="c1">// Define a structure for which `fmt::Display` will be implemented. This is</span>
<span class="c1">// a tuple struct named `Structure` that contains an `i32`.</span>
<span class="k">struct</span> <span class="nf">Structure</span><span class="p">(</span><span class="nb">i32</span><span class="p">);</span>

<span class="c1">// To use the `{}` marker, the trait `fmt::Display` must be implemented</span>
<span class="c1">// manually for the type.</span>
<span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="k">for</span> <span class="n">Structure</span> <span class="p">{</span>
    <span class="c1">// This trait requires `fmt` with this exact signature.</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="c1">// Write strictly the first element into the supplied output</span>
        <span class="c1">// stream: `f`. Returns `fmt::Result` which indicates whether the</span>
        <span class="c1">// operation succeeded or failed. Note that `write!` uses syntax which</span>
        <span class="c1">// is very similar to `println!`.</span>
        <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span> <span class="k">self</span><span class="na">.0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">fmt::Display</code> may be cleaner than <code class="language-plaintext highlighter-rouge">fmt::Debug</code> but this presents a problem for the <code class="language-plaintext highlighter-rouge">std</code> library. 
How should ambiguous types be displayed? For example, if the <code class="language-plaintext highlighter-rouge">std</code> library implemented a single style for all <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code>, what style should it be? Would it be either of these two?</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Vec&lt;path&gt;</code> : <code class="language-plaintext highlighter-rouge">/:/etc:/home/username:/bin</code> (split on <code class="language-plaintext highlighter-rouge">:</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">Vec&lt;number&gt;</code> : <code class="language-plaintext highlighter-rouge">1,2,3</code> (split on <code class="language-plaintext highlighter-rouge">,</code>)</li>
</ul>

<p>No, because there is no ideal style for all types and the <code class="language-plaintext highlighter-rouge">std</code> library doesn’t presume to dictate one. 
<code class="language-plaintext highlighter-rouge">fmt::Display</code> is not implemented for <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code> or for any other generic containers.
 <code class="language-plaintext highlighter-rouge">fmt::Debug</code> must then be used for these generic cases.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fmt</span><span class="p">;</span> <span class="c1">// Import `fmt`</span>

<span class="c1">// A structure holding two numbers. `Debug` will be derived so the results can</span>
<span class="c1">// be contrasted with `Display`.</span>
<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="nf">MinMax</span><span class="p">(</span><span class="nb">i64</span><span class="p">,</span> <span class="nb">i64</span><span class="p">);</span>

<span class="c1">// Implement `Display` for `MinMax`.</span>
<span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="k">for</span> <span class="n">MinMax</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
      <span class="c1">// Use `self.number` to refer to each positional data point.</span>
      <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"({}, {})"</span><span class="p">,</span> <span class="k">self</span><span class="na">.0</span><span class="p">,</span> <span class="k">self</span><span class="na">.1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Define a structure where the fields are nameable for comparison.</span>
<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Point2D</span> <span class="p">{</span>
  <span class="n">x</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span>
  <span class="n">y</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// Similarly, implement `Display` for `Point2D`</span>
<span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="k">for</span> <span class="n">Point2D</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
      <span class="c1">// Customize so only `x` and `y` are denoted.</span>
      <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"x: {}, y: {}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.x</span><span class="p">,</span> <span class="k">self</span><span class="py">.y</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">minmax</span> <span class="o">=</span> <span class="nf">MinMax</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">14</span><span class="p">);</span>

  <span class="nd">println!</span><span class="p">(</span><span class="s">"Compare structures:"</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Display: {}"</span><span class="p">,</span> <span class="n">minmax</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Debug: {:?}"</span><span class="p">,</span> <span class="n">minmax</span><span class="p">);</span>

  <span class="k">let</span> <span class="n">big_range</span> <span class="o">=</span>   <span class="nf">MinMax</span><span class="p">(</span><span class="o">-</span><span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">);</span>
  <span class="k">let</span> <span class="n">small_range</span> <span class="o">=</span> <span class="nf">MinMax</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

  <span class="nd">println!</span><span class="p">(</span><span class="s">"The big range is {big} and the small is {small}"</span><span class="p">,</span>
            <span class="n">small</span> <span class="o">=</span> <span class="n">small_range</span><span class="p">,</span>
            <span class="n">big</span> <span class="o">=</span> <span class="n">big_range</span><span class="p">);</span>

  <span class="k">let</span> <span class="n">point</span> <span class="o">=</span> <span class="n">Point2D</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mf">3.3</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">7.2</span> <span class="p">};</span>

  <span class="nd">println!</span><span class="p">(</span><span class="s">"Compare points:"</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Display: {}"</span><span class="p">,</span> <span class="n">point</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Debug: {:?}"</span><span class="p">,</span> <span class="n">point</span><span class="p">);</span>

  <span class="c1">// Error. Both `Debug` and `Display` were implemented, but `{:b}`</span>
  <span class="c1">// requires `fmt::Binary` to be implemented. This will not work.</span>
  <span class="c1">// println!("What does Point2D look like in binary: {:b}?", point);</span>
  
<span class="p">}</span>
</code></pre></div></div>
<p>So, <code class="language-plaintext highlighter-rouge">fmt::Display</code> has been implemented but <code class="language-plaintext highlighter-rouge">fmt::Binary</code> has not, and therefore cannot be used. 
<code class="language-plaintext highlighter-rouge">std::fmt</code> has many such traits and each requires its own implementation. This is detailed further in std::fmt.</p>

<h3 id="activity-1">Activity</h3>
<p>After checking the output of the above example, use the <code class="language-plaintext highlighter-rouge">Point2D</code> struct as a guide to add a <code class="language-plaintext highlighter-rouge">Complex</code> struct to the example. 
When printed in the same way, the output should be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Display: 3.3 + 7.2i
Debug: Complex { real: 3.3, imag: 7.2 }
</code></pre></div></div>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Add sturct and Implemnet Display trait</span>
<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Complex</span> <span class="p">{</span>
  <span class="n">real</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span>
  <span class="n">imag</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="k">for</span> <span class="n">Complex</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
      <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{} + {}i"</span><span class="p">,</span> <span class="k">self</span><span class="py">.real</span><span class="p">,</span> <span class="k">self</span><span class="py">.imag</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">complex</span> <span class="o">=</span> <span class="n">Complex</span> <span class="p">{</span> <span class="n">real</span><span class="p">:</span> <span class="mf">3.3</span><span class="p">,</span> <span class="n">imag</span><span class="p">:</span> <span class="mf">7.2</span> <span class="p">};</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Display: {}"</span><span class="p">,</span> <span class="n">complex</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Debug: {:?}"</span><span class="p">,</span> <span class="n">complex</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>See also:
<a href="https://doc.rust-lang.org/rust-by-example/trait/derive.html">derive</a>, 
<a href="https://doc.rust-lang.org/std/fmt/">std::fmt</a>, 
<a href="https://doc.rust-lang.org/rust-by-example/macros.html">macros</a>, 
<a href="https://doc.rust-lang.org/rust-by-example/custom_types/structs.html">struct</a>, 
<a href="https://doc.rust-lang.org/std/fmt/#formatting-traits">trait</a>, and 
<a href="https://doc.rust-lang.org/rust-by-example/mod/use.html">use</a></p>

<h3 id="1221-testcase-list">1.2.2.1 Testcase: List</h3>

<p>Implementing <code class="language-plaintext highlighter-rouge">fmt::Display</code> for a structure where the elements must each be handled sequentially is tricky. 
The problem is that each <code class="language-plaintext highlighter-rouge">write!</code> generates a <code class="language-plaintext highlighter-rouge">fmt::Result</code>. Proper handling of this requires dealing with <em>all</em> the results. 
Rust provides the <code class="language-plaintext highlighter-rouge">?</code> operator for exactly this purpose.</p>

<p>Using <code class="language-plaintext highlighter-rouge">?</code> on <code class="language-plaintext highlighter-rouge">write!</code> looks like this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Try `write!` to see if it errors. If it errors, return</span>
<span class="c1">// the error. Otherwise continue.</span>
<span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
</code></pre></div></div>

<p>With <code class="language-plaintext highlighter-rouge">?</code> available, implementing <code class="language-plaintext highlighter-rouge">fmt::Display</code> for a Vec is straightforward:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fmt</span><span class="p">;</span> <span class="c1">// Import the `fmt` module.</span>

<span class="c1">// Define a structure named `List` containing a `Vec`.</span>
<span class="k">struct</span> <span class="nf">List</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">);</span>

<span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="k">for</span> <span class="n">List</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
      <span class="c1">// Extract the value using tuple indexing,</span>
      <span class="c1">// and create a reference to `vec`.</span>
      <span class="k">let</span> <span class="n">vec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="na">.0</span><span class="p">;</span>

      <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"["</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

      <span class="c1">// Iterate over `v` in `vec` while enumerating the iteration</span>
      <span class="c1">// count in `count`.</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">in</span> <span class="n">vec</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
          <span class="c1">// For every element except the first, add a comma.</span>
          <span class="c1">// Use the ? operator to return on errors.</span>
          <span class="k">if</span> <span class="n">count</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">", "</span><span class="p">)</span><span class="o">?</span><span class="p">;</span> <span class="p">}</span>
          <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">// Close the opened bracket and return a fmt::Result value.</span>
      <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"]"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nf">List</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="activity-2">Activity</h3>
<p>Try changing the program so that the index of each element in the vector is also printed. The new output should look like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[0: 1, 1: 2, 2: 3]
</code></pre></div></div>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// --snip -- </span>
  <span class="c1">// Iterate over `v` in `vec` while enumerating the iteration</span>
  <span class="c1">// count in `count`.</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">in</span> <span class="n">vec</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
      <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}: {}"</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
      <span class="k">if</span> <span class="n">vec</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">count</span> <span class="p">{</span> <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">", "</span><span class="p">)</span><span class="o">?</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// -- snip --</span>
</code></pre></div></div>

<p>See also:
<a href="https://doc.rust-lang.org/rust-by-example/flow_control/for.html">for</a>,
<a href="https://doc.rust-lang.org/rust-by-example/scope/borrow/ref.html">ref</a>, 
<a href="https://doc.rust-lang.org/rust-by-example/std/result.html">Result</a>, 
<a href="https://doc.rust-lang.org/rust-by-example/custom_types/structs.html">struct</a>, 
<a href="https://doc.rust-lang.org/rust-by-example/std/result/question_mark.html">?</a>, and 
<a href="https://doc.rust-lang.org/rust-by-example/std/vec.html">vec!</a></p>

<h3 id="123-formatting">1.2.3. Formatting</h3>
<p>We’ve seen that formatting is specified via a <em>format string</em>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">format!("{}", foo)</code> -&gt; <code class="language-plaintext highlighter-rouge">"3735928559"</code></li>
  <li><code class="language-plaintext highlighter-rouge">format!("0x{:X}", foo)</code> -&gt; <code class="language-plaintext highlighter-rouge">"0xDEADBEEF"</code></li>
  <li><code class="language-plaintext highlighter-rouge">format!("0o{:o}", foo)</code> -&gt; <code class="language-plaintext highlighter-rouge">"0o33653337357"</code>
The same variable (<code class="language-plaintext highlighter-rouge">foo</code>) can be formatted differently depending on which argument type is used: <code class="language-plaintext highlighter-rouge">X</code> vs <code class="language-plaintext highlighter-rouge">o</code> vs unspecified.</li>
</ul>

<p>This formatting functionality is implemented via traits, and there is one trait for each argument type. 
The most common formatting trait is <code class="language-plaintext highlighter-rouge">Display</code>, which handles cases where the argument type is left unspecified: <code class="language-plaintext highlighter-rouge">{}</code> for instance.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::{</span><span class="k">self</span><span class="p">,</span> <span class="n">Formatter</span><span class="p">,</span> <span class="n">Display</span><span class="p">};</span>

<span class="k">struct</span> <span class="n">City</span> <span class="p">{</span>
  <span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span><span class="p">,</span>
  <span class="c1">// Latitude</span>
  <span class="n">lat</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>
  <span class="c1">// Longitude</span>
  <span class="n">lon</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Display</span> <span class="k">for</span> <span class="n">City</span> <span class="p">{</span>
  <span class="c1">// `f` is a buffer, and this method must write the formatted string into it</span>
  <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">lat_c</span> <span class="o">=</span> <span class="k">if</span> <span class="k">self</span><span class="py">.lat</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="p">{</span> <span class="sc">'N'</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="sc">'S'</span> <span class="p">};</span>
      <span class="k">let</span> <span class="n">lon_c</span> <span class="o">=</span> <span class="k">if</span> <span class="k">self</span><span class="py">.lon</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="p">{</span> <span class="sc">'E'</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="sc">'W'</span> <span class="p">};</span>

      <span class="c1">// `write!` is like `format!`, but it will write the formatted string</span>
      <span class="c1">// into a buffer (the first argument)</span>
      <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}: {:.3}°{} {:.3}°{}"</span><span class="p">,</span>
              <span class="k">self</span><span class="py">.name</span><span class="p">,</span> <span class="k">self</span><span class="py">.lat</span><span class="nf">.abs</span><span class="p">(),</span> <span class="n">lat_c</span><span class="p">,</span> <span class="k">self</span><span class="py">.lon</span><span class="nf">.abs</span><span class="p">(),</span> <span class="n">lon_c</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Color</span> <span class="p">{</span>
  <span class="n">red</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
  <span class="n">green</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
  <span class="n">blue</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">city</span> <span class="k">in</span> <span class="p">[</span>
      <span class="n">City</span> <span class="p">{</span> <span class="n">name</span><span class="p">:</span> <span class="s">"Dublin"</span><span class="p">,</span> <span class="n">lat</span><span class="p">:</span> <span class="mf">53.347778</span><span class="p">,</span> <span class="n">lon</span><span class="p">:</span> <span class="o">-</span><span class="mf">6.259722</span> <span class="p">},</span>
      <span class="n">City</span> <span class="p">{</span> <span class="n">name</span><span class="p">:</span> <span class="s">"Oslo"</span><span class="p">,</span> <span class="n">lat</span><span class="p">:</span> <span class="mf">59.95</span><span class="p">,</span> <span class="n">lon</span><span class="p">:</span> <span class="mf">10.75</span> <span class="p">},</span>
      <span class="n">City</span> <span class="p">{</span> <span class="n">name</span><span class="p">:</span> <span class="s">"Vancouver"</span><span class="p">,</span> <span class="n">lat</span><span class="p">:</span> <span class="mf">49.25</span><span class="p">,</span> <span class="n">lon</span><span class="p">:</span> <span class="o">-</span><span class="mf">123.1</span> <span class="p">},</span>
  <span class="p">]</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
      <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="o">*</span><span class="n">city</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="n">color</span> <span class="k">in</span> <span class="p">[</span>
      <span class="n">Color</span> <span class="p">{</span> <span class="n">red</span><span class="p">:</span> <span class="mi">128</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mi">255</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mi">90</span> <span class="p">},</span>
      <span class="n">Color</span> <span class="p">{</span> <span class="n">red</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mi">254</span> <span class="p">},</span>
      <span class="n">Color</span> <span class="p">{</span> <span class="n">red</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mi">0</span> <span class="p">},</span>
  <span class="p">]</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// Switch this to use {} once you've added an implementation</span>
      <span class="c1">// for fmt::Display.</span>
      <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="o">*</span><span class="n">color</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>
<p>You can view a full list of formatting traits and their argument types in the <code class="language-plaintext highlighter-rouge">std::fmt</code> documentation.</p>

<h3 id="activity-3">Activity</h3>
<p>Add an implementation of the <code class="language-plaintext highlighter-rouge">fmt::Display</code> trait for the <code class="language-plaintext highlighter-rouge">Color</code> struct above so that the output displays as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RGB (128, 255, 90) 0x80FF5A
RGB (0, 3, 254) 0x0003FE
RGB (0, 0, 0) 0x000000
Two hints if you get stuck:
</code></pre></div></div>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::{</span><span class="k">self</span><span class="p">,</span> <span class="n">Formatter</span><span class="p">,</span> <span class="n">Display</span><span class="p">};</span>

<span class="k">impl</span> <span class="n">Display</span> <span class="k">for</span> <span class="n">Color</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
      <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"RGB ({}, {}, {}) 0x{:0&gt;2X}{:0&gt;2X}{:0&gt;2X}"</span><span class="p">,</span>
              <span class="k">self</span><span class="py">.red</span><span class="p">,</span> <span class="k">self</span><span class="py">.green</span><span class="p">,</span> <span class="k">self</span><span class="py">.blue</span><span class="p">,</span>
              <span class="k">self</span><span class="py">.red</span><span class="p">,</span> <span class="k">self</span><span class="py">.green</span><span class="p">,</span> <span class="k">self</span><span class="py">.blue</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Color</span> <span class="p">{</span>
  <span class="n">red</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
  <span class="n">green</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
  <span class="n">blue</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">color</span> <span class="k">in</span> <span class="p">[</span>
      <span class="n">Color</span> <span class="p">{</span> <span class="n">red</span><span class="p">:</span> <span class="mi">128</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mi">255</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mi">90</span> <span class="p">},</span>
      <span class="n">Color</span> <span class="p">{</span> <span class="n">red</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mi">254</span> <span class="p">},</span>
      <span class="n">Color</span> <span class="p">{</span> <span class="n">red</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mi">0</span> <span class="p">},</span>
  <span class="p">]</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// Switch this to use {} once you've added an implementation</span>
      <span class="c1">// for fmt::Display.</span>
      <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="o">*</span><span class="n">color</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>You <a href="https://doc.rust-lang.org/std/fmt/#named-parameters">may need to list each color more than once</a>,
You can <a href="https://doc.rust-lang.org/std/fmt/#width">pad with zeros to a width of 2</a> with :0&gt;2.</p>

<p>See also:
<a href="https://doc.rust-lang.org/std/fmt/">std::fmt</a></p>]]></content><author><name>JJungs-lee</name></author><category term="RUST by Example" /><category term="Rust" /><category term="Example" /><summary type="html"><![CDATA[This is the source code of the traditional Hello World program.]]></summary></entry><entry><title type="html">Dev Setting - Settings Sync</title><link href="https://jjungs-lee.github.io//vs%20code/VSCODE-Dev-set(Settings-Sync)/" rel="alternate" type="text/html" title="Dev Setting - Settings Sync" /><published>2021-12-01T00:00:00+00:00</published><updated>2021-12-01T00:00:00+00:00</updated><id>https://jjungs-lee.github.io//vs%20code/VSCODE%20-%20Dev%20set(Settings%20Sync)</id><content type="html" xml:base="https://jjungs-lee.github.io//vs%20code/VSCODE-Dev-set(Settings-Sync)/"><![CDATA[<p>I have a trouble cuz the development settings at home and at work are different.
It’s so inconvenient. So I’m trying to use syncing up settings(vscode plugin) on multiple devices.</p>

<h2 id="how-synchronize-configurations-to-multiple-devices">How synchronize configurations to multiple devices?</h2>
<h3 id="1-install-settings-sync-plugin">1. install Settings Sync plugin</h3>
<p><img src="/assets/images/vscode/settings_sync_1.png" alt="Figure 1" /></p>

<h3 id="2-create-a-github-token">2. Create a github token</h3>
<ul>
  <li>2-1. Login Github / go to <code class="language-plaintext highlighter-rouge">Settings &gt; Developeer settings &gt; Personal access tokens</code></li>
  <li>2-2. Click <code class="language-plaintext highlighter-rouge">Generate new token</code> <br />
<img src="/assets/images/vscode/settings_sync_2.png" alt="Figure 2" /></li>
  <li>2-3. Select <code class="language-plaintext highlighter-rouge">expiration</code> then <code class="language-plaintext highlighter-rouge">click to gist</code></li>
  <li>2-4. Copy token number</li>
</ul>

<h3 id="3-create-github-gist-id">3. Create Github Gist id</h3>
<ul>
  <li>3-1. Go to Gist page(<a href="https://gist.github.com" target="_blank">https://gist.github.com</a>) and login.</li>
  <li>3-2. Create as below &amp; click <code class="language-plaintext highlighter-rouge">Create secret gist</code>
<img src="/assets/images/vscode/settings_sync_3.png" alt="Figure 3" /></li>
  <li>3-3. Copy gist id (included URL)
    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// example
https://gist.github.com/<span class="o">{</span>your github <span class="nb">id</span><span class="o">}</span>/<span class="o">{</span>your gist <span class="nb">id</span><span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="4-update-settingsjson-in-vscode">4. Update settings.json in VScode</h3>
<p>Write down the Gist id from step 3.</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">   </span><span class="nl">"sync.gist"</span><span class="p">:</span><span class="w"> </span><span class="s2">"your gist id"</span><span class="err">,</span><span class="w">
    </span><span class="nl">"sync.autoDownload"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="err">,</span><span class="w">
    </span><span class="nl">"sync.autoUpload"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="err">,</span><span class="w">
    </span><span class="nl">"sync.forceDownload"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="err">,</span><span class="w">
    </span><span class="nl">"sync.forceUpload"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="err">,</span><span class="w">
    </span><span class="nl">"sync.quietSync"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="err">,</span><span class="w">
    </span><span class="nl">"sync.removeExtensions"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="err">,</span><span class="w">
    </span><span class="nl">"sync.syncExtensions"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></code></pre></div></div>

<h3 id="5-update-synclocalsettingsjson-in-vscode">5. Update syncLocalSettings.json in VScode</h3>
<p>Write down the Github token id from step 2.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"ignoreUploadFiles"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="s2">"state.*"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"syncLocalSettings.json"</span><span class="p">,</span><span class="w">
        </span><span class="s2">".DS_Store"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"sync.lock"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"projects.json"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"projects_cache_vscode.json"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"projects_cache_git.json"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"projects_cache_svn.json"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"gpm_projects.json"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"gpm-recentItems.json"</span><span class="w">
    </span><span class="p">],</span><span class="w">
    </span><span class="nl">"ignoreUploadFolders"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="s2">"workspaceStorage"</span><span class="w">
    </span><span class="p">],</span><span class="w">
    </span><span class="nl">"ignoreExtensions"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
    </span><span class="nl">"gistDescription"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Visual Studio Code Settings Sync Gist"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="mi">343</span><span class="p">,</span><span class="w">
    </span><span class="nl">"token"</span><span class="p">:</span><span class="w"> </span><span class="s2">"YOUR_GITHUB_TOKEN"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"downloadPublicGist"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
    </span><span class="nl">"supportedFileExtensions"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="s2">"json"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"code-snippets"</span><span class="w">
    </span><span class="p">],</span><span class="w">
    </span><span class="nl">"openTokenLink"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
    </span><span class="nl">"disableUpdateMessage"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
    </span><span class="nl">"lastUpload"</span><span class="p">:</span><span class="w"> </span><span class="s2">"null"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"lastDownload"</span><span class="p">:</span><span class="w"> </span><span class="s2">"null"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"githubEnterpriseUrl"</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span><span class="w">
    </span><span class="nl">"askGistDescription"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
    </span><span class="nl">"customFiles"</span><span class="p">:</span><span class="w"> </span><span class="p">{},</span><span class="w">
    </span><span class="nl">"hostName"</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span><span class="w">
    </span><span class="nl">"universalKeybindings"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
    </span><span class="nl">"autoUploadDelay"</span><span class="p">:</span><span class="w"> </span><span class="mi">20</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h3 id="6-upload-your-setting-to-gist">6. Upload your setting to Gist</h3>
<p>Press <code class="language-plaintext highlighter-rouge">Shift + Alt + U</code> (macOS: <code class="language-plaintext highlighter-rouge">Shift + Option + U</code>)</p>

<h3 id="7-download-setting">7. Download Setting</h3>
<p>Press <code class="language-plaintext highlighter-rouge">Shift + Alt + D</code> (macOS: <code class="language-plaintext highlighter-rouge">Shift + Option + D</code>)</p>

<h3 id="notes">Notes.</h3>
<ol>
  <li>File path (settings.json / syncLocalSettings.json)
    <ul>
      <li>Windows : %APPDATA%\Code\User</li>
      <li>MAX : $HOME/Library/Application Support/Code/User</li>
    </ul>
  </li>
</ol>]]></content><author><name>JJungs-lee</name></author><category term="VS Code" /><category term="IDE" /><category term="Sync up" /><category term="settings Sync" /><category term="Plugin" /><summary type="html"><![CDATA[I have a trouble cuz the development settings at home and at work are different. It’s so inconvenient. So I’m trying to use syncing up settings(vscode plugin) on multiple devices.]]></summary></entry><entry><title type="html">Github Actions: Setting for CI server</title><link href="https://jjungs-lee.github.io//github%20pages/Github-actions/" rel="alternate" type="text/html" title="Github Actions: Setting for CI server" /><published>2021-06-18T00:00:00+00:00</published><updated>2021-06-18T00:00:00+00:00</updated><id>https://jjungs-lee.github.io//github%20pages/Github%20actions</id><content type="html" xml:base="https://jjungs-lee.github.io//github%20pages/Github-actions/"><![CDATA[<p>In the past, When distributing the homepage was using CI called <strong>travis</strong>.</p>

<p>A few days ago, I modified the page and pushed it. 
But automatic distribution did not work, so i went to the travis homepage. 
There was a notice like the one below.
All the projects were read-only, nothing could be done.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Since June 15th, 2021, the building on travis-ci.org is ceased. 
Please use travis-ci.com from now on.
Travis CI - Test and Deploy Your Code with Confidence is in read-only mode. 
The historical data can be downloaded to external file storage.
</code></pre></div></div>
<p>As an announcement, I am trying to move the project to <code class="language-plaintext highlighter-rouge">travis.com</code>.
However, while setting it up, it didn’t work properly. 
So I decided to look for something else.</p>

<h2 id="github-action">Github Action</h2>
<h3 id="what-is-github-action">What is Github Action?</h3>
<p>Github Action is a tool that can automate software development <code class="language-plaintext highlighter-rouge">workflow</code> based on Github repository. 
Simply put, it is a <strong>CI/CD tool</strong> directly provided by Github.</p>

<p><code class="language-plaintext highlighter-rouge">Workflow</code> can directly create a desired workflow based on various events such as build, test, package, 
release, and deploy that occur in the Github repository.</p>

<p><code class="language-plaintext highlighter-rouge">Workflow</code> runs in Linux, macOS, and Windows environments hosted on Github called Runners. 
And you can run these Runners directly in the environment hosted by the user (self-hosted runner).</p>

<p><code class="language-plaintext highlighter-rouge">Workflows</code> shared by multiple people can be found in the Github marketplace, and you can create your own and share them.</p>

<p>⏳ <strong>How long can it be used?</strong><br />
Up to 20 workflows can be registered per repository. 
And it can be executed for up to 6 hours for each stage called Job that exists in the workflow, and is automatically stopped when it exceeds.</p>

<p>And according to the Github account plan, the number of jobs that can be executed simultaneously throughout the entire Git repository is determined.
If you call Github API within a job, you can do it up to 1,000 times per hour.</p>

<p>💵 <strong>How much is the usage fee?</strong><br />
Public storage is free, and private storage is billed after the free usage granted to the account.
Based on the full private storage of the Github free account, 500MB of storage and running time of up to 2,000 minutes are provided per month.</p>

<p>If you want more information, please visit below links.</p>
<ul>
  <li><a href="https://github.com/features/actions">https://github.com/features/actions</a></li>
  <li><a href="https://docs.github.com/en/actions">https://docs.github.com/en/actions</a></li>
</ul>

<p>The official guide provides several basic templates. When using travis CI to build and push deployment, using <code class="language-plaintext highlighter-rouge">Rakefile</code>.
And then jekyll theme, so I took the <code class="language-plaintext highlighter-rouge">Ruby</code> template and tried to change it little by little.</p>

<p>At first, I just looked at it as it is in <code class="language-plaintext highlighter-rouge">.travis.yml</code>, but the github page repo push didn’t work perfectly.
I think token seems to be the problem.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nothing to commit, working tree clean
remote: Permission to 
jjungs-lee/jjungs-lee.github.io.git denied to github-actions[bot].
fatal: unable to access 'https://github.com/jjungs-lee/jjungs-lee.github.io.git/'
: The requested URL returned error: 403
rake aborted!
</code></pre></div></div>
<p>I tried creating a new token, and setting the environment.
However, the permission denial continued, and it took about 2 days to trouble shooting.</p>

<p>After searching, I finally found the answer from the link below.
<a href="https://github.community/t/automating-push-to-public-repo/17742">Automating push to public repo</a><br />
There were various things such as setting <code class="language-plaintext highlighter-rouge">http</code> or something else. 
but i set the token and various in <code class="language-plaintext highlighter-rouge">actions/checkout@v2</code> and followed the example.
<a href="https://github.com/actions/checkout#checkout-multiple-repos-nested">Checkout multiple repos (nested)</a></p>

<p>After that, I checked that it was working properly and updated the CI server with it.</p>

<p>It was a long and hard task, but i’m glad i was able to learn something new. haha 😊</p>]]></content><author><name>JJungs-lee</name></author><category term="Github Pages" /><category term="CI" /><category term="Github Actions" /><category term="Automation" /><category term="Travis" /><summary type="html"><![CDATA[In the past, When distributing the homepage was using CI called travis.]]></summary></entry><entry><title type="html">Github Pages: Testing for local server</title><link href="https://jjungs-lee.github.io//github/Testing-for-local-server" rel="alternate" type="text/html" title="Github Pages: Testing for local server" /><published>2021-05-05T00:00:00+00:00</published><updated>2021-05-05T00:00:00+00:00</updated><id>https://jjungs-lee.github.io//github/Testing%20for%20local%20server</id><content type="html" xml:base="https://jjungs-lee.github.io//github/Testing-for-local-server"><![CDATA[<p>Before committing to github pages, you can upload your homepage locally through <strong>ruby</strong> and <strong>jekyll serve</strong>!</p>

<h2 id="installing-ruby--devkit--jekyll">Installing Ruby + Devkit &amp; Jekyll</h2>
<p>After downloading <a href="https://rubyinstaller.org/downloads/">Ruby</a>, open the ruby prompt and enter <code class="language-plaintext highlighter-rouge">gem install jekyll bundler</code> to proceed with the installation.<br />
After completing the installation, check if the installation was successful with <code class="language-plaintext highlighter-rouge">jekyll -v</code>.</p>

<h2 id="trobleshooting">TrobleShooting</h2>

<h3 id="1-using-bundle-exec-jekyll-serve-instead-of-jekyll-serve">1) Using <code class="language-plaintext highlighter-rouge">bundle exec jekyll serve</code> instead of <code class="language-plaintext highlighter-rouge">jekyll serve</code></h3>
<p>When I try to run <code class="language-plaintext highlighter-rouge">jekyll serve</code> command, sometimes I keep getting bundle errors. 
In this case, it can be easily solved by using the <code class="language-plaintext highlighter-rouge">bundle exec jekyll serve</code> command. 
It tells you what to do, so just follow the instructions in the <code class="language-plaintext highlighter-rouge">Ruby prompt</code>.</p>

<p>A message prompting you to bundle install or bundle update appears saying that bundle is not installed, so you can install it as it is.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>D:\jjungs-page&gt;jekyll serve
Traceback (most recent call last):
 10: from C:/Ruby26-x64/bin/jekyll:23:in `&lt;main&gt;'
  9: from C:/Ruby26-x64/bin/jekyll:23:in `load'
  8: from C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/jekyll-4.0.0/exe/jekyll:11:in `&lt;top (required)&gt;'
  7: from C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/jekyll-4.0.0/lib/jekyll/plugin_manager.rb:52:in `require_from_bundler'
  6: from C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/bundler-2.1.4/lib/bundler.rb:149:in `setup'
  5: from C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/bundler-2.1.4/lib/bundler/runtime.rb:26:in `setup'
  4: from C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/bundler-2.1.4/lib/bundler/runtime.rb:26:in `map'
  3: from C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/bundler-2.1.4/lib/bundler/spec_set.rb:147:in `each'
  2: from C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/bundler-2.1.4/lib/bundler/spec_set.rb:147:in `each'
  1: from C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/bundler-2.1.4/lib/bundler/runtime.rb:31:in `block in setup'
C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/bundler-2.1.4/lib/bundler/runtime.rb:312:in `check_for_activated_spec!': You have already activated i18n 1.7.0, 
but your Gemfile requires i18n 0.9.5. Prepending `bundle exec` to your command may solve this. (Gem::LoadError)
</code></pre></div></div>

<h3 id="2-change-gemfile-and-_configyml-files">2) Change <code class="language-plaintext highlighter-rouge">Gemfile</code> and <code class="language-plaintext highlighter-rouge">_config.yml</code> files</h3>
<p>If you get a message that your gemfile is a problem, updating Gemfile
To solve the problem, you can do one of the two below.</p>

<ul>
  <li>Comment out the gem to remove(using #)</li>
  <li>Add <code class="language-plaintext highlighter-rouge">Gem</code> to the <code class="language-plaintext highlighter-rouge">Gemfile</code>, and add it to the <code class="language-plaintext highlighter-rouge">plugins:</code> part of the<code class="language-plaintext highlighter-rouge"> _config.yml</code> file.</li>
</ul>

<h3 id="3-run-chcp-65001-cmd">3) run <code class="language-plaintext highlighter-rouge">chcp 65001</code> cmd</h3>
<p>If you get an <code class="language-plaintext highlighter-rouge">Invalid CP949 character "\xE2"</code> error message, this may be an encoding problem on <strong>Windows</strong>.</p>

<blockquote>
  <p>If you use UTF-8 encoding, Jekyll will break if a file starts with characters representing a BOM. 
Therefore, remove this sequence of bytes if it appears at the beginning of your file.<br />
refer : <a href="https://jekyllrb.com/docs/installation/windows/">jekyll page</a></p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>D:\jjungs-page&gt;bundle exec jekyll serve
Configuration file: D:/jjungs-page/_config.yml
            Source: D:/jjungs-page
       Destination: ./publishing
 Incremental build: disabled. Enable with --incremental
      Generating...
         AutoPages: Disabled/Not configured in site.config.
        Pagination: Complete, processed 2 pagination page(s)
       Jekyll Feed: Generating feed for posts
  Conversion error: Jekyll::Converters::Scss encountered an error while converting 'assets/css/main.scss':
                    Invalid CP949 character "\xE2" on line 54
jekyll 3.8.6 | Error:  Invalid CP949 character "\xE2" on line 54
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>D:\jjungs-page&gt;chcp 65001
Active code page: 65001

D:\jjungs-page&gt;bundle exec jekyll serve
</code></pre></div></div>

<h2 id="finish">Finish</h2>
<p>Go to local page(http://127.0.0.1:4000/) and testing local test. Then Update and pushing it.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>D:\jjungs-page&gt;bundle exec jekyll serve
Configuration file: D:/jjungs-page/_config.yml
            Source: D:/jjungs-page
       Destination: ./publishing
 Incremental build: disabled. Enable with --incremental
      Generating...
         AutoPages: Disabled/Not configured in site.config.
        Pagination: Complete, processed 2 pagination page(s)
       Jekyll Feed: Generating feed for posts
                    done in 6.677 seconds.
 Auto-regeneration: enabled for 'D:/jjungs-page'
    Server address: http://127.0.0.1:4000
  Server running... press ctrl-c to stop.
      Regenerating: 1 file(s) changed at 2021-05-05 22:2
</code></pre></div></div>]]></content><author><name>JJungs-lee</name></author><category term="Github Pages" /><category term="Github Pages" /><category term="minimal-mistakes theme" /><summary type="html"><![CDATA[Before committing to github pages, you can upload your homepage locally through ruby and jekyll serve!]]></summary></entry><entry><title type="html">Algorithm - SORT</title><link href="https://jjungs-lee.github.io//Algorithm/algorithm-Sort" rel="alternate" type="text/html" title="Algorithm - SORT" /><published>2021-02-28T00:00:00+00:00</published><updated>2021-02-28T00:00:00+00:00</updated><id>https://jjungs-lee.github.io//Algorithm/%5Balgorithm%5D%20Sort</id><content type="html" xml:base="https://jjungs-lee.github.io//Algorithm/algorithm-Sort"><![CDATA[<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="cp">#define ARR_SIZE sizeof(arr) / sizeof(int)
#define SWAP(a, b) { int temp = a; a = b; b = temp; }
</span>
<span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>

<span class="kt">void</span> <span class="n">quickSort</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">mergeSort</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Quick Sort</span>
  <span class="n">quickSort</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ARR_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

  <span class="c1">// Merge Sort</span>
  <span class="n">mergeSort</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ARR_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">quickSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span>
        <span class="n">l</span><span class="o">++</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="n">left</span><span class="p">)</span>
        <span class="n">r</span><span class="o">--</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SWAP</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">r</span><span class="p">]);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">SWAP</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">pivot</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">r</span><span class="p">]);</span>

    <span class="n">quickSort</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">quickSort</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">merge</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">mid</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">temp</span><span class="p">[</span><span class="n">idx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">temp</span><span class="p">[</span><span class="n">idx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">temp</span><span class="p">[</span><span class="n">idx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">temp</span><span class="p">[</span><span class="n">idx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">l</span><span class="o">++</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">delete</span><span class="p">[]</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">mergeSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

    <span class="n">mergeSort</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
    <span class="n">mergeSort</span><span class="p">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
    <span class="n">merge</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>JJungs-lee</name></author><category term="Algorithm" /><category term="Sort" /><category term="Quick Sort" /><category term="Merge Sort" /><summary type="html"><![CDATA[```cpp #include]]></summary></entry><entry><title type="html">Data Structure - HEAP</title><link href="https://jjungs-lee.github.io//Algorithm/Data-structure-Heap" rel="alternate" type="text/html" title="Data Structure - HEAP" /><published>2021-02-27T00:00:00+00:00</published><updated>2021-02-27T00:00:00+00:00</updated><id>https://jjungs-lee.github.io//Algorithm/%5BData%20structure%5D%20Heap</id><content type="html" xml:base="https://jjungs-lee.github.io//Algorithm/Data-structure-Heap"><![CDATA[<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="cp">#define SWAP(a, b) { int temp = a; a = b; b = temp; }
</span>
<span class="k">struct</span> <span class="nc">heap</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">tree</span><span class="p">[</span><span class="mi">40001</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

  <span class="kt">void</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">size</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">idx</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">!</span><span class="n">idx</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">top</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">// Push &amp; Pop</span>
  <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tree</span><span class="p">[</span><span class="o">++</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="p">],</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">pop</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">idx</span><span class="o">--</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">idx</span><span class="p">;)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">idx</span> <span class="o">||</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tree</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">idx</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Sort</span>
  <span class="kt">void</span> <span class="n">heapify</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">largest</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">tree</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">largest</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">largest</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">tree</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">largest</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">largest</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">largest</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">SWAP</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tree</span><span class="p">[</span><span class="n">largest</span><span class="p">]);</span>
      <span class="n">heapify</span><span class="p">(</span><span class="n">largest</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">buildHeap</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">heapify</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">heapSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">buildHeap</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">SWAP</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
      <span class="n">heapify</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">heap</span> <span class="n">h</span><span class="p">;</span>

  <span class="n">h</span><span class="p">.</span><span class="n">init</span><span class="p">();</span>
  <span class="n">h</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
  <span class="n">h</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">59</span><span class="p">);</span>
  <span class="n">h</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span>
  <span class="n">h</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
  <span class="n">h</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">h</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>

  <span class="n">h</span><span class="p">.</span><span class="n">heapSort</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="n">h</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>

  <span class="n">h</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
  <span class="n">h</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
  <span class="n">h</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
  <span class="n">h</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>JJungs-lee</name></author><category term="Algorithm" /><category term="Heap" /><category term="Priority Queue" /><category term="Max heap" /><category term="Min heap" /><summary type="html"><![CDATA[```cpp #include]]></summary></entry></feed>